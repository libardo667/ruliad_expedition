import { AMBIGUITY_QUEUE, RUN_STATE, activeTab, plotInited } from '../core/state.js';
import { showToast, updateAmbiguityQueueUIState } from './notifications.js';
import { escapeHtml } from '../core/utils.js';
import { openModal } from './modals.js';
import { applyAmbiguityDecisionToTerm, buildAmbiguityRetryTemplates, computeAmbiguityPriority, formatAmbiguityReason, getPendingAmbiguityCount, retryAmbiguityWithCustomQuery, retryAmbiguityWithTemplate, sortAmbiguityQueueInPlace } from '../grounding/ambiguity-queue.js';
import { renderPlot } from '../plot/plot-render.js';
import { buildStats } from '../plot/sidebar.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Source: ruliad_expedition_v1.1.html
// Module: js/ui/ambiguity-queue-ui.js

export function renderAmbiguityQueueModal(){
  const summaryEl=document.getElementById("ambiguity-summary");
  const listEl=document.getElementById("ambiguity-modal-content");
  if(!summaryEl||!listEl) return;
  const pending=getPendingAmbiguityCount();
  const resolved=Math.max(0,AMBIGUITY_QUEUE.length-pending);
  summaryEl.textContent=`${pending} pending | ${resolved} reviewed | ${AMBIGUITY_QUEUE.length} total | sorted by priority = centrality * (1 + contradictionBoost + emergentBoost) * ambiguitySeverity`;
  if(!AMBIGUITY_QUEUE.length){
    listEl.innerHTML="<div class=\"matrix-note\">No ambiguous Wolfram terms captured in this run.</div>";
    return;
  }
  listEl.innerHTML=AMBIGUITY_QUEUE.map((item,idx)=>{
    const reasons=(Array.isArray(item?.ambiguityReasons)?item.ambiguityReasons:[]).map(formatAmbiguityReason);
    const statusTag=item.reviewStatus==="pending"?"pending review":item.reviewStatus==="accepted_wa"?"accepted WA":item.reviewStatus==="kept_probe_only"?"kept probe-only":"retried";
    const statusCol=item.reviewStatus==="pending"?"#d97706":"#16a34a";
    const snippet=String(item?.snippet||item?.bestDefinition||item?.inputInterpretation||"").trim();
    const canAccept=Boolean(snippet);
    const assumptions=Array.isArray(item?.assumptions)?item.assumptions:[];
    const warnings=Array.isArray(item?.warnings)?item.warnings:[];
    const didYouMeans=Array.isArray(item?.didYouMeans)?item.didYouMeans:[];
    const priorityMeta=computeAmbiguityPriority(item);
    const templateRetries=buildAmbiguityRetryTemplates(item);
    const reasonHtml=reasons.map(r=>`<span class="tag strong">${escapeHtml(r)}</span>`).join("")||"<span class='tag'>unspecified ambiguity</span>";
    const confidenceText=Number.isFinite(Number(item.score))?` (${Number(item.score).toFixed(2)})`:"";
    const templateButtons=templateRetries.map(t=>`<button class="small-btn" type="button" data-amb-action="retry_template" data-amb-template="${escapeHtml(t.key)}" data-amb-index="${idx}" title="${escapeHtml(t.query)}">${escapeHtml(t.label)}</button>`).join("");
    const templatePreview=templateRetries.length?`<div class="evidence-meta">Templated rewrites: ${escapeHtml(templateRetries.map(t=>`${t.label}: ${t.query}`).join(" | "))}</div>`:"";
    return `<div class="evidence-card"><div class="evidence-top"><div><div class="evidence-title">${escapeHtml(item.termLabel||"(unlabeled term)")}</div><div class="evidence-meta">${escapeHtml(item.discName||"Unknown probe")}</div></div><div class="tag" style="border-color:${statusCol};color:${statusCol}">${escapeHtml(statusTag)}</div></div><div class="tag-row">${reasonHtml}<span class="tag">confidence: ${escapeHtml(item.confidence||"low")}${confidenceText}</span><span class="tag">priority: ${Number(priorityMeta.priority||0).toFixed(2)}</span><span class="tag">severity: ${Number(priorityMeta.ambiguitySeverity||0).toFixed(2)}</span><span class="tag">centrality: ${Number(priorityMeta.centrality||0).toFixed(2)}</span><span class="tag">type: ${escapeHtml(priorityMeta.termType||"unknown")}</span></div><div class="evidence-meta">Query: ${escapeHtml(item.query||"-")}</div><div class="evidence-meta">Snippet: ${escapeHtml(snippet||"(none)")}</div>${assumptions.length?`<div class="evidence-meta">Assumptions: ${escapeHtml(assumptions.slice(0,4).join(" | "))}</div>`:""}${didYouMeans.length?`<div class="evidence-meta">Alternatives: ${escapeHtml(didYouMeans.slice(0,4).join(" | "))}</div>`:""}${warnings.length?`<div class="evidence-meta">Warnings: ${escapeHtml(warnings.slice(0,3).join(" | "))}</div>`:""}${templatePreview}${item.reviewNote?`<div class="evidence-meta">Review note: ${escapeHtml(item.reviewNote)}</div>`:""}<div style="display:flex;gap:6px;flex-wrap:wrap;margin-top:6px"><button class="small-btn" type="button" data-amb-action="keep" data-amb-index="${idx}">KEEP PROBE-ONLY</button><button class="small-btn" type="button" data-amb-action="accept" data-amb-index="${idx}" ${canAccept?"":"disabled"}>ACCEPT WA RESULT</button><button class="small-btn" type="button" data-amb-action="retry" data-amb-index="${idx}">RETRY CUSTOM</button>${templateButtons}</div></div>`;
  }).join("");
}

export function showAmbiguityQueueModal(){renderAmbiguityQueueModal();openModal("ambiguity-modal");}

export async function onAmbiguityQueueClick(e){
  const btn=e.target.closest("[data-amb-action]");
  if(!btn) return;
  const action=String(btn.getAttribute("data-amb-action")||"").trim();
  const idx=Number(btn.getAttribute("data-amb-index"));
  if(!Number.isInteger(idx)||idx<0||idx>=AMBIGUITY_QUEUE.length) return;
  const item=AMBIGUITY_QUEUE[idx];
  if(!item) return;
  const asyncRetryAction=action==="retry"||action==="retry_template";
  if(asyncRetryAction) btn.disabled=true;
  try{
    if(action==="keep"){
      const ok=applyAmbiguityDecisionToTerm(item,"keep",{note:"Manual review chose probe-only text."});
      if(!ok){showToast("Term not found for this ambiguity entry.");}
      else{item.reviewStatus="kept_probe_only";item.reviewedAt=new Date().toISOString();item.reviewNote="Kept probe-only wording.";item.lastUpdated=item.reviewedAt;showToast("Applied: keep probe-only.");}
    }else if(action==="accept"){
      const ok=applyAmbiguityDecisionToTerm(item,"accept",{note:"Manual review accepted Wolfram result."});
      if(!ok){showToast("Term not found for this ambiguity entry.");}
      else{item.reviewStatus="accepted_wa";item.reviewedAt=new Date().toISOString();item.reviewNote="Accepted Wolfram grounding result.";item.lastUpdated=item.reviewedAt;showToast("Applied: accepted WA result.");}
    }else if(action==="retry"){
      await retryAmbiguityWithCustomQuery(item);
    }else if(action==="retry_template"){
      const templateKey=String(btn.getAttribute("data-amb-template")||"").trim().toLowerCase();
      await retryAmbiguityWithTemplate(item,templateKey);
    }
  }catch(err){
    console.error("Ambiguity queue action failed:",err);
    showToast(`Ambiguity action failed: ${err.message||err}`);
  }finally{
    if(asyncRetryAction) btn.disabled=false;
    if(RUN_STATE) RUN_STATE.ambiguityQueue=[...AMBIGUITY_QUEUE];
    sortAmbiguityQueueInPlace();
    updateAmbiguityQueueUIState();
    renderAmbiguityQueueModal();
    buildStats();
    if(plotInited&&activeTab==="plot"){renderPlot();}
  }
}
