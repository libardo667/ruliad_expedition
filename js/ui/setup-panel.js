import { COLORS, DEFAULT_DISCS } from '../core/constants.js';
import { MODE_STATE, SOURCE_MATERIAL, activeSetupMode, setActiveSetupMode, setSourceMaterial } from '../core/state.js';
import { LENS_CONFIGS, tokenize, scoreArticle, parseRecency, crossMentionCount, parseFeedItems, scoreArticleWithSeed, temporalRelevanceBonus, softScoreArticle, buildGoogleNewsRssUrl, generateSearchQueries, normalizeBraveResults, normalizeNewsApiResults, deduplicateArticles } from '../domain/news-sources.js';
import { discInputsEl } from '../core/refs.js';
import { clampInt, structuredCloneSafe } from '../core/utils.js';
import { showToast } from './notifications.js';
import { refreshPromptPreview, syncPromptPreviewDiscOptions } from './prompt-preview.js';
import { callLLM, callLLMJSON, getQualityProfile, readApiConfig, validateApiConfig } from '../api/llm.js';
import { extractJSON } from '../api/json-recovery.js';
import { buildLensGenerationPrompt, resolvePromptBundleWithOverrides } from '../prompt/prompt-system.js';

// Auto-generated by tools/decompose.mjs — edit freely after generation
// Module: js/ui/setup-panel.js

export function renderDisciplineInputs(count,seeds=[],colors=[]){const n=clampInt(count,2,12);discInputsEl.innerHTML="";for(let i=0;i<n;i++){const fallback=DEFAULT_DISCS[i%DEFAULT_DISCS.length];const val=(seeds[i]||fallback).trim();const col=colors[i]||COLORS[i%COLORS.length];const row=document.createElement("div");row.className="disc-row";row.innerHTML=`<span class="disc-num">${i+1}</span><div class="disc-color" style="background:${col}"></div><input class="disc-input" type="text" data-idx="${i}" data-color="${col}" value="${val}" placeholder="discipline ${i+1}"/><button class="mini-btn probe-del-btn" type="button" data-probe-del="${i}" title="Delete this probe">DEL</button>`;discInputsEl.appendChild(row);}const countEl=document.getElementById("lens-count-input");if(countEl) countEl.value=String(n);syncPromptPreviewDiscOptions();refreshPromptPreview();}

export function createSetupSection(title,helpText,open=false){
  const details=document.createElement("details");
  details.className="setup-section";
  if(open) details.open=true;
  const summary=document.createElement("summary");
  const label=document.createElement("span");
  label.textContent=title;
  const help=document.createElement("span");
  help.className="setup-help";
  help.textContent="?";
  help.setAttribute("title",helpText);
  help.setAttribute("aria-label",helpText);
  summary.append(label,help);
  const body=document.createElement("div");
  body.className="setup-section-body";
  details.append(summary,body);
  return {details,body};
}

export function findDirectChildBlock(root,controlId){
  const el=document.getElementById(controlId);
  if(!root||!el) return null;
  let node=el;
  while(node&&node.parentElement!==root){node=node.parentElement;}
  return node&&node.parentElement===root?node:null;
}

export function extractSetupBlocks(root,controlIds){
  const blocks=[];
  const seen=new Set();
  for(const id of (controlIds||[])){
    const block=findDirectChildBlock(root,id);
    if(!block||seen.has(block)) continue;
    seen.add(block);
    blocks.push(block);
  }
  return blocks;
}

export function applySetupTooltips(){
  const tooltipById={
    "target-input":"Primary concept to map across probes.",
    "api-mode":"Use proxy to avoid browser CORS and keep keys server-side.",
    "research-model-input":"Model used for probe and synthesis generation.",
    "api-key-input":"Only used in direct mode; not persisted to localStorage.",
    "embedding-model-input":"Model used to position nodes in semantic space.",
    "web-search-check":"Allows model responses to use web-grounded retrieval when supported.",
    "source-policy-input":"Source preference and exclusion instructions for the model.",
    "ca-probe-check":"Enable run-derived computational irreducibility diagnostics.",
    "ca-rule-input":"Optional manual override for rule (blank = auto-derived).",
    "ca-steps-input":"Optional manual override for steps (blank = auto-derived).",
    "ca-width-input":"Optional manual override for width (blank = auto-derived).",
    "quality-mode-select":"Balances speed vs depth and cleanup behavior.",
    "redteam-check":"Generate skeptical critique after synthesis.",
    "replication-models-input":"Comma-separated models for replication checks.",
    "replication-runs-input":"Number of reruns per model during replication.",
    "replication-strategy-select":"Fixed parameters or jittered temperature per run.",
    "lens-count-input":"How many orthogonal lenses to auto-generate.",
    "gen-lenses-btn":"Generate distinct probe lenses from the target concept."
  };
  for(const [id,text] of Object.entries(tooltipById)){
    const el=document.getElementById(id);
    if(!el) continue;
    if(!String(el.getAttribute("title")||"").trim()) el.setAttribute("title",text);
  }
}

export function initGenerationPanelQol(){
  if(document.getElementById("generation-workbench")){applySetupTooltips();return;}
  const configGroup=document.getElementById("api-mode")?.closest(".field-group");
  if(!configGroup||configGroup.dataset.qolEnhanced==="1") return;
  configGroup.dataset.qolEnhanced="1";
  const heading=configGroup.querySelector(":scope > label");
  if(heading) heading.textContent="RUN CONFIGURATION";
  const inlineThemeSelect=document.getElementById("theme-select");
  if(inlineThemeSelect){
    const inlineThemeRow=inlineThemeSelect.closest(".prefs-row");
    inlineThemeSelect.remove();
    if(inlineThemeRow) inlineThemeRow.classList.add("prefs-row-single");
  }
  const datalists=[...configGroup.querySelectorAll(":scope > datalist")];
  for(const dl of datalists){dl.remove();}
  const sections=[
    {
      title:"Models & Access",
      help:"Connection mode, model IDs, credentials, and source-policy defaults.",
      open:true,
      ids:["api-mode","api-key-input","embedding-model-input","web-search-check","source-policy-input","api-mode-note"]
    },
    {
      title:"Quality & Replication",
      help:"CA probe settings, quality profile, red-team pass, and replication controls.",
      open:false,
      ids:["ca-probe-check","ca-rule-input","ca-steps-input","ca-width-input","quality-mode-select","redteam-check","replication-models-input","replication-runs-input","replication-strategy-select"]
    }
  ];
  const stack=document.createElement("div");
  stack.className="setup-section-stack";
  const used=new Set();
  for(const sectionDef of sections){
    const section=createSetupSection(sectionDef.title,sectionDef.help,sectionDef.open);
    stack.appendChild(section.details);
    const blocks=extractSetupBlocks(configGroup,sectionDef.ids);
    for(const block of blocks){
      if(used.has(block)) continue;
      used.add(block);
      section.body.appendChild(block);
    }
  }
  const fallbackBody=stack.querySelector(".setup-section-body");
  for(const child of [...configGroup.children]){
    if(child===stack||datalists.includes(child)||child.tagName==="LABEL") continue;
    if(used.has(child)) continue;
    fallbackBody?.appendChild(child);
    used.add(child);
  }
  configGroup.appendChild(stack);
  for(const dl of datalists){configGroup.appendChild(dl);}
  applySetupTooltips();
}

export function initWorkbenchJumpNav(){
  const pane=document.getElementById("workbench-controls-pane");
  if(!pane) return;
  const buttons=Array.from(document.querySelectorAll("[data-workbench-jump]"));
  for(const btn of buttons){
    btn.addEventListener("click",()=>{
      const targetId=String(btn.getAttribute("data-workbench-jump")||"").trim();
      if(!targetId) return;
      const targetEl=document.getElementById(targetId);
      if(!targetEl) return;
      if(pane.contains(targetEl)){
        const paneRect=pane.getBoundingClientRect();
        const targetRect=targetEl.getBoundingClientRect();
        const nextTop=Math.max(0,pane.scrollTop+(targetRect.top-paneRect.top)-52);
        pane.scrollTo({top:nextTop,behavior:"smooth"});
      }else{
        targetEl.scrollIntoView({behavior:"smooth",block:"start"});
      }
      targetEl.classList.add("workbench-jump-highlight");
      setTimeout(()=>targetEl.classList.remove("workbench-jump-highlight"),900);
    });
  }
}

export function getCurrentProbeSpecs(){return Array.from(document.querySelectorAll(".disc-input")).map(el=>el.value.trim());}

export function addProbeSpec(){const specs=getCurrentProbeSpecs();if(specs.length>=12){showToast("Maximum probe count is 12.");return;}specs.push(`Probe ${specs.length+1}`);renderDisciplineInputs(specs.length,specs);}

export function onProbeActionClick(e){const btn=e.target.closest("[data-probe-del]");if(!btn) return;const idx=Number(btn.getAttribute("data-probe-del"));const specs=getCurrentProbeSpecs();if(specs.length<=2){showToast("At least 2 probes are required.");return;}if(Number.isNaN(idx)||idx<0||idx>=specs.length) return;specs.splice(idx,1);renderDisciplineInputs(specs.length,specs);}

export function toggleApiKey(){const input=document.getElementById("api-key-input");const btn=document.getElementById("toggle-key-btn");const show=input.type==="password";input.type=show?"text":"password";btn.textContent=show?"HIDE":"SHOW";}

export function clearApiKey(){const input=document.getElementById("api-key-input");input.value="";input.focus();}

export async function generateOrthogonalLenses(){const target=document.getElementById("target-input").value.trim();if(!target){showToast("Enter a target concept first.");return;}const count=clampInt(document.getElementById("lens-count-input")?.value,2,12);const cfg=readApiConfig();const cfgError=validateApiConfig(cfg);if(cfgError){showToast(cfgError);return;}const btn=document.getElementById("gen-lenses-btn");const prev=btn.textContent;btn.disabled=true;btn.textContent="GENERATING...";btn.classList.add("llm-busy");try{const defaults=buildLensGenerationPrompt(target,count,cfg);const built=resolvePromptBundleWithOverrides("lens_generation",{target,cfg,quality:getQualityProfile(cfg.qualityMode),defaults});const raw=await callLLMJSON(built.systemPrompt,built.userPrompt,cfg);const parsed=extractJSON(raw);let list=[];if(Array.isArray(parsed)) list=parsed;else if(Array.isArray(parsed.disciplines)) list=parsed.disciplines;else if(Array.isArray(parsed.lenses)) list=parsed.lenses;const cleaned=[];const seen=new Set();for(const item of list){const name=String(item||"").replace(/^\d+[\).\-\s]*/,"").trim();const key=name.toLowerCase();if(!name||seen.has(key)) continue;seen.add(key);cleaned.push(name);}while(cleaned.length<count){const fallback=DEFAULT_DISCS[cleaned.length%DEFAULT_DISCS.length];const key=fallback.toLowerCase();if(!seen.has(key)){seen.add(key);cleaned.push(fallback);}else{cleaned.push(`Lens ${cleaned.length+1}`);}}renderDisciplineInputs(count,cleaned.slice(0,count));showToast(`Generated ${count} orthogonal lenses.`);}catch(err){console.error("Lens generation failed:",err);showToast("Lens generation failed. Check key/model and try again.");}finally{btn.disabled=false;btn.textContent=prev;btn.classList.remove("llm-busy");refreshPromptPreview();}}

export function syncApiModeNote(){const mode=document.getElementById("api-mode").value;const note=document.getElementById("api-mode-note");if(mode==="proxy"){note.textContent="Proxy mode is backend-ready. Add server routes at /api/llm/chat/completions and /api/llm/embeddings.";}else{note.textContent="Direct mode sends model requests from this page (tab-memory key only). CA probe still simulates locally in direct mode.";}}

export function syncCAOverrideUI(){
  const enabled=Boolean(document.getElementById("ca-probe-check")?.checked);
  const group=document.getElementById("ca-override-group");
  if(group) group.style.display=enabled?"flex":"none";
}

// ── Per-mode state save/restore ───────────────────────────────────────────────

function captureModeState(){
  return {
    targetValue:document.getElementById("target-input")?.value||"",
    lensCount:document.getElementById("lens-count-input")?.value||"7",
    discSpecs:getCurrentProbeSpecs(),
    discColors:Array.from(document.querySelectorAll(".disc-input")).map(el=>el.dataset.color||""),
    seedUrl:document.getElementById("seed-url-input")?.value||"",
    anchorRowHtml:document.getElementById("seed-anchor-row")?.innerHTML||"",
    anchorRowVisible:document.getElementById("seed-anchor-row")?.style.display!=="none",
    sourceColumnsHtml:document.getElementById("source-columns")?.innerHTML||"",
    sourceColumnsVisible:document.getElementById("source-columns")?.style.display!=="none",
    sourceUseRowVisible:document.getElementById("source-use-row")?.style.display!=="none",
    sourceStatus:document.getElementById("source-status")?.textContent||"",
    lensSelectValue:document.getElementById("lens-select")?.value||"political",
    sourceMaterial:structuredCloneSafe(SOURCE_MATERIAL),
  };
}

function restoreModeState(snapshot){
  if(!snapshot) return;
  const targetEl=document.getElementById("target-input");
  if(targetEl) targetEl.value=snapshot.targetValue;
  renderDisciplineInputs(
    snapshot.discSpecs.length||7,
    snapshot.discSpecs,
    snapshot.discColors
  );
  const lensCountEl=document.getElementById("lens-count-input");
  if(lensCountEl) lensCountEl.value=snapshot.lensCount;
  const seedEl=document.getElementById("seed-url-input");
  if(seedEl) seedEl.value=snapshot.seedUrl;
  const anchorRow=document.getElementById("seed-anchor-row");
  if(anchorRow){anchorRow.innerHTML=snapshot.anchorRowHtml;anchorRow.style.display=snapshot.anchorRowVisible?"block":"none";}
  const sourceCols=document.getElementById("source-columns");
  if(sourceCols){sourceCols.innerHTML=snapshot.sourceColumnsHtml;sourceCols.style.display=snapshot.sourceColumnsVisible?"grid":"none";}
  const useRow=document.getElementById("source-use-row");
  if(useRow) useRow.style.display=snapshot.sourceUseRowVisible?"flex":"none";
  const statusEl=document.getElementById("source-status");
  if(statusEl) statusEl.textContent=snapshot.sourceStatus;
  const lensSelect=document.getElementById("lens-select");
  if(lensSelect) lensSelect.value=snapshot.lensSelectValue;
  setSourceMaterial(snapshot.sourceMaterial||{urls:[],text:"",titles:[],byDisc:{}});
}

function defaultModeState(mode){
  const base={
    targetValue:"",
    lensCount:"7",
    discSpecs:DEFAULT_DISCS.slice(0,7),
    discColors:COLORS.slice(0,7),
    seedUrl:"",
    anchorRowHtml:"",
    anchorRowVisible:false,
    sourceColumnsHtml:"",
    sourceColumnsVisible:false,
    sourceUseRowVisible:false,
    sourceStatus:"",
    lensSelectValue:"political",
    sourceMaterial:{urls:[],text:"",titles:[],byDisc:{}},
  };
  if(mode==="sources"){
    base.discSpecs=DEFAULT_DISCS.slice(0,3);
    base.discColors=COLORS.slice(0,3);
    base.lensCount="3";
  }
  return base;
}

function persistModeStateToSession(){
  try{
    const serializable={};
    for(const[mode,snap] of Object.entries(MODE_STATE)){
      if(!snap) continue;
      serializable[mode]={
        targetValue:snap.targetValue,
        lensCount:snap.lensCount,
        discSpecs:snap.discSpecs,
        discColors:snap.discColors,
        seedUrl:snap.seedUrl,
        lensSelectValue:snap.lensSelectValue,
      };
    }
    sessionStorage.setItem("parallax_mode_state",JSON.stringify(serializable));
  }catch{/* quota exceeded */}
}

export function initProgressiveDisclosure(){
  const workbench=document.getElementById("generation-workbench");
  const setup=document.getElementById("setup");
  const simpleBtn=document.getElementById("setup-mode-simple-btn");
  const sourcesBtn=document.getElementById("setup-mode-sources-btn");
  const advancedBtn=document.getElementById("setup-mode-advanced-btn");
  const promptToggleBtn=document.getElementById("setup-prompt-pane-btn");
  if(!workbench||!simpleBtn) return;

  function applyMode(mode,promptVisible){
    const isSimple=(mode==="simple");
    const isSources=(mode==="sources");
    const isAdvanced=(mode==="advanced");
    const isLanding=(mode==="landing");

    // Save current mode state before switching
    const prevMode=activeSetupMode;
    if(prevMode!=="landing"&&prevMode!==mode){
      MODE_STATE[prevMode]=captureModeState();
    }

    setup.classList.toggle("mode-landing",isLanding);
    setup.classList.toggle("simple-mode",isSimple);
    workbench.classList.toggle("simple-mode",isSimple);
    workbench.classList.toggle("sources-mode",isSources);
    workbench.classList.toggle("prompt-pane-hidden",isAdvanced&&!promptVisible);
    [simpleBtn,sourcesBtn,advancedBtn].forEach(b=>b&&b.classList.remove("mode-active"));
    if(isSimple) simpleBtn?.classList.add("mode-active");
    if(isSources) sourcesBtn?.classList.add("mode-active");
    if(isAdvanced) advancedBtn?.classList.add("mode-active");
    if(promptToggleBtn){
      promptToggleBtn.style.display=isAdvanced?"":"none";
      promptToggleBtn.textContent=promptVisible?"HIDE PROMPT EDITOR":"SHOW PROMPT EDITOR";
    }
    sessionStorage.setItem("parallax_setup_mode",mode);
    sessionStorage.setItem("parallax_prompt_pane_visible",String(promptVisible));

    // Restore target mode state after switching
    setActiveSetupMode(mode);
    if(!isLanding){
      const snapshot=MODE_STATE[mode];
      if(!snapshot&&mode==="advanced"&&MODE_STATE["simple"]){
        // Advanced inherits from Explore on first entry
        restoreModeState(MODE_STATE["simple"]);
      }else if(snapshot){
        restoreModeState(snapshot);
      }else{
        restoreModeState(defaultModeState(mode));
      }
      MODE_STATE[mode]=captureModeState();
    }
    persistModeStateToSession();
  }

  // Landing card buttons
  document.querySelectorAll("[data-mode]").forEach(btn=>{
    btn.addEventListener("click",()=>applyMode(btn.dataset.mode,false));
  });
  simpleBtn?.addEventListener("click",()=>applyMode("simple",false));
  sourcesBtn?.addEventListener("click",()=>applyMode("sources",false));
  advancedBtn?.addEventListener("click",()=>{
    const pv=sessionStorage.getItem("parallax_prompt_pane_visible")==="true";
    applyMode("advanced",pv);
  });
  promptToggleBtn?.addEventListener("click",()=>{
    const next=sessionStorage.getItem("parallax_prompt_pane_visible")!=="true";
    applyMode("advanced",next);
  });

  // Hard refresh (Ctrl+F5): navigation type is "reload" AND transferSize > 0
  // (page fetched from network, not cache). Normal F5 hits cache (transferSize 0)
  // so saved mode is preserved. Hard refresh clears it → landing page.
  const navEntry=performance?.getEntriesByType?.("navigation")?.[0];
  if(navEntry?.type==="reload"&&navEntry?.transferSize>0){
    sessionStorage.removeItem("parallax_setup_mode");
    sessionStorage.removeItem("parallax_prompt_pane_visible");
    sessionStorage.removeItem("parallax_mode_state");
  }

  // Restore lightweight per-mode state from sessionStorage (survives soft refresh)
  try{
    const raw=sessionStorage.getItem("parallax_mode_state");
    if(raw){
      const parsed=JSON.parse(raw);
      for(const mode of ["simple","sources","advanced"]){
        if(parsed[mode]) MODE_STATE[mode]={...defaultModeState(mode),...parsed[mode]};
      }
    }
  }catch{/* corrupt data */}

  const savedMode=sessionStorage.getItem("parallax_setup_mode")||"landing";
  const savedPV=sessionStorage.getItem("parallax_prompt_pane_visible")==="true";
  applyMode(savedMode,savedPV);
}

// ── News Lens: per-column runtime feed state (may be edited by user) ──────────
// Cloned from LENS_CONFIGS at panel init; user edits are session-only.
let _activeColumns = null; // [{id, label, color, feeds:[]}]
let _activePopover = null; // currently open feed-edit popover

function getLensColumns() {
  if (_activeColumns) return _activeColumns;
  const key = document.getElementById("lens-select")?.value || "political";
  if (key === "custom") return getCustomColumns();
  // Deep-clone so user edits don't mutate the config constant
  _activeColumns = LENS_CONFIGS[key].columns.map(c => ({ ...c, feeds: [...c.feeds] }));
  return _activeColumns;
}

function resetColumns() {
  _activeColumns = null;
}

function getCustomColumns() {
  const rows = document.querySelectorAll(".custom-col-row");
  const cols = [];
  rows.forEach((row, i) => {
    const label = row.querySelector("input[type=text]")?.value.trim() || `Column ${i + 1}`;
    const feedsRaw = row.querySelector("textarea")?.value || "";
    const feeds = feedsRaw.split("\n").map(u => u.trim()).filter(u => u.startsWith("http"));
    if (feeds.length) cols.push({ id: `custom-${i}`, label, color: "#94a3b8", feeds });
  });
  return cols;
}

async function postFetchUrl(urls) {
  const BATCH_SIZE = 10;
  if (urls.length <= BATCH_SIZE) {
    const resp = await fetch("/api/fetch-url", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ urls })
    });
    if (!resp.ok) throw new Error(`Proxy returned ${resp.status}. Is proxy mode active?`);
    return (await resp.json()).results || [];
  }
  // Multi-batch: chunk urls into groups, fetch in parallel
  const batches = [];
  for (let i = 0; i < urls.length; i += BATCH_SIZE) {
    batches.push(urls.slice(i, i + BATCH_SIZE));
  }
  const batchResults = await Promise.all(batches.map(async batch => {
    const resp = await fetch("/api/fetch-url", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ urls: batch })
    });
    if (!resp.ok) throw new Error(`Proxy returned ${resp.status}. Is proxy mode active?`);
    return (await resp.json()).results || [];
  }));
  return batchResults.flat();
}

function setSourceStatus(msg, cls = "") {
  const el = document.getElementById("source-status");
  if (!el) return;
  el.className = "source-status" + (cls ? ` ${cls}` : "");
  el.textContent = msg;
}

function updateSelectionNote() {
  const columns = getLensColumns();
  const total = columns.length;
  const countByCol = {};
  for (const col of columns) countByCol[col.id] = 0;
  document.querySelectorAll(".source-pick-card.selected").forEach(el => {
    if (countByCol[el.dataset.col] !== undefined) countByCol[el.dataset.col]++;
  });
  const counts = Object.values(countByCol);
  const totalSelected = counts.reduce((s, n) => s + n, 0);

  // Update selection note text
  const note = document.getElementById("source-selection-note");
  const unrepresented = counts.filter(n => n === 0).length;
  if (note) {
    if (totalSelected === 0) {
      note.textContent = "Select articles to continue.";
      note.style.color = "var(--muted)";
    } else if (unrepresented > 0) {
      note.textContent = `${unrepresented} perspective${unrepresented > 1 ? "s" : ""} unrepresented — coverage may be skewed.`;
      note.style.color = "#f59e0b";
    } else {
      note.textContent = `All ${total} perspectives covered.`;
      note.style.color = "#16a34a";
    }
  }

}

function openFeedEditPopover(btn, col) {
  closePopover();
  const popover = document.createElement("div");
  popover.className = "source-edit-popover";
  popover.setAttribute("role", "dialog");
  popover.innerHTML = `<div class="source-edit-title">FEEDS FOR ${col.label.toUpperCase()}</div>`;
  const warningShown = { shown: false };

  function showEditWarning() {
    if (warningShown.shown) return;
    warningShown.shown = true;
    showToast("Modifying default sources may reduce balance across perspectives.");
  }

  function renderFeeds() {
    const existing = popover.querySelectorAll(".source-feed-row");
    existing.forEach(el => el.remove());
    const addRow = popover.querySelector(".source-edit-add-row");
    for (const feedUrl of col.feeds) {
      const row = document.createElement("div");
      row.className = "source-feed-row";
      const label = document.createElement("span");
      label.style.flex = "1";
      label.textContent = feedUrl.replace(/^https?:\/\//, "").slice(0, 40);
      label.title = feedUrl;
      const removeBtn = document.createElement("button");
      removeBtn.className = "mini-btn";
      removeBtn.textContent = "✕";
      removeBtn.addEventListener("click", () => {
        showEditWarning();
        col.feeds = col.feeds.filter(f => f !== feedUrl);
        renderFeeds();
      });
      row.append(label, removeBtn);
      popover.insertBefore(row, addRow);
    }
  }

  const addRow = document.createElement("div");
  addRow.className = "source-edit-add-row";
  const addInput = document.createElement("input");
  addInput.type = "text";
  addInput.placeholder = "https://feeds.example.com/rss";
  const addBtn = document.createElement("button");
  addBtn.className = "mini-btn";
  addBtn.textContent = "ADD";
  addBtn.addEventListener("click", () => {
    const url = addInput.value.trim();
    if (!url.startsWith("http")) { showToast("Enter a valid http(s) URL."); return; }
    if (col.feeds.includes(url)) return;
    showEditWarning();
    col.feeds.push(url);
    addInput.value = "";
    renderFeeds();
  });
  addRow.append(addInput, addBtn);
  popover.appendChild(addRow);
  renderFeeds();

  // Position below the edit button
  const rect = btn.getBoundingClientRect();
  popover.style.top = `${rect.bottom + window.scrollY + 4}px`;
  popover.style.left = `${Math.max(4, rect.left + window.scrollX - 60)}px`;
  document.body.appendChild(popover);
  _activePopover = popover;

  // Close on outside click
  setTimeout(() => {
    document.addEventListener("click", closePopoverOnOutside, { once: false });
  }, 10);
}

function closePopoverOnOutside(e) {
  if (_activePopover && !_activePopover.contains(e.target)) {
    closePopover();
    document.removeEventListener("click", closePopoverOnOutside);
  }
}

function closePopover() {
  if (_activePopover) { _activePopover.remove(); _activePopover = null; }
}

function makeSourceCard(art, col) {
  const card = document.createElement("div");
  card.className = "evidence-card source-pick-card";
  card.dataset.col = col.id;
  card.dataset.colLabel = col.label;
  card.dataset.link = art.link;
  card.dataset.title = art.title;
  card.dataset.description = art.description || "";

  let outlet = "";
  try { outlet = art.link ? new URL(art.link).hostname.replace(/^www\./, "") : ""; } catch {}
  const snippetShort = (art.description || "").slice(0, 120);
  const snippetFull = art.description || "";
  const hasMore = snippetFull.length > 120;

  card.innerHTML = `
    <div class="card-select-row">
      <div class="evidence-top" style="flex:1;min-width:0">
        <div class="evidence-title">${escHtml(art.title)}</div>
        <div class="evidence-meta">${escHtml(outlet)} · ${escHtml(art.recency.label)}</div>
      </div>
    </div>
    <div class="tag-row">
      <span class="tag ${art.relevance > 50 ? "strong" : ""}">Relevance: ${art.relevance}%</span>
      <span class="tag">Cross-coverage: ${art.mentions}</span>
    </div>
    <div class="source-card-snippet">
      <span class="snippet-short">${escHtml(snippetShort)}${hasMore ? "…" : ""}</span>
      <span class="snippet-full" style="display:none">${escHtml(snippetFull)}</span>
      ${hasMore ? `<button class="source-expand-btn mini-link-btn" type="button">Show more</button>` : ""}
    </div>`;

  // Click = toggle selection; hold-click (300ms+) = expand/collapse snippet
  let pressTimer = null;
  let didHold = false;
  card.addEventListener("pointerdown", e => {
    if (e.target.closest(".source-expand-btn")) return;
    if (e.button !== 0) return; // left click only
    didHold = false;
    pressTimer = setTimeout(() => { didHold = true; toggleCardExpand(card); }, 300);
  });
  card.addEventListener("pointerup", e => {
    if (e.target.closest(".source-expand-btn")) return;
    clearTimeout(pressTimer);
    if (!didHold && e.button === 0) {
      if (e.detail === 2) return; // dblclick handled separately
      card.classList.toggle("selected");
      updateSelectionNote();
    }
  });
  card.addEventListener("pointerleave", () => { clearTimeout(pressTimer); });

  // Expand button still works directly
  card.querySelector(".source-expand-btn")?.addEventListener("click", e => {
    e.stopPropagation();
    toggleCardExpand(card);
  });

  // Double-click = modal
  card.addEventListener("dblclick", e => {
    e.stopPropagation();
    openArticleModal(art, col);
  });

  return card;
}

function toggleCardExpand(card) {
  const short = card.querySelector(".snippet-short");
  const full = card.querySelector(".snippet-full");
  const btn = card.querySelector(".source-expand-btn");
  const expanded = card.classList.toggle("card-expanded");
  if (short) short.style.display = expanded ? "none" : "";
  if (full) full.style.display = expanded ? "" : "none";
  if (btn) btn.textContent = expanded ? "Show less" : "Show more";
}

// Extract unique outlets from articles, return { domain, count, faviconUrl }[] sorted by count desc
function getOutletStats(articles) {
  const byDomain = {};
  for (const art of articles) {
    let domain = "";
    try { domain = art.link ? new URL(art.link).hostname.replace(/^www\./, "") : ""; } catch {}
    if (!domain) continue;
    if (!byDomain[domain]) byDomain[domain] = { domain, count: 0 };
    byDomain[domain].count++;
  }
  return Object.values(byDomain)
    .sort((a, b) => b.count - a.count)
    .map(o => ({ ...o, faviconUrl: `https://www.google.com/s2/favicons?domain=${o.domain}&sz=32` }));
}

// Build the row of small circular favicon indicators for a column header
function buildOutletIndicators(articles) {
  const wrap = document.createElement("div");
  wrap.className = "source-outlets";
  const outlets = getOutletStats(articles);
  const MAX_ICONS = 4;
  const shown = outlets.slice(0, MAX_ICONS);
  const overflow = outlets.length - MAX_ICONS;

  for (const o of shown) {
    const img = document.createElement("img");
    img.className = "source-outlet-icon";
    img.src = o.faviconUrl;
    img.alt = o.domain;
    img.title = `${o.domain} (${o.count})`;
    img.width = 20;
    img.height = 20;
    img.loading = "lazy";
    img.onerror = function () { this.style.display = "none"; };
    wrap.appendChild(img);
  }

  if (overflow > 0) {
    const badge = document.createElement("span");
    badge.className = "source-outlet-overflow";
    badge.textContent = `+${overflow}`;
    badge.title = `${overflow} more source${overflow > 1 ? "s" : ""}`;
    wrap.appendChild(badge);
  }

  return wrap;
}

// Build the expandable detail panel listing all outlets with counts
function buildOutletDetailPanel(articles, colColor) {
  const panel = document.createElement("div");
  panel.className = "source-outlet-detail";
  if (colColor) panel.style.borderColor = colColor;
  const outlets = getOutletStats(articles);
  if (!outlets.length) {
    panel.textContent = "No sources detected.";
    return panel;
  }
  for (const o of outlets) {
    const row = document.createElement("div");
    row.className = "source-outlet-detail-row";
    row.innerHTML = `<img src="${escHtml(o.faviconUrl)}" alt="" width="14" height="14" loading="lazy" onerror="this.style.display='none'"/><span>${escHtml(o.domain)}</span><span class="source-outlet-detail-count" style="color:${colColor || 'var(--text)'}">${o.count}</span>`;
    panel.appendChild(row);
  }
  return panel;
}

function openArticleModal(art, col) {
  let outlet = "";
  try { outlet = art.link ? new URL(art.link).hostname.replace(/^www\./, "") : ""; } catch {}
  const modal = document.getElementById("source-article-modal");
  const titleEl = document.getElementById("source-article-modal-title");
  const content = document.getElementById("source-article-modal-content");
  if (!modal || !content) return;
  if (titleEl) titleEl.textContent = col.label.toUpperCase();
  content.innerHTML = `
    <div class="article-modal-head" style="border-left:3px solid ${col.color};padding-left:10px;margin-bottom:12px">
      <div class="evidence-title" style="font-size:15px;margin-bottom:4px">${escHtml(art.title)}</div>
      <div class="evidence-meta">${escHtml(outlet)} · ${escHtml(art.recency.label)}</div>
    </div>
    <div class="tag-row" style="margin-bottom:10px">
      <span class="tag ${art.relevance > 50 ? "strong" : ""}">Relevance: ${art.relevance}%</span>
      <span class="tag">Cross-coverage: ${art.mentions}</span>
    </div>
    <div class="evidence-meta" style="line-height:1.6;white-space:pre-wrap">${escHtml(art.description || "No description available.")}</div>
    ${art.link ? `<div style="margin-top:14px"><a href="${escHtml(art.link)}" target="_blank" rel="noopener" class="small-btn" style="display:inline-block;padding:4px 12px">OPEN ARTICLE ↗</a></div>` : ""}`;
  modal.classList.add("open");
  modal.style.display = "flex";
}

function showExpandSearchGate(columns, articlesByColumn, topicTokens, entities, effectivePubDate, topicLabel, cfg) {
  // Remove any existing gate/banner
  document.querySelector('.expand-search-gate')?.remove();
  document.querySelector('.expand-search-gate')?.remove();

  const container = document.getElementById("source-columns");
  const useSourcesBtn = document.getElementById("use-sources-btn");
  if (!container) return;

  // DISABLE use-sources until user resolves the gate
  if (useSourcesBtn) useSourcesBtn.disabled = true;

  const gate = document.createElement('div');
  gate.className = 'expand-search-gate';
  gate.innerHTML = `
    <div class="expand-gate-icon">!</div>
    <div class="expand-gate-text">
      <div class="expand-gate-title">LIMITED COVERAGE DETECTED</div>
      <div class="expand-gate-desc">Not enough high-relevance articles were found across perspectives.
        Expanding the search will query Google News and any configured search APIs for additional coverage.</div>
    </div>
    <div class="expand-gate-actions">
      <button class="mini-btn accent expand-gate-expand-btn" type="button">EXPAND SEARCH</button>
      <button class="mini-btn expand-gate-dismiss-btn" type="button">CONTINUE WITH CURRENT RESULTS</button>
    </div>`;

  // EXPAND SEARCH triggers Tier 2 dynamic search
  gate.querySelector('.expand-gate-expand-btn').addEventListener('click', async () => {
    const expandBtn = gate.querySelector('.expand-gate-expand-btn');
    expandBtn.disabled = true;
    expandBtn.textContent = 'SEARCHING\u2026';
    expandBtn.classList.add('llm-busy');

    try {
      await performExpandedSearch(columns, articlesByColumn, topicTokens, entities, effectivePubDate, topicLabel, cfg);
    } finally {
      gate.remove();
      if (useSourcesBtn) useSourcesBtn.disabled = false;
    }
  });

  // CONTINUE dismisses the gate and re-enables use-sources
  gate.querySelector('.expand-gate-dismiss-btn').addEventListener('click', () => {
    gate.remove();
    if (useSourcesBtn) useSourcesBtn.disabled = false;
  });

  container.parentNode.insertBefore(gate, container);
}

async function performExpandedSearch(columns, articlesByColumn, topicTokens, entities, effectivePubDate, topicLabel, cfg) {
  setSourceStatus("Generating targeted search queries\u2026");

  // 1. Check which search APIs are available
  let capabilities = { brave: false, newsapi: false, googleNews: true };
  try {
    const resp = await fetch("/api/news-search/capabilities");
    if (resp.ok) capabilities = await resp.json();
  } catch { /* Google News RSS is always available */ }

  // 2. Generate search queries per column via LLM (parallel)
  const cfgError = validateApiConfig(cfg);
  let queriesByColumn = {};
  if (!cfgError) {
    const queryPromises = columns.map(async col => {
      const queries = await generateSearchQueries(
        topicLabel, entities, col.label, col.id,
        (sys, usr) => callLLMJSON(sys, usr, cfg)
      );
      return { colId: col.id, queries };
    });
    const results = await Promise.all(queryPromises);
    for (const { colId, queries } of results) {
      queriesByColumn[colId] = queries;
    }
  } else {
    // Fallback: simple topic + column label queries
    for (const col of columns) {
      queriesByColumn[col.id] = [`${topicLabel} ${col.label}`];
    }
  }

  // 3. Fetch Google News RSS for each query (through existing proxy)
  setSourceStatus("Fetching search results from Google News\u2026");
  const allSearchUrls = [];
  const urlToColumn = {};
  for (const col of columns) {
    for (const query of (queriesByColumn[col.id] || [])) {
      const url = buildGoogleNewsRssUrl(query);
      allSearchUrls.push(url);
      urlToColumn[url] = col.id;
    }
  }

  let searchResults = [];
  try {
    searchResults = await postFetchUrl(allSearchUrls);
  } catch { /* non-fatal — continue with whatever we got */ }

  // Parse and deduplicate against existing articles
  for (const col of columns) {
    const existingArticles = articlesByColumn[col.id] || [];
    let newArticles = [];
    for (const r of searchResults) {
      if (urlToColumn[r.url] !== col.id) continue;
      if (!r?.ok || !r.raw) continue;
      newArticles.push(...parseFeedItems(r.raw));
    }
    const deduped = deduplicateArticles(existingArticles, newArticles);
    articlesByColumn[col.id] = [...existingArticles, ...deduped];
  }

  // 4. Optional: Hit Brave Search if available
  if (capabilities.brave) {
    setSourceStatus("Querying Brave Search\u2026");
    for (const col of columns) {
      const queries = queriesByColumn[col.id] || [];
      if (!queries.length) continue;
      try {
        const resp = await fetch("/api/news-search/brave", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ query: queries[0], count: 10 })
        });
        if (resp.ok) {
          const data = await resp.json();
          const articles = normalizeBraveResults(data);
          const deduped = deduplicateArticles(articlesByColumn[col.id], articles);
          articlesByColumn[col.id] = [...articlesByColumn[col.id], ...deduped];
        }
      } catch { /* non-fatal */ }
    }
  }

  // 5. Optional: Hit NewsAPI if available
  if (capabilities.newsapi) {
    setSourceStatus("Querying NewsAPI\u2026");
    const from = effectivePubDate ? new Date(effectivePubDate.getTime() - 7 * 86400000).toISOString().slice(0, 10) : "";
    const to = effectivePubDate ? new Date(effectivePubDate.getTime() + 7 * 86400000).toISOString().slice(0, 10) : "";
    for (const col of columns) {
      const queries = queriesByColumn[col.id] || [];
      if (!queries.length) continue;
      try {
        const resp = await fetch("/api/news-search/newsapi", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ query: queries[0], pageSize: 10, from, to })
        });
        if (resp.ok) {
          const data = await resp.json();
          const articles = normalizeNewsApiResults(data);
          const deduped = deduplicateArticles(articlesByColumn[col.id], articles);
          articlesByColumn[col.id] = [...articlesByColumn[col.id], ...deduped];
        }
      } catch { /* non-fatal */ }
    }
  }

  // 6. Re-score everything and re-render with relaxed params
  const scoredByColumn = {};
  for (const col of columns) {
    const articles = articlesByColumn[col.id] || [];
    const scored = articles.map(a => ({
      ...a,
      relevance: Math.max(0, (entities.length
        ? Math.max(scoreArticleWithSeed(a, topicTokens, entities), softScoreArticle(a, topicTokens))
        : Math.max(scoreArticle(a, topicTokens), softScoreArticle(a, topicTokens)))),
      recency: parseRecency(a.pubDate),
      mentions: crossMentionCount(a, articlesByColumn, col.id, topicTokens)
    }));
    scored.sort((a, b) => b.relevance - a.relevance || a.recency.ms - b.recency.ms);
    scoredByColumn[col.id] = scored.slice(0, 15);
  }

  renderSourceColumns(columns, scoredByColumn, 10);
  const totalResults = Object.values(scoredByColumn).reduce((s, a) => s + a.length, 0);
  setSourceStatus(`Expanded search complete \u2014 ${totalResults} articles across ${columns.length} perspectives.`, "ok");
  showToast("Search expanded with dynamic queries.");
}

function renderSourceColumns(columns, scoredByColumn, visibilityThreshold = 20) {
  const container = document.getElementById("source-columns");
  if (!container) return;
  container.innerHTML = "";
  container.style.display = "grid";

  // "Expand coverage details" checkbox above columns
  const expandRow = document.createElement("label");
  expandRow.className = "expand-coverage-row";
  expandRow.style.gridColumn = "1 / -1";
  const expandCb = document.createElement("input");
  expandCb.type = "checkbox";
  expandCb.id = "expand-coverage-toggle";
  const expandLabel = document.createElement("span");
  expandLabel.textContent = "EXPAND COVERAGE DETAILS";
  expandRow.append(expandCb, expandLabel);
  container.appendChild(expandRow);
  expandCb.addEventListener("change", () => {
    const panels = container.querySelectorAll(".source-outlet-detail");
    panels.forEach(p => p.classList.toggle("open", expandCb.checked));
  });

  for (const col of columns) {
    const colDiv = document.createElement("div");
    colDiv.className = "source-column";
    colDiv.style.borderTopColor = col.color;
    colDiv.style.borderTopWidth = "3px";

    // Column header with color dot + label + edit button + outlet indicators
    const header = document.createElement("div");
    header.className = "source-column-header";
    const colorDot = document.createElement("span");
    colorDot.style.cssText = `display:inline-block;width:10px;height:10px;border-radius:50%;background:${col.color};flex-shrink:0`;
    const lbl = document.createElement("span");
    lbl.className = "source-column-label";
    lbl.textContent = col.label;
    lbl.style.color = col.color;
    const editBtn = document.createElement("button");
    editBtn.className = "source-col-edit-btn";
    editBtn.title = "Edit feeds for this column";
    editBtn.textContent = "\u2699";
    editBtn.addEventListener("click", e => { e.stopPropagation(); openFeedEditPopover(editBtn, col); });

    // Source outlet favicon indicators
    const colArticles = scoredByColumn[col.id] || [];
    const outletIcons = buildOutletIndicators(colArticles);
    header.append(colorDot, lbl, outletIcons, editBtn);
    colDiv.appendChild(header);

    // Expandable outlet detail panel (hidden by default)
    const outletDetail = buildOutletDetailPanel(colArticles, col.color);
    colDiv.appendChild(outletDetail);
    // Clicking the outlet icons row or overflow badge toggles the detail panel
    outletIcons.addEventListener("click", e => {
      e.stopPropagation();
      outletDetail.classList.toggle("open");
      // Sync the master expand checkbox
      syncExpandCoverageCheckbox(container);
    });

    const articles = scoredByColumn[col.id] || [];

    // "Select top N" stepper — defaults to total article count, auto-selects top N by relevance
    if (articles.length) {
      const topNRow = document.createElement("div");
      topNRow.className = "source-col-top-n";
      const topNLabel = document.createElement("span");
      topNLabel.textContent = "Select top";
      const topNInput = document.createElement("input");
      topNInput.type = "number";
      topNInput.min = 0;
      topNInput.max = articles.length;
      topNInput.value = articles.length;
      topNInput.dataset.col = col.id;
      topNInput.className = "top-n-input";
      const topNOf = document.createElement("span");
      topNOf.textContent = `of ${articles.length}`;
      topNRow.append(topNLabel, topNInput, topNOf);
      colDiv.appendChild(topNRow);
      topNInput.addEventListener("change", () => {
        const n = clampInt(parseInt(topNInput.value, 10) || 0, 0, articles.length);
        topNInput.value = n;
        applyTopNSelection(colDiv, n);
      });
    }

    if (!articles.length) {
      const empty = document.createElement("div");
      empty.className = "no-stories";
      empty.textContent = "No recent stories matching this topic.";
      colDiv.appendChild(empty);
    } else {
      const highRel = articles.filter(a => a.relevance > visibilityThreshold);
      const lowRel = articles.filter(a => a.relevance <= visibilityThreshold);

      // High-relevance cards (always visible)
      if (highRel.length) {
        for (const art of highRel) colDiv.appendChild(makeSourceCard(art, col));
      } else {
        // All articles are low-relevance — show a persistent warning with opt-in reveal
        const warn = document.createElement("div");
        warn.className = "no-stories-warn";
        const warnText = document.createElement("span");
        warnText.textContent = "No relevant stories found for this topic.";
        const showBtn = document.createElement("button");
        showBtn.className = "mini-link-btn";
        showBtn.textContent = "Show them anyway";
        const hiddenSection = document.createElement("div");
        hiddenSection.style.display = "none";
        for (const art of lowRel) hiddenSection.appendChild(makeSourceCard(art, col));
        showBtn.addEventListener("click", () => {
          hiddenSection.style.display = hiddenSection.style.display === "none" ? "" : "none";
          showBtn.textContent = hiddenSection.style.display === "none" ? "Show them anyway" : "Hide";
        });
        warn.append(warnText, " ", showBtn);
        colDiv.append(warn, hiddenSection);
      }

      // Low-relevance collapsible section (only when there are also high-relevance articles)
      if (lowRel.length && highRel.length < articles.length) {
        const toggle = document.createElement("button");
        toggle.className = "mini-link-btn low-rel-toggle";
        toggle.textContent = `See less relevant stories (${lowRel.length})`;
        const lowSection = document.createElement("div");
        lowSection.className = "low-rel-section";
        lowSection.style.display = "none";
        for (const art of lowRel) lowSection.appendChild(makeSourceCard(art, col));
        toggle.addEventListener("click", () => {
          const open = lowSection.style.display !== "none";
          lowSection.style.display = open ? "none" : "";
          toggle.textContent = open
            ? `See less relevant stories (${lowRel.length})`
            : `Hide less relevant stories`;
        });
        colDiv.append(toggle, lowSection);
      }
    }
    container.appendChild(colDiv);

    // Auto-select all articles (top N defaults to max)
    if (articles.length) applyTopNSelection(colDiv, articles.length);
  }

  document.getElementById("source-use-row").style.display = "flex";
  updateSelectionNote();
}

// Apply top N selection: select first N cards, deselect the rest
function applyTopNSelection(colDiv, n) {
  const cards = colDiv.querySelectorAll(".source-pick-card");
  let i = 0;
  cards.forEach(card => {
    card.classList.toggle("selected", i < n);
    i++;
  });
  updateSelectionNote();
}

// Sync the master "expand coverage details" checkbox with individual panel states
function syncExpandCoverageCheckbox(container) {
  const toggle = document.getElementById("expand-coverage-toggle");
  if (!toggle) return;
  const panels = container.querySelectorAll(".source-outlet-detail");
  const openCount = container.querySelectorAll(".source-outlet-detail.open").length;
  toggle.checked = panels.length > 0 && openCount === panels.length;
  toggle.indeterminate = openCount > 0 && openCount < panels.length;
}

function escHtml(str) {
  return String(str || "")
    .replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;");
}

async function extractSeedMetadata(seedUrl, rawText, cfg) {
  const snippet = rawText.slice(0, 4000);
  try {
    const resp = await callLLMJSON(
      "You extract structured metadata from news articles. Return only strict JSON.",
      `From this news article extract:\n1. Publication date (ISO 8601, best guess)\n2. 5-8 named entities: key people, places, organizations, event names\n3. A 4-8 word descriptive topic label\n\nURL: ${seedUrl}\n\nArticle excerpt:\n"""\n${snippet}\n"""\n\nReturn JSON only:\n{\n  "pubDate": "2026-02-28T00:00:00Z",\n  "entities": ["Netanyahu", "Iran", "Operation Epic Fury"],\n  "topicLabel": "US-Israel joint strikes on Iran"\n}`,
      cfg
    );
    const parsed = extractJSON(resp);
    return {
      pubDate: parsed.pubDate ? new Date(parsed.pubDate) : null,
      entities: Array.isArray(parsed.entities) ? parsed.entities.map(e => String(e).trim()).filter(Boolean) : [],
      topicLabel: String(parsed.topicLabel || "").trim()
    };
  } catch {
    return { pubDate: null, entities: [], topicLabel: "" };
  }
}

function renderAnchorCard({ seedUrl, title, topicLabel, pubDate, entities }) {
  const row = document.getElementById("seed-anchor-row");
  if (!row) return;
  const dateStr = pubDate && !isNaN(pubDate.getTime())
    ? pubDate.toLocaleDateString(undefined, { year: "numeric", month: "short", day: "numeric" })
    : "date unknown";
  const safeTitle = (title || seedUrl).replace(/</g, "&lt;").replace(/>/g, "&gt;");
  const safeUrl = seedUrl.replace(/"/g, "&quot;");
  row.innerHTML = `
    <div class="anchor-card">
      <div class="anchor-card-meta-row">
        <span class="anchor-card-badge">ANCHOR</span>
        <span class="anchor-card-date">${dateStr}</span>
        <a class="anchor-card-link" href="${safeUrl}" target="_blank" rel="noopener">View original ↗</a>
      </div>
      <div class="anchor-card-title">${safeTitle}</div>
      ${entities.length ? `<div class="anchor-card-entities">Detected: ${entities.slice(0, 6).map(e => e.replace(/</g, "&lt;")).join(" · ")}</div>` : ""}
      ${topicLabel ? `<div class="anchor-card-topic">Topic → <strong>${topicLabel.replace(/</g, "&lt;")}</strong></div>` : ""}
      <div class="anchor-card-note">RSS results are filtered to ±7 days of this article's date and scored by entity overlap.</div>
    </div>`;
  row.style.display = "block";
}

export async function findStories() {
  const seedUrl = document.getElementById("seed-url-input")?.value?.trim();
  const lensKey = document.getElementById("lens-select")?.value || "political";
  resetColumns();
  const columns = lensKey === "custom" ? getCustomColumns() : getLensColumns();
  if (!columns.length) { showToast("Add at least one column with a feed URL."); return; }
  if (!seedUrl) { showToast("Paste an article URL to explore first."); return; }

  const btn = document.getElementById("find-stories-btn");
  const prev = btn?.textContent;
  if (btn) { btn.disabled = true; btn.textContent = "FINDING STORIES…"; btn.classList.add("llm-busy"); }
  setSourceStatus("Fetching seed article…");
  // Clear stale state from previous searches so new seed starts fresh
  document.getElementById("target-input").value = "";
  document.getElementById("seed-anchor-row").style.display = "none";
  document.getElementById("seed-anchor-row").innerHTML = "";
  document.getElementById("source-columns").style.display = "none";
  document.getElementById("source-columns").innerHTML = "";
  document.getElementById("source-use-row").style.display = "none";
  document.querySelector(".expand-search-gate")?.remove();
  resetColumns();

  try {
    // 1. Fetch seed article
    const seedResults = await postFetchUrl([seedUrl]);
    const seedResult = seedResults[0];
    if (!seedResult?.ok) throw new Error("Could not fetch the seed article. Check the URL and proxy mode.");

    // 2. Extract metadata from seed via LLM (graceful fallback if API not configured)
    // btn stays as "FINDING STORIES…" — status line shows detail
    setSourceStatus("Analyzing seed article…");
    const cfg = readApiConfig();
    const cfgError = validateApiConfig(cfg);
    let seedMeta = { pubDate: null, entities: [], topicLabel: "" };
    if (!cfgError) {
      seedMeta = await extractSeedMetadata(seedUrl, seedResult.text || "", cfg);
    }

    // Proxy-extracted date (from URL path / meta tags / JSON-LD) takes priority over LLM guess
    const effectivePubDate = seedResult.pubDate ? new Date(seedResult.pubDate) : seedMeta.pubDate;

    // 3. Auto-fill #target-input with extracted topic label
    const topicLabel = seedMeta.topicLabel || seedResult.title || "";
    const targetInput = document.getElementById("target-input");
    if (targetInput && topicLabel) targetInput.value = topicLabel;

    // 4. Render locked anchor card
    renderAnchorCard({
      seedUrl,
      title: seedResult.title || seedUrl,
      topicLabel,
      pubDate: effectivePubDate,
      entities: seedMeta.entities
    });

    const topic = topicLabel || (targetInput?.value?.trim() || "");
    const topicTokens = tokenize(topic);
    const entities = seedMeta.entities;

    // 5. Fetch all RSS feeds
    // btn stays as "FINDING STORIES…" — status line shows detail
    setSourceStatus(`Fetching ${columns.flatMap(c => c.feeds).length} feed(s)…`);
    const allFeedUrls = [...new Set(columns.flatMap(c => c.feeds))];
    const feedResults = await postFetchUrl(allFeedUrls);

    // 6. Parse + temporally filter articles per column
    const articlesByColumn = {};
    for (const col of columns) {
      const items = [];
      for (const feedUrl of col.feeds) {
        const r = feedResults.find(f => f.url === feedUrl);
        if (!r?.ok || !r.raw) continue;
        items.push(...parseFeedItems(r.raw));
      }
      articlesByColumn[col.id] = items; // keep all articles; temporal proximity is a scoring bonus, not a hard filter
    }

    // 7. Score and rank (entity-aware when entities available, falls back to keyword-only)
    const scoredByColumn = {};
    for (const col of columns) {
      const articles = articlesByColumn[col.id] || [];
      const scored = articles.map(a => ({
        ...a,
        relevance: Math.max(0, (entities.length
          ? scoreArticleWithSeed(a, topicTokens, entities)
          : scoreArticle(a, topicTokens))
          + temporalRelevanceBonus(a, effectivePubDate, 7)),
        recency: parseRecency(a.pubDate),
        mentions: crossMentionCount(a, articlesByColumn, col.id, topicTokens)
      }));
      scored.sort((a, b) => b.relevance - a.relevance || a.recency.ms - b.recency.ms);
      scoredByColumn[col.id] = scored.slice(0, 10);
    }

    renderSourceColumns(columns, scoredByColumn);

    // Tiered expand search — if results are thin, offer to widen the net
    const totalHighRel = Object.values(scoredByColumn)
      .reduce((sum, arts) => sum + arts.filter(a => a.relevance > 20).length, 0);
    if (totalHighRel / columns.length < 2) {
      showExpandSearchGate(columns, articlesByColumn, topicTokens, entities, effectivePubDate, topicLabel, cfg);
    }

    const totalArticles = Object.values(scoredByColumn).reduce((s, a) => s + a.length, 0);
    const anchorDateStr = effectivePubDate && !isNaN(effectivePubDate.getTime())
      ? effectivePubDate.toLocaleDateString()
      : "seed article";
    setSourceStatus(`${columns.length} perspectives · ${totalArticles} stories found (anchored to ${anchorDateStr} ±7 days). Click to select/deselect; hold to expand; double-click to preview.`, "ok");
  } catch (err) {
    setSourceStatus(String(err.message || "Fetch failed. Check proxy mode."), "err");
    showToast(String(err.message || "Fetch failed."));
  } finally {
    if (btn) { btn.disabled = false; btn.textContent = prev; btn.classList.remove("llm-busy"); }
  }
}


// Core summarization logic — reusable by pipeline and standalone
// Returns { byDisc, activeCols, successful, failed, combined }
export async function summarizeSourcesForPipeline(selected, cfg, onProgress) {
  const columns = getLensColumns();
  const selectedCols = new Set(selected.map(el => el.dataset.col));

  // Build url → {colId, colLabel} map
  const urlToCol = {};
  for (const card of selected) {
    urlToCol[card.dataset.link] = { colId: card.dataset.col, colLabel: card.dataset.colLabel || card.dataset.col };
  }
  const urls = selected.map(el => el.dataset.link).filter(Boolean);

  const results = await postFetchUrl(urls);
  const successful = results.filter(r => r.ok && r.text);
  const failed = results.filter(r => !r.ok);

  // Pre-summarize each article via LLM (parallel, per-article, falls back to raw on error)
  let summarized = successful;
  const cfgError = validateApiConfig(cfg);

  if (!cfgError && successful.length) {
    let summarizeDone = 0;
    const total = successful.length;
    summarized = await Promise.all(successful.map(async r => {
      try {
        const rawText = String(r.text || "").replace(/[ \t]+/g, " ").replace(/\n{3,}/g, "\n\n").trim();
        const snippet = rawText.length > 12000 ? rawText.slice(0, 12000).trimEnd() + "\n...[truncated]" : rawText;
        const systemPrompt = "You are a research summarizer. Produce a structured summary of the provided article. Be factual and precise.";
        const userPrompt = `Summarize the following article for use as grounding material in a multi-lens research analysis.\n\nURL: ${r.url}\nTitle: ${r.title || "(untitled)"}\n\nArticle:\n"""\n${snippet}\n"""\n\nProvide a 400–600 word summary covering:\n- Main thesis and key findings\n- Key facts, data points, or statistics\n- Up to 3 notable verbatim quotes (≤25 words each)\n- Framing and perspective of the source\n\nEnd with: Source URL: ${r.url}`;
        const summaryText = await callLLM(systemPrompt, userPrompt, { ...cfg, __maxTokens: 800 });
        return { ...r, text: summaryText };
      } catch {
        return r; // fall back to raw text on error
      } finally {
        summarizeDone++;
        if (onProgress) onProgress(summarizeDone, total);
      }
    }));
  }

  // Group text by column label for per-probe grounding
  const byDiscTexts = {};
  for (const r of summarized) {
    const { colLabel } = urlToCol[r.url] || { colLabel: "Source" };
    if (!byDiscTexts[colLabel]) byDiscTexts[colLabel] = [];
    byDiscTexts[colLabel].push(`--- SOURCE: ${r.title || r.url} ---\n${r.text}`);
  }
  const byDisc = {};
  for (const [label, texts] of Object.entries(byDiscTexts)) {
    byDisc[label] = texts.join("\n\n");
  }
  const combined = summarized.map(r => `--- SOURCE: ${r.title || r.url} ---\n${r.text}`).join("\n\n");

  const activeCols = columns.filter(c => selectedCols.has(c.id));
  for (const c of activeCols) { if (!byDisc[c.label]) byDisc[c.label] = ''; }

  return { byDisc, activeCols, successful, failed, combined };
}

// Lens mode: validate selection, populate discs, then launch the full pipeline
export function launchLensRun() {
  const selected = [...document.querySelectorAll(".source-pick-card.selected")];
  if (!selected.length) { showToast("Select at least one article to use as source."); return; }

  const columns = getLensColumns();
  const selectedCols = new Set(selected.map(el => el.dataset.col));
  const missingCols = columns.filter(c => !selectedCols.has(c.id)).map(c => c.label);
  if (missingCols.length) {
    showToast(`Unrepresented: ${missingCols.join(", ")}. Results may reflect narrower coverage.`);
  }

  // Auto-populate probe discipline inputs with selected column labels
  const activeCols = columns.filter(c => selectedCols.has(c.id));
  if (activeCols.length >= 2) {
    renderDisciplineInputs(activeCols.length, activeCols.map(c => c.label), activeCols.map(c => c.color));
    syncPromptPreviewDiscOptions();
  } else {
    showToast("Need articles from at least 2 perspectives."); return;
  }

  // Import and call launchExpedition dynamically to avoid circular imports
  import('../pipeline/launch-expedition.js').then(mod => mod.launchExpedition());
}

export function clearSources() {
  setSourceMaterial({ urls: [], text: "", titles: [] });
  resetColumns();
  closePopover();
  const seedInput = document.getElementById("seed-url-input");
  if (seedInput) seedInput.value = "";
  const anchorRow = document.getElementById("seed-anchor-row");
  if (anchorRow) { anchorRow.innerHTML = ""; anchorRow.style.display = "none"; }
  const cols = document.getElementById("source-columns");
  if (cols) { cols.innerHTML = ""; cols.style.display = "none"; }
  const useRow = document.getElementById("source-use-row");
  if (useRow) useRow.style.display = "none";
  setSourceStatus("");
}

export function initSourcesPanel() {
  const lensSelect = document.getElementById("lens-select");
  const customEditor = document.getElementById("custom-lens-editor");
  if (lensSelect && customEditor) {
    lensSelect.addEventListener("change", () => {
      customEditor.style.display = lensSelect.value === "custom" ? "" : "none";
      resetColumns();
      clearSources();
    });
  }

  document.getElementById("add-custom-column-btn")?.addEventListener("click", () => {
    const list = document.getElementById("custom-columns-list");
    if (!list) return;
    const row = document.createElement("div");
    row.className = "custom-col-row";
    row.innerHTML = `
      <input type="text" placeholder="Column label" value="Column ${list.children.length + 1}"/>
      <textarea placeholder="https://feeds.example.com/rss&#10;(one URL per line)"></textarea>
      <button class="mini-btn" type="button" title="Remove column">✕</button>`;
    row.querySelector("button").addEventListener("click", () => row.remove());
    list.appendChild(row);
  });
}
