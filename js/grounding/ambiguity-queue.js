import { AMBIGUITY_QUEUE, CURRENT_RUN_ID, DISCS, LAST_RUN, RUN_STATE, TERMS, WOLFRAM_GROUNDING_DIAGNOSTICS } from '../core/state.js';
import { clampInt } from '../core/utils.js';
import { showToast, updateAmbiguityQueueUIState } from '../ui/notifications.js';
import { normalizeMode } from '../api/provider.js';
import { readApiConfig } from '../api/llm.js';
import { buildNoPlaintextReasons, extractWolframStructured, fetchWolframJSON, resolveWolframChosenPod, sanitizeWolframToken, scoreWolframSnippet, selectWolframSnippetFromParsed } from './wolfram-parse.js';
import { applyCompositeTermAppendGuard, applyGroundingCategoryMismatchGuard, applySingleWordDriftGuard, applyWarningAssumptionRiskGuard, clampGroundingSnippetScore, evaluateGroundingApplication, evaluateGroundingCategoryMismatch, resolveGroundingPolicy } from './wolfram-score.js';
import { buildWolframGroundingCitation, deriveWolframDomainHintFromDiscName, mergeGroundingBlocks, normalizeGroundingBlock, normalizeWolframAssumptionText, recordWolframGroundingDiagnostic } from './wolfram-grounding.js';
import { applyDisplayDescriptionForTerm, mergeDescription, normalizeTermDescriptions } from '../domain/terms.js';
import { toCanonicalKey } from '../domain/aliases.js';
import { mergeDescriptionProvenance, normalizeConfidenceLevel, upsertCitationEntry } from '../domain/citations.js';
import { refreshTermSignalFields } from '../domain/grounding-status.js';
import { clamp01 } from '../plot/plot-overlays.js';
import { showTermDetail } from '../plot/term-detail.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Source: ruliad_expedition_v1.1.html
// Module: js/grounding/ambiguity-queue.js

export function ambiguityQueueKey(raw){const runId=String(raw?.runId||CURRENT_RUN_ID||"run").trim()||"run";const term=toCanonicalKey(raw?.termLabel||"");const disc=toCanonicalKey(raw?.discName||"");if(!term) return "";return `${runId}|${disc}|${term}`;}

export function getAmbiguityReasonsFromDiagnostic(item){const reasons=[];const diagReasons=(Array.isArray(item?.reasons)?item.reasons:[]).map(x=>String(x||"").trim().toLowerCase()).filter(Boolean);if(diagReasons.some(r=>["generic_placeholder","too_short","mostly_numeric","same_as_label","empty"].includes(r))||String(item?.snippet||"").trim().toLowerCase()==="entity"){reasons.push("generic_result");}const mismatchReason=diagReasons.find(r=>r.startsWith("category_mismatch_"));if(mismatchReason) reasons.push(mismatchReason);if(diagReasons.includes("name_like_interpretation")) reasons.push("name_like_interpretation");if(diagReasons.includes("forced_metadata_only_name_like_interpretation")) reasons.push("forced_metadata_only_name_like_interpretation");if(diagReasons.some(r=>r.startsWith("single_word_drift"))) reasons.push("single_word_drift");if(diagReasons.some(r=>r.includes("closest_interpretation_type_mismatch"))) reasons.push("closest_interpretation_type_mismatch");if(diagReasons.some(r=>r.includes("assumption_clash_generic_token"))) reasons.push("assumption_clash_generic_token");if(diagReasons.some(r=>r.includes("composite_term_default_metadata_only"))) reasons.push("composite_term_default_metadata_only");if(diagReasons.some(r=>r.startsWith("suspicious_acceptance_"))) reasons.push("suspicious_acceptance_audit");const assumptions=(Array.isArray(item?.assumptions)?item.assumptions:[]).map(x=>String(x||"").trim()).filter(Boolean);if(new Set(assumptions.map(x=>x.toLowerCase())).size>1){reasons.push("conflicting_assumptions");}const status=String(item?.status||"").trim().toLowerCase();const confidence=String(item?.confidence||"").trim().toLowerCase();const lowConfidence=confidence==="low"||/rejected|error|failed|no_plaintext/.test(status)||diagReasons.some(r=>r.startsWith("score_below_threshold")||r.startsWith("quality_below_threshold")||r.startsWith("alignment_below_threshold"));if(lowConfidence) reasons.push("low_confidence_interpretation");return [...new Set(reasons)];}

export function normalizeAmbiguityQueueItem(raw){const base=raw&&typeof raw==="object"?raw:{};const id=ambiguityQueueKey(base)||String(base.id||"").trim();const reasons=getAmbiguityReasonsFromDiagnostic(base);const reviewStatus=String(base.reviewStatus||"pending").trim().toLowerCase();const normalizedReview=["pending","kept_probe_only","accepted_wa","retried"].includes(reviewStatus)?reviewStatus:"pending";return {id,runId:base?.runId||CURRENT_RUN_ID||null,timestamp:String(base?.timestamp||new Date().toISOString()),target:String(base?.target||"").trim(),discName:String(base?.discName||"").trim(),termLabel:String(base?.termLabel||"").trim(),query:String(base?.query||"").trim(),snippet:String(base?.snippet||"").trim(),inputInterpretation:String(base?.inputInterpretation||"").trim(),bestDefinition:String(base?.bestDefinition||"").trim(),chosenInterpretation:String(base?.chosenInterpretation||"").trim(),assumptions:Array.isArray(base?.assumptions)?base.assumptions.map(x=>normalizeWolframAssumptionText(x,{})).filter(Boolean):[],didYouMeans:Array.isArray(base?.didYouMeans)?base.didYouMeans.map(x=>String(x||"").trim()).filter(Boolean):[],warnings:Array.isArray(base?.warnings)?base.warnings.map(x=>String(x||"").trim()).filter(Boolean):[],reasons:Array.isArray(base?.reasons)?base.reasons.map(x=>String(x||"").trim()).filter(Boolean):[],ambiguityReasons:Array.isArray(base?.ambiguityReasons)&&base.ambiguityReasons.length?base.ambiguityReasons.map(x=>String(x||"").trim()).filter(Boolean):reasons,score:Number.isFinite(Number(base?.score))?Number(base.score):null,snippetQualityScore:Number.isFinite(Number(base?.snippetQualityScore))?Number(base.snippetQualityScore):Number.isFinite(Number(base?.snippet_quality_score))?Number(base.snippet_quality_score):null,semanticAlignmentScore:Number.isFinite(Number(base?.semanticAlignmentScore))?Number(base.semanticAlignmentScore):Number.isFinite(Number(base?.semantic_alignment_score))?Number(base.semantic_alignment_score):null,confidence:String(base?.confidence||"").trim()||"low",status:String(base?.status||"").trim(),accepted:Boolean(base?.accepted),reviewStatus:normalizedReview,reviewNote:String(base?.reviewNote||"").trim(),reviewedAt:String(base?.reviewedAt||"").trim(),retryCount:clampInt(base?.retryCount||0,0,999),lastUpdated:String(base?.lastUpdated||base?.timestamp||new Date().toISOString()).trim()};}

export function normalizeAmbiguitySeverity(item){
  const reasons=new Set((Array.isArray(item?.ambiguityReasons)?item.ambiguityReasons:[]).map(x=>String(x||"").toLowerCase()));
  let severity=1;
  if(reasons.has("low_confidence_interpretation")) severity+=0.35;
  if(reasons.has("conflicting_assumptions")) severity+=0.55;
  if(reasons.has("generic_result")) severity+=0.3;
  if(reasons.has("closest_interpretation_type_mismatch")) severity+=0.45;
  if(reasons.has("single_word_drift")) severity+=0.25;
  if(reasons.has("name_like_interpretation")||reasons.has("forced_metadata_only_name_like_interpretation")) severity+=0.5;
  if([...reasons].some(r=>r.startsWith("category_mismatch_"))) severity+=0.4;
  const status=String(item?.status||"").toLowerCase();
  if(status.includes("no_plaintext")) severity+=0.3;
  if(status.includes("error")) severity+=0.35;
  const confidence=String(item?.confidence||"low").toLowerCase();
  if(confidence==="low") severity+=0.25;
  else if(confidence==="medium") severity+=0.1;
  const didYouCount=Array.isArray(item?.didYouMeans)?item.didYouMeans.length:0;
  const warnCount=Array.isArray(item?.warnings)?item.warnings.length:0;
  const assumptionCount=Array.isArray(item?.assumptions)?item.assumptions.length:0;
  severity+=Math.min(0.55,(didYouCount*0.06)+(warnCount*0.06)+(assumptionCount>1?0.18:0));
  const retryCount=clampInt(item?.retryCount||0,0,999);
  severity+=Math.min(0.5,retryCount*0.1);
  return Math.max(0.8,Math.min(4,severity));
}

export function computeAmbiguityPriority(item){
  const term=findTermForAmbiguityItem(item);
  const centrality=clamp01(Number(term?.centrality??0.5));
  const contradictionBoost=term?.type==="contradictory"?0.8:0;
  const emergentBoost=term?.type==="emergent"?0.6:0;
  const ambiguitySeverity=normalizeAmbiguitySeverity(item);
  const priority=centrality*(1+contradictionBoost+emergentBoost)*ambiguitySeverity;
  return {priority,centrality,ambiguitySeverity,contradictionBoost,emergentBoost,termType:String(term?.type||"unknown")};
}

export function sortAmbiguityQueueInPlace(){AMBIGUITY_QUEUE.sort((a,b)=>{const ap=a?.reviewStatus==="pending"?0:1;const bp=b?.reviewStatus==="pending"?0:1;if(ap!==bp) return ap-bp;const pa=computeAmbiguityPriority(a).priority;const pb=computeAmbiguityPriority(b).priority;if(Math.abs(pb-pa)>1e-6) return pb-pa;const at=Date.parse(a?.lastUpdated||a?.timestamp||0)||0;const bt=Date.parse(b?.lastUpdated||b?.timestamp||0)||0;return bt-at;});}

export function getPendingAmbiguityCount(){return AMBIGUITY_QUEUE.filter(item=>item.reviewStatus==="pending").length;}

export function upsertAmbiguityQueueItem(raw,{preserveReview=true}={}){const item=normalizeAmbiguityQueueItem(raw);if(!item.id||!item.termLabel) return null;if(!Array.isArray(item.ambiguityReasons)||!item.ambiguityReasons.length) return null;const idx=AMBIGUITY_QUEUE.findIndex(row=>row.id===item.id);if(idx>=0){const existing=AMBIGUITY_QUEUE[idx];const merged={...existing,...item};if(preserveReview&&existing.reviewStatus&&existing.reviewStatus!=="pending"){merged.reviewStatus=existing.reviewStatus;merged.reviewNote=existing.reviewNote;merged.reviewedAt=existing.reviewedAt;}merged.retryCount=Math.max(clampInt(existing.retryCount||0,0,999),clampInt(item.retryCount||0,0,999));AMBIGUITY_QUEUE[idx]=merged;}else{AMBIGUITY_QUEUE.push(item);}sortAmbiguityQueueInPlace();if(RUN_STATE) RUN_STATE.ambiguityQueue=[...AMBIGUITY_QUEUE];updateAmbiguityQueueUIState();return item;}

export function upsertAmbiguityFromDiagnostic(item){const reasons=getAmbiguityReasonsFromDiagnostic(item);if(!reasons.length) return;upsertAmbiguityQueueItem({...item,ambiguityReasons:reasons,lastUpdated:String(item?.timestamp||new Date().toISOString())});}

export function rebuildAmbiguityQueueFromDiagnostics(importedQueue=[]){const preserved=new Map();if(Array.isArray(importedQueue)){for(const raw of importedQueue){const item=normalizeAmbiguityQueueItem(raw);if(!item.id) continue;preserved.set(item.id,item);}}const rebuilt=[];for(const diag of (WOLFRAM_GROUNDING_DIAGNOSTICS||[])){const reasons=getAmbiguityReasonsFromDiagnostic(diag);if(!reasons.length) continue;const item=normalizeAmbiguityQueueItem({...diag,ambiguityReasons:reasons,lastUpdated:String(diag?.timestamp||new Date().toISOString())});if(!item.id) continue;const existing=preserved.get(item.id);if(existing&&existing.reviewStatus&&existing.reviewStatus!=="pending"){item.reviewStatus=existing.reviewStatus;item.reviewNote=existing.reviewNote;item.reviewedAt=existing.reviewedAt;item.retryCount=existing.retryCount||0;}const idx=rebuilt.findIndex(row=>row.id===item.id);if(idx>=0){const prev=rebuilt[idx];const prevTs=Date.parse(prev?.lastUpdated||prev?.timestamp||0)||0;const nowTs=Date.parse(item?.lastUpdated||item?.timestamp||0)||0;if(nowTs>=prevTs) rebuilt[idx]=item;}else{rebuilt.push(item);}}for(const [id,item] of preserved.entries()){if(!rebuilt.some(row=>row.id===id)) rebuilt.push(item);}AMBIGUITY_QUEUE=rebuilt;sortAmbiguityQueueInPlace();if(RUN_STATE) RUN_STATE.ambiguityQueue=[...AMBIGUITY_QUEUE];updateAmbiguityQueueUIState();}

export function formatAmbiguityReason(reason){const key=String(reason||"").trim().toLowerCase();if(key==="generic_result") return "generic WA result";if(key==="conflicting_assumptions") return "conflicting assumptions";if(key==="low_confidence_interpretation") return "low-confidence interpretation";if(key==="single_word_drift") return "single-word drift on multi-word label";if(key==="closest_interpretation_type_mismatch") return "closest interpretation type mismatch";if(key==="assumption_clash_generic_token") return "assumption clash on generic label token";if(key==="composite_term_default_metadata_only") return "composite concept defaulted to metadata-only";if(key==="name_like_interpretation") return "name-like interpretation";if(key==="forced_metadata_only_name_like_interpretation") return "forced metadata-only: name-like interpretation";if(key==="name_like_interpretation_high_alignment_override") return "name-like interpretation allowed by high-alignment override";if(key==="suspicious_acceptance_audit") return "suspicious acceptance auto-downgraded";if(key==="category_mismatch_airport") return "category mismatch: airport";if(key==="category_mismatch_periodical") return "category mismatch: periodical";if(key==="category_mismatch_chemical_compound") return "category mismatch: chemical compound";if(key==="category_mismatch_person") return "category mismatch: person";if(key==="category_mismatch_place") return "category mismatch: place";if(key==="category_mismatch_name_like") return "category mismatch: name-like interpretation";return key||"unspecified";}

export function findTermForAmbiguityItem(item){const key=toCanonicalKey(item?.termLabel||"");if(!key) return null;const discName=toCanonicalKey(item?.discName||"");return TERMS.find(t=>toCanonicalKey(t?.label||"")===key&&(!discName||t.slices.some(i=>toCanonicalKey(DISCS[i]?.name||"")===discName)))||TERMS.find(t=>toCanonicalKey(t?.label||"")===key)||null;}

export function applyAmbiguityDecisionToTerm(item,decision,{note=""}={}){
  const term=findTermForAmbiguityItem(item);
  if(!term) return false;
  const snippet=String(item?.snippet||item?.bestDefinition||item?.inputInterpretation||"").trim();
  term.descriptions=normalizeTermDescriptions(term.descriptions,{fallbackDescription:term.description,fallbackSource:term.description_source,label:term.label});
  if(snippet){
    term.descriptions.wolframGrounding=mergeDescription(term.descriptions.wolframGrounding,snippet);
  }
  term.descriptions.wolframDisplayMode=decision==="accept"?"append":"metadata_only";
  if(Number.isFinite(Number(item?.score))) term.descriptions.wolframMinScore=clampGroundingSnippetScore(item.score,0.58);
  if(Number.isFinite(Number(item?.semanticAlignmentScore))) term.descriptions.wolframMinAlignmentScore=clampGroundingSnippetScore(item.semanticAlignmentScore,0.55);
  const fallbackDescription=String(term?.descriptions?.synthesisSummary||term?.descriptions?.probeSummary||term.description||"").trim();
  applyDisplayDescriptionForTerm(term,{fallbackDescription,fallbackSource:term.description_source||"llm"});
  const confLevel=normalizeConfidenceLevel(item?.confidence||"low");
  const confScore=Number.isFinite(Number(item?.score))?Number(item.score):null;
  const groundingStatus=decision==="accept"?"grounded":"failed";
  term.grounding=mergeGroundingBlocks(term.grounding,normalizeGroundingBlock({wolframQueriesTried:item?.query?[item.query]:[],wolframInterpretations:[item?.chosenInterpretation,item?.inputInterpretation,...(item?.didYouMeans||[])].filter(Boolean),groundingStatus,wolframConfidence:{level:confLevel,score:confScore},wolframResolution:`manual review: ${decision}`,wolframChosenInterpretation:String(item?.chosenInterpretation||item?.inputInterpretation||"").trim()}));
  term.description_provenance=mergeDescriptionProvenance(term.description_provenance,[{source:"wolfram",stage:"manual_review",status:decision==="accept"?"accepted_manual":"probe_only_manual",impact:decision==="accept"?"display_description_enriched":"metadata_only",query:String(item?.query||""),note:note||`Ambiguity queue decision: ${decision}`}]);
  if(decision==="accept"&&snippet){
    const chosen={query:String(item?.query||""),definition:snippet,scoring:{score:Number.isFinite(Number(item?.score))?Number(item.score):0,confidence:String(item?.confidence||"low"),reasons:Array.isArray(item?.reasons)?item.reasons:[]},parsed:{inputInterpretation:String(item?.inputInterpretation||""),bestDefinition:String(item?.bestDefinition||""),altFacts:[],assumptions:Array.isArray(item?.assumptions)?item.assumptions:[],didYouMeans:Array.isArray(item?.didYouMeans)?item.didYouMeans:[],warnings:Array.isArray(item?.warnings)?item.warnings:[]}};
    const cite=buildWolframGroundingCitation(term.label,chosen,true,"manual ambiguity review",{appliedToDescription:true,policyMode:"manual"});
    const citeId=upsertCitationEntry(cite);
    if(Number.isInteger(citeId)&&!term.citations.includes(citeId)) term.citations.push(citeId);
  }
  refreshTermSignalFields([term]);
  if(document.getElementById("d-label")?.textContent===term.label) showTermDetail(term);
  return true;
}

export function buildAmbiguityRetryTemplates(item){
  const label=sanitizeWolframToken(item?.termLabel||"");
  const discName=sanitizeWolframToken(item?.discName||"");
  const domainHint=deriveWolframDomainHintFromDiscName(discName)||discName;
  const templates=[
    {key:"quoted_label",label:"RETRY QUOTED",query:label?`"${label}"`:""},
    {key:"domain_hint",label:"RETRY DOMAIN",query:label&&domainHint?`${label} ${domainHint}`.trim():label},
    {key:"concept_query",label:"RETRY CONCEPT",query:label?`${label} concept`:""}
  ];
  const seen=new Set();
  const out=[];
  for(const t of templates){
    const q=String(t.query||"").trim();
    if(!q) continue;
    const key=q.toLowerCase();
    if(seen.has(key)) continue;
    seen.add(key);
    out.push({...t,query:q});
  }
  return out;
}

export function getAmbiguityRetryTemplate(item,templateKey){
  const wanted=String(templateKey||"").trim().toLowerCase();
  return buildAmbiguityRetryTemplates(item).find(t=>String(t.key||"").toLowerCase()===wanted)||null;
}

export async function retryAmbiguityWithQuery(item,query,{attemptStrategy="manual_retry",resolutionLabel="manual_retry",reviewNotePrefix="Retried query"}={}){
  const normalizedQuery=String(query||"").trim();
  if(!normalizedQuery) return false;
  const cfg=readApiConfig();
  if(normalizeMode(cfg)!=="proxy"){showToast("Retry requires proxy mode for Wolfram.");return false;}
  if(!cfg?.wolframAppId){showToast("Add Wolfram AppID to retry.");return false;}
  const target=item?.target||RUN_STATE?.target||LAST_RUN?.target||document.getElementById("viz-target-label")?.textContent||"";
  const policy=resolveGroundingPolicy(cfg);
  const data=await fetchWolframJSON(normalizedQuery,cfg,{target,discName:item?.discName||"Ambiguity Review",termLabel:item?.termLabel||"",resolutionLabel});
  const parsed=extractWolframStructured(data);
  const selected=selectWolframSnippetFromParsed(parsed);
  const snippet=String(selected?.snippet||"").trim();
  const chosenInterpretation=String(selected?.chosenInterpretation||parsed?.inputInterpretation||parsed?.bestDefinition||"").trim();
  const chosenPod=resolveWolframChosenPod(parsed,snippet);
  const entityType=String(item?.entityType||item?.wolframEntityType||"").trim();
  const scoring=scoreWolframSnippet(snippet,item?.termLabel||"",policy.minQualityScore,policy.minAlignmentScore,{chosenInterpretation,parsed,entityType,chosenPod});
  const categoryGate=evaluateGroundingCategoryMismatch({termLabel:item?.termLabel||"",entityType,chosenInterpretation,definition:snippet,parsed,chosenPod,policy,scoring});
  const baseDecision=evaluateGroundingApplication(scoring,policy);
  const driftDecision=applySingleWordDriftGuard(baseDecision,scoring);
  const warningDecision=applyWarningAssumptionRiskGuard(driftDecision,scoring);
  const compositeDecision=applyCompositeTermAppendGuard(warningDecision,scoring,{termLabel:item?.termLabel||"",definition:snippet,chosenInterpretation,parsed});
  const decision=applyGroundingCategoryMismatchGuard(compositeDecision,categoryGate);
  const combinedReasons=[...(Array.isArray(scoring?.reasons)?scoring.reasons:[]),...(Array.isArray(decision?.reasons)?decision.reasons:[])];
  const retryStatus=snippet?(decision.accepted?decision.status:String(decision?.status||"rejected_low_confidence")):"no_plaintext";
  const retryReasons=snippet?combinedReasons:[...new Set([...(combinedReasons||[]),...buildNoPlaintextReasons(parsed)])];
  recordWolframGroundingDiagnostic({target,discName:item?.discName||"Ambiguity Review",termLabel:item?.termLabel||"",attemptRank:null,attemptStrategy,resolutionLabel,stopReason:resolutionLabel,query:normalizedQuery,snippet,accepted:Boolean(decision?.accepted),status:retryStatus,score:Number.isFinite(Number(scoring?.score))?Number(scoring.score):0,snippetQualityScore:Number.isFinite(Number(scoring?.snippet_quality_score))?Number(scoring.snippet_quality_score):null,semanticAlignmentScore:Number.isFinite(Number(scoring?.semantic_alignment_score))?Number(scoring.semantic_alignment_score):null,confidence:String(scoring?.confidence||"low"),reasons:retryReasons,inputInterpretation:String(parsed?.inputInterpretation||""),bestDefinition:String(parsed?.bestDefinition||""),altFacts:Array.isArray(parsed?.altFacts)?parsed.altFacts:[],assumptions:Array.isArray(parsed?.assumptions)?parsed.assumptions:[],didYouMeans:Array.isArray(parsed?.didYouMeans)?parsed.didYouMeans:[],warnings:Array.isArray(parsed?.warnings)?parsed.warnings:[],chosenInterpretation:String(chosenInterpretation||parsed?.inputInterpretation||parsed?.bestDefinition||""),mode:normalizeMode(cfg),statusCode:200,durationMs:0,cacheStatus:"memory_miss",chosenPod,appliedToDescription:false,success:true});
  const key=ambiguityQueueKey({runId:item?.runId||CURRENT_RUN_ID||"run",discName:item?.discName,termLabel:item?.termLabel});
  const hit=AMBIGUITY_QUEUE.find(row=>row.id===key);
  if(hit){
    hit.reviewStatus="pending";
    hit.reviewNote=`${reviewNotePrefix}: ${normalizedQuery}`;
    hit.reviewedAt="";
    hit.retryCount=clampInt((hit.retryCount||0)+1,0,999);
    hit.lastUpdated=new Date().toISOString();
  }
  sortAmbiguityQueueInPlace();
  updateAmbiguityQueueUIState();
  showToast(snippet?"Retry captured. Review and choose keep/accept.":"Retry returned no usable plaintext.");
  return true;
}

export async function retryAmbiguityWithTemplate(item,templateKey){
  const template=getAmbiguityRetryTemplate(item,templateKey);
  if(!template){showToast("Template retry unavailable for this term.");return false;}
  return retryAmbiguityWithQuery(item,template.query,{attemptStrategy:`manual_retry_${template.key}`,resolutionLabel:`manual_retry_${template.key}`,reviewNotePrefix:`Retried ${template.label.toLowerCase()}`});
}

export async function retryAmbiguityWithCustomQuery(item){
  const current=String(item?.query||item?.termLabel||"").trim();
  const query=String(prompt("Retry Wolfram query for this term:",current)||"").trim();
  if(!query) return false;
  return retryAmbiguityWithQuery(item,query,{attemptStrategy:"manual_retry",resolutionLabel:"manual_retry",reviewNotePrefix:"Retried custom query"});
}
