import { normalizeMode } from '../api/provider.js';
import { getWolframQueryCache, setWolframQueryCache } from './wolfram-cache.js';
import { clampGroundingSnippetScore, classifyWolframResolvedCategory, recordWolframAuditEvent } from './wolfram-score.js';
import { normalizeWolframAssumptionText } from './wolfram-grounding.js';
import { toCanonicalKey } from '../domain/aliases.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Source: ruliad_expedition_v1.1.html
// Module: js/grounding/wolfram-parse.js

export function wolframPublicInputUrl(query){return `https://www.wolframalpha.com/input?i=${encodeURIComponent(String(query||""))}`;}

export function sanitizeWolframToken(value){return String(value||"").replace(/[\r\n\t]+/g," ").replace(/\s+/g," ").replace(/"/g,"").trim();}

export function canonicalizeWolframLabelForQuery(label){
  const clean=sanitizeWolframToken(label);
  if(!clean) return "";
  const canonical=toCanonicalKey(clean);
  return sanitizeWolframToken(canonical);
}

export async function fetchWolframJSON(query,cfg,auditContext={}){
  const normalizedQuery=String(query||"").trim();
  const mode=normalizeMode(cfg);
  const ctx={
    target:String(auditContext?.target||"").trim(),
    discName:String(auditContext?.discName||"").trim(),
    termLabel:String(auditContext?.termLabel||"").trim(),
    attemptRank:Number.isFinite(Number(auditContext?.attemptRank))?Number(auditContext.attemptRank):null,
    attemptStrategy:String(auditContext?.attemptStrategy||"").trim(),
    resolutionLabel:String(auditContext?.resolutionLabel||"").trim()
  };
  const started=Date.now();
  const cached=getWolframQueryCache(normalizedQuery);
  if(cached){
    const durationMs=Date.now()-started;
    const cacheStatus="memory_hit";
    recordWolframAuditEvent({...ctx,stage:"fetch",query:normalizedQuery,mode,statusCode:200,success:true,durationMs,cacheStatus,note:"Browser query cache hit"});
    if(cached&&typeof cached==="object"){
      Object.defineProperty(cached,"__waAudit",{value:{mode,cacheStatus,statusCode:200,durationMs},enumerable:false,configurable:true});
    }
    return cached;
  }
  const appid=String(cfg?.wolframAppId||"").trim();
  if(!appid){
    recordWolframAuditEvent({...ctx,stage:"fetch",query:normalizedQuery,mode,statusCode:401,success:false,durationMs:Date.now()-started,cacheStatus:"memory_miss",status:"error",note:"Missing Wolfram AppID"});
    throw new Error("Missing Wolfram AppID.");
  }
  if(mode!=="proxy"){
    recordWolframAuditEvent({...ctx,stage:"fetch",query:normalizedQuery,mode,statusCode:0,success:false,durationMs:Date.now()-started,cacheStatus:"memory_miss",status:"error",note:"Direct mode blocked by CORS"});
    throw new Error("Wolfram Full Results API is blocked by browser CORS in direct mode. Switch to proxy mode.");
  }
  let res=null;
  try{
    res=await fetch("/wa/normalize",{
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body:JSON.stringify({appid,input:normalizedQuery,output:"json",format:"plaintext",reinterpret:true})
    });
    const proxyCacheRaw=res.headers?.get("X-Wolfram-Cache")||"";
    const cacheStatus=proxyCacheRaw?`proxy_${String(proxyCacheRaw).trim().toLowerCase()}`:"memory_miss";
    if(!res.ok){
      const raw=(await res.text()).slice(0,240);
      if(res.status===404||res.status===405){
        res=await fetch("/api/wolfram/query",{
          method:"POST",
          headers:{"Content-Type":"application/json"},
          body:JSON.stringify({appid,input:normalizedQuery,output:"json",format:"plaintext",reinterpret:true})
        });
      }else{
        recordWolframAuditEvent({...ctx,stage:"fetch",query:normalizedQuery,mode,statusCode:res.status,success:false,durationMs:Date.now()-started,cacheStatus,status:"error",note:raw});
        throw new Error(`Wolfram normalize proxy request failed (${res.status}): ${raw}`);
      }
    }
    const proxyCacheRawFinal=res.headers?.get("X-Wolfram-Cache")||"";
    const cacheStatusFinal=proxyCacheRawFinal?`proxy_${String(proxyCacheRawFinal).trim().toLowerCase()}`:"memory_miss";
    if(!res.ok){
      const raw=(await res.text()).slice(0,240);
      recordWolframAuditEvent({...ctx,stage:"fetch",query:normalizedQuery,mode,statusCode:res.status,success:false,durationMs:Date.now()-started,cacheStatus:cacheStatusFinal,status:"error",note:raw});
      throw new Error(`Wolfram proxy request failed (${res.status}): ${raw}`);
    }
    const data=await res.json();
    setWolframQueryCache(normalizedQuery,data);
    const durationMs=Date.now()-started;
    recordWolframAuditEvent({...ctx,stage:"fetch",query:normalizedQuery,mode,statusCode:res.status,success:true,durationMs,cacheStatus:cacheStatusFinal});
    if(data&&typeof data==="object"){
      Object.defineProperty(data,"__waAudit",{value:{mode,cacheStatus:cacheStatusFinal,statusCode:res.status,durationMs},enumerable:false,configurable:true});
    }
    return data;
  }catch(err){
    if(!res){
      recordWolframAuditEvent({...ctx,stage:"fetch",query:normalizedQuery,mode,statusCode:0,success:false,durationMs:Date.now()-started,cacheStatus:"memory_miss",status:"error",note:String(err?.message||err)});
    }
    throw err;
  }
}

export function compactWolframText(text,maxLen=420){return String(text||"").replace(/\s+/g," ").trim().slice(0,maxLen);}

export function resolveWolframTemplateToken(values,key){
  const raw=String(key||"").trim();
  if(!raw) return "";
  const candidates=[raw,raw.toLowerCase(),raw.replace(/[^a-z0-9]+/gi,""),raw.replace(/[^a-z0-9]+/gi,"").toLowerCase()];
  for(const candidate of candidates){
    if(!candidate) continue;
    const hit=values?.[candidate];
    if(hit!==undefined&&hit!==null&&String(hit).trim()) return compactWolframText(String(hit),120);
  }
  return "";
}

export function isWolframLowSignalText(text){
  const t=compactWolframText(text,320);
  if(!t) return true;
  if(/^(?:none|n\/a|null|unknown|not available|not applicable)$/i.test(t)) return true;
  const canon=t.toLowerCase().replace(/[^a-z0-9]+/g," ").trim();
  if(/^(?:entity|person|location|place|thing|object|item|concept|term|image)$/i.test(canon)) return true;
  if(/^\(?image\)?$/i.test(canon)) return true;
  return false;
}

export function wolframPodTitleScore(title){
  const t=String(title||"").toLowerCase();
  if(/input interpretation/.test(t)) return 120;
  if(/definition|definitions/.test(t)) return 112;
  if(/basic information/.test(t)) return 102;
  if(/^result$|result /.test(t)) return 98;
  if(/properties/.test(t)) return 92;
  if(/assumption|possible interpretation/.test(t)) return 46;
  if(/name|identity|identification|wikipedia/.test(t)) return 18;
  return 54;
}

export function extractWolframListValues(value,maxItems=8){
  const out=[];
  const pushIf=(v)=>{const t=compactWolframText(v,220);if(t&&!out.includes(t)) out.push(t);};
  const walk=(node)=>{
    if(out.length>=maxItems||node===null||node===undefined) return;
    if(typeof node==="string"){pushIf(node);return;}
    if(Array.isArray(node)){for(const x of node){walk(x);if(out.length>=maxItems) break;}return;}
    if(typeof node==="object"){
      if(typeof node.plaintext==="string") pushIf(node.plaintext);
      if(typeof node.text==="string") pushIf(node.text);
      if(typeof node.desc==="string") pushIf(node.desc);
      if(typeof node.word==="string"&&typeof node.desc==="string") pushIf(`${node.word}: ${node.desc}`);
      if(typeof node.value==="string") pushIf(node.value);
      if(typeof node.name==="string"&&!node.desc&&!node.text) pushIf(node.name);
      if(typeof node["#text"]==="string") pushIf(node["#text"]);
      for(const key of Object.keys(node)){walk(node[key]);if(out.length>=maxItems) break;}
    }
  };
  walk(value);
  return out.filter(x=>!isWolframLowSignalText(x)).slice(0,maxItems);
}

export function extractWolframStructured(data){
  const normalized=data?.normalized&&typeof data.normalized==="object"?data.normalized:(data&&typeof data==="object"?data:null);
  if(normalized&&("bestPlaintext" in normalized||"candidateFacts" in normalized||"inputInterpretation" in normalized)){
    const bestDefinition=compactWolframText(normalized.bestPlaintext||"",420);
    const inputInterpretation=compactWolframText(normalized.inputInterpretation||"",320);
    const altFacts=Array.isArray(normalized.candidateFacts)?normalized.candidateFacts.map(x=>compactWolframText(x,320)).filter(Boolean):[];
    const assumptions=Array.isArray(normalized.assumptions)?normalized.assumptions.map(x=>normalizeWolframAssumptionText(x,{})).filter(Boolean):[];
    const didYouMeans=Array.isArray(normalized.didYouMeans)?normalized.didYouMeans.map(x=>compactWolframText(x,200)).filter(Boolean):[];
    const warnings=Array.isArray(normalized.warnings)?normalized.warnings.map(x=>compactWolframText(x,220)).filter(Boolean):[];
    const chosenPod=String(normalized.chosenPod||"").trim();
    const candidates=[bestDefinition,...altFacts].filter(Boolean).map((text,idx)=>({title:idx===0?(chosenPod||"Result"):"Alternative fact",text,score:idx===0?120:80,podId:"normalized",subpodIndex:idx}));
    return {
      inputInterpretation,
      bestDefinition,
      altFacts:[...new Set(altFacts)].slice(0,6),
      assumptions:[...new Set(assumptions)].slice(0,6),
      didYouMeans:[...new Set(didYouMeans)].slice(0,6),
      warnings:[...new Set(warnings)].slice(0,6),
      candidates:candidates.slice(0,12)
    };
  }
  const queryresult=data?.queryresult&&typeof data.queryresult==="object"?data.queryresult:{};
  const pods=Array.isArray(queryresult.pods)?queryresult.pods:[];
  const candidates=[];
  for(const pod of pods){
    const title=String(pod?.title||"").trim();
    const base=wolframPodTitleScore(title);
    const subpods=Array.isArray(pod?.subpods)?pod.subpods:[];
    for(let i=0;i<subpods.length;i++){
      const sub=subpods[i];
      const textCandidates=[];
      const seenTexts=new Set();
      const pushText=(raw)=>{
        const text=compactWolframText(raw,420);
        if(!text) return;
        const key=toCanonicalKey(text)||text.toLowerCase();
        if(seenTexts.has(key)) return;
        seenTexts.add(key);
        textCandidates.push(text);
      };
      pushText(sub?.plaintext);
      for(const fallbackText of extractWolframListValues(sub,4)){
        pushText(fallbackText);
        if(textCandidates.length>=3) break;
      }
      for(let textIdx=0;textIdx<textCandidates.length;textIdx++){
        const text=textCandidates[textIdx];
        if(!text||isWolframLowSignalText(text)) continue;
        let score=base;
        if(text.length<24) score-=16;
        if(text.length>=40&&text.length<=240) score+=9;
        if(/(?:assuming|assumptions?)/i.test(text)) score-=8;
        if(/^\d+(?:\.\d+)?$/.test(text)) score-=18;
        if(textIdx>0) score-=6;
        candidates.push({title,text,score,podId:String(pod?.id||""),subpodIndex:i});
      }
    }
  }
  candidates.sort((a,b)=>b.score-a.score);
  const inputInterpretation=(candidates.find(c=>/input interpretation/i.test(c.title))?.text)||"";
  const defCandidates=candidates.filter(c=>/definition|basic information|result|properties/i.test(c.title));
  const bestDefinition=(defCandidates[0]?.text)||(candidates[0]?.text)||"";
  const altFacts=[];
  for(const c of candidates){
    if(c.text===bestDefinition||c.text===inputInterpretation) continue;
    if(altFacts.includes(c.text)) continue;
    altFacts.push(c.text);
    if(altFacts.length>=4) break;
  }
  const assumptionsRaw=queryresult.assumptions??queryresult.assumption??null;
  const assumptions=[];
  const pushAssumption=(text,context={})=>{const t=normalizeWolframAssumptionText(text,context);if(t&&!assumptions.includes(t)) assumptions.push(t);};
  const assumptionTemplateContext=(node)=>{
    if(!node||typeof node!=="object") return {};
    const ctx={};
    for(const [k,v] of Object.entries(node)){
      if(v===null||v===undefined) continue;
      if(typeof v==="string"||typeof v==="number"||typeof v==="boolean") ctx[k]=String(v);
      if(Array.isArray(v)&&v.length&&v.every(x=>typeof x==="string"||typeof x==="number"||typeof x==="boolean")) ctx[k]=v.map(x=>String(x)).join(" | ");
    }
    return ctx;
  };
  const readAssumptions=(node)=>{
    if(!node) return;
    if(Array.isArray(node)){for(const n of node){readAssumptions(n);}return;}
    if(typeof node==="object"){
      if(Array.isArray(node.assumption)){for(const a of node.assumption){readAssumptions(a);}return;}
      const templateCtx=assumptionTemplateContext(node);
      const word=typeof node.word==="string"?node.word.trim():"";
      const desc=typeof node.desc==="string"?node.desc.trim():"";
      const value=typeof node.value==="string"?node.value.trim():"";
      if(word&&desc) pushAssumption(`${word}: ${desc}`,templateCtx);
      if(desc&&!word) pushAssumption(desc,templateCtx);
      if(value&&word) pushAssumption(`${word} -> ${value}`,templateCtx);
      if(typeof node.template==="string") pushAssumption(node.template,templateCtx);
      if(typeof node.plaintext==="string") pushAssumption(node.plaintext,templateCtx);
    }
  };
  readAssumptions(assumptionsRaw);
  const didYouRaw=queryresult.didyoumeans??queryresult.didyoumean??null;
  const didYouMeans=[];
  const pushDidYou=(text)=>{const t=compactWolframText(text,140);if(t&&!didYouMeans.includes(t)) didYouMeans.push(t);};
  const readDidYou=(node)=>{
    if(!node) return;
    if(Array.isArray(node)){for(const n of node){readDidYou(n);}return;}
    if(typeof node==="object"){
      if(Array.isArray(node.didyoumean)){for(const d of node.didyoumean){readDidYou(d);}return;}
      if(typeof node["#text"]==="string") pushDidYou(node["#text"]);
      if(typeof node.text==="string") pushDidYou(node.text);
      if(typeof node.word==="string") pushDidYou(node.word);
      return;
    }
    if(typeof node==="string") pushDidYou(node);
  };
  readDidYou(didYouRaw);
  const warningsRaw=queryresult.warnings??queryresult.warning??null;
  const warnings=[...extractWolframListValues(warningsRaw,4)];
  if(queryresult.timedout) warnings.push(`Timed out pods: ${String(queryresult.timedout)}`);
  if(queryresult.error===true) warnings.push("Wolfram queryresult.error=true");
  return {
    inputInterpretation,
    bestDefinition,
    altFacts,
    assumptions:assumptions.filter(x=>!isWolframLowSignalText(x)).slice(0,6),
    didYouMeans:didYouMeans.filter(x=>!isWolframLowSignalText(x)).slice(0,6),
    warnings:[...new Set(warnings.map(x=>compactWolframText(x,220)).filter(Boolean))].slice(0,6),
    candidates:candidates.slice(0,12)
  };
}

export function selectWolframSnippetFromParsed(parsed){
  const clean=(value,maxLen=420)=>compactWolframText(value,maxLen);
  const valid=(value)=>{const text=clean(value);return text&&!isWolframLowSignalText(text);};
  const normalized=parsed&&typeof parsed==="object"?parsed:{};
  const candidateTexts=Array.isArray(normalized.candidates)?normalized.candidates.slice().sort((a,b)=>(Number(b?.score)||0)-(Number(a?.score)||0)).map(item=>clean(item?.text,420)).filter(valid):[];
  const altFacts=Array.isArray(normalized.altFacts)?normalized.altFacts.map(x=>clean(x,420)).filter(valid):[];
  const assumptions=Array.isArray(normalized.assumptions)?normalized.assumptions.map(x=>clean(x,320)).filter(x=>valid(x)&&!/^assumption clash/i.test(x)):[];
  const didYouMeans=Array.isArray(normalized.didYouMeans)?normalized.didYouMeans.map(x=>clean(x,220)).filter(valid):[];
  const inputInterpretation=clean(normalized.inputInterpretation,320);
  const bestDefinition=clean(normalized.bestDefinition,420);
  const ordered=[
    {source:"best_definition",text:bestDefinition},
    {source:"candidate_fact",text:candidateTexts[0]||""},
    {source:"input_interpretation",text:inputInterpretation},
    {source:"alt_fact",text:altFacts[0]||""},
    {source:"assumption_fallback",text:assumptions[0]||""},
    {source:"didyoumean_fallback",text:didYouMeans[0]||""}
  ];
  const picked=ordered.find(item=>valid(item.text))||null;
  const snippet=picked?clean(picked.text,420):"";
  const chosenInterpretation=clean(inputInterpretation||bestDefinition||didYouMeans[0]||snippet,320);
  return {snippet,source:picked?.source||"",chosenInterpretation};
}

export function buildNoPlaintextReasons(parsed){
  const base=["empty","parser_selection_exhausted"];
  const hasStructuredSignal=Boolean(
    String(parsed?.inputInterpretation||"").trim()||
    String(parsed?.bestDefinition||"").trim()||
    (Array.isArray(parsed?.altFacts)&&parsed.altFacts.length)||
    (Array.isArray(parsed?.assumptions)&&parsed.assumptions.length)||
    (Array.isArray(parsed?.didYouMeans)&&parsed.didYouMeans.length)||
    (Array.isArray(parsed?.candidates)&&parsed.candidates.length)
  );
  if(hasStructuredSignal) base.push("structured_response_present");
  return base;
}

export function extractWolframPlaintext(data){
  const parsed=extractWolframStructured(data);
  const selected=selectWolframSnippetFromParsed(parsed);
  return selected.snippet||"";
}

export function resolveWolframChosenPod(parsed,snippet){
  const candidates=Array.isArray(parsed?.candidates)?parsed.candidates:[];
  const snippetKey=toCanonicalKey(snippet||"");
  if(snippetKey){
    const exact=candidates.find(c=>toCanonicalKey(c?.text||"")===snippetKey);
    if(exact?.title) return String(exact.title||"").trim();
  }
  if(Array.isArray(candidates)&&candidates[0]?.title){
    return String(candidates[0].title||"").trim();
  }
  if(String(parsed?.bestDefinition||"").trim()) return "Definition";
  if(String(parsed?.inputInterpretation||"").trim()) return "Input interpretation";
  return "";
}

export function scoreWolframSnippet(snippet,termLabel,minQualityScore=0.58,minAlignmentScore=0.55,context={}){
  const text=String(snippet||"").replace(/\s+/g," ").trim();
  const normalized=text.toLowerCase();
  const labelNorm=String(termLabel||"").replace(/\s+/g," ").trim().toLowerCase();
  const reasons=[];
  const qualityThreshold=clampGroundingSnippetScore(minQualityScore,0.58);
  const alignmentThreshold=clampGroundingSnippetScore(minAlignmentScore,0.55);
  if(!text){
    return {score:0,accept:false,confidence:"low",reasons:["empty"],length:0,wordCount:0,threshold:qualityThreshold,quality_threshold:qualityThreshold,alignment_threshold:alignmentThreshold,snippet_quality_score:0,semantic_alignment_score:0,quality_accept:false,alignment_accept:false,single_word_drift:false,single_word_drift_warning_signal:false,closest_interpretation_type_mismatch:false,assumption_clash_generic_token:false};
  }
  let qualityScore=1;
  const words=text.split(" ").filter(Boolean);
  const genericTokens=new Set(["entity","entities","person","people","location","place","concept","thing","object","item","term","idea","category","unknown","n/a","na","none","null"]);
  const normalizedWords=words.map(w=>w.toLowerCase().replace(/[^a-z0-9]/g,"")).filter(Boolean);
  if(text.length<24||normalizedWords.length<4){
    qualityScore-=0.45;
    reasons.push("too_short");
  }
  const genericOnly=normalizedWords.length>0&&normalizedWords.every(w=>genericTokens.has(w));
  if(genericOnly||genericTokens.has(normalized.replace(/[^a-z0-9]/g,""))){
    qualityScore-=0.7;
    reasons.push("generic_placeholder");
  }
  const canonText=toCanonicalKey(text);
  const canonLabel=toCanonicalKey(termLabel||"");
  if((canonText&&canonLabel&&canonText===canonLabel)||normalized===labelNorm){
    qualityScore-=0.8;
    reasons.push("same_as_label");
  }
  const digitCount=(text.match(/[0-9]/g)||[]).length;
  const alphaCount=(text.match(/[A-Za-z]/g)||[]).length;
  const semanticCue=/(?:\bis\b|\bare\b|\brefers to\b|\bdefined\b|\bmeans\b|\btype\b|\bclass\b|\bprocess\b|\btheory\b|\bcondition\b|\bsyndrome\b|\bprinciple\b)/i.test(text);
  if(digitCount>0){
    const total=digitCount+alphaCount;
    const numericRatio=total?digitCount/total:1;
    if((alphaCount===0||numericRatio>=0.52)&&!semanticCue){
      qualityScore-=0.55;
      reasons.push("mostly_numeric");
    }
  }
  qualityScore=Math.max(0,Math.min(1,qualityScore));
  const stopWords=new Set(["a","an","the","of","for","to","in","on","at","by","with","from","and","or","as","via","into","is","are","be","this","that","these","those"]);
  const tokenize=(value)=>String(value||"").toLowerCase().split(/[^a-z0-9]+/g).map(tok=>tok.trim()).filter(tok=>tok&&tok.length>1&&!stopWords.has(tok));
  const labelTokens=[...new Set(tokenize(termLabel||""))];
  const snippetTokenSet=new Set(tokenize(text));
  const overlapCount=labelTokens.filter(tok=>snippetTokenSet.has(tok)).length;
  const overlapRatio=labelTokens.length?overlapCount/labelTokens.length:0;
  const phraseMatch=Boolean(canonLabel&&canonText&&canonText.includes(canonLabel));
  let semanticAlignmentScore=labelTokens.length?0.35+Math.min(0.6,overlapRatio*0.62):0.55;
  if(phraseMatch) semanticAlignmentScore=Math.max(semanticAlignmentScore,0.92);
  if(labelTokens.length&&overlapCount===0){
    semanticAlignmentScore-=0.2;
    reasons.push("label_tokens_missing");
  }
  if(genericOnly) semanticAlignmentScore-=0.2;
  if((canonText&&canonLabel&&canonText===canonLabel)||normalized===labelNorm) semanticAlignmentScore-=0.15;
  const entityTypeRaw=String(context?.entityType||"").trim();
  const entityTypePresent=Boolean(entityTypeRaw);
  const interpretationText=String(context?.chosenInterpretation||context?.parsed?.inputInterpretation||context?.parsed?.bestDefinition||text).replace(/\s+/g," ").trim();
  const interpretationTokens=new Set(tokenize(interpretationText));
  const interpretationMatchCount=labelTokens.filter(tok=>interpretationTokens.has(tok)).length;
  const warningsList=[...(Array.isArray(context?.warnings)?context.warnings:[]),...(Array.isArray(context?.parsed?.warnings)?context.parsed.warnings:[])].map(x=>String(x||"").trim()).filter(Boolean);
  const warningText=warningsList.join(" ").toLowerCase();
  const warningSignal=/(?:closest\s+wolfram\|alpha\s+interpretation|closest\s+interpretation|closest\s+match|clash)/i.test(warningText);
  const entityTypeTokens=entityTypeRaw.toLowerCase().replace(/([a-z])([A-Z])/g,"$1 $2").split(/[^a-z0-9]+/g).map(x=>x.trim()).filter(Boolean);
  const interpretationBlob=[interpretationText,text,String(context?.chosenPod||""),String(context?.parsed?.bestDefinition||""),String(context?.parsed?.inputInterpretation||"")].join(" ").toLowerCase();
  const categoryFromInterpretation=classifyWolframResolvedCategory({entityType:"",chosenInterpretation:interpretationText,definition:text,parsed:context?.parsed||{},chosenPod:String(context?.chosenPod||"")});
  const expectedCategories=(()=>{const t=entityTypeRaw.toLowerCase();if(/airport|airfield/.test(t)) return ["airport","place"];if(/periodical|journal|magazine|newspaper|publication/.test(t)) return ["periodical"];if(/chemical|compound|molecule|drug|protein|gene|enzyme|substance/.test(t)) return ["chemical_compound"];if(/person|people|human|biography/.test(t)) return ["person"];if(/city|country|state|province|county|location|place|geographic|airport/.test(t)) return ["place","airport"];return [];})();
  const typeTokenOverlap=entityTypeTokens.filter(tok=>interpretationBlob.includes(tok)).length;
  const interpretationTypeMatch=!entityTypePresent||Boolean((expectedCategories.length&&expectedCategories.includes(categoryFromInterpretation))||typeTokenOverlap>0);
  const closestInterpretationWarning=/(?:closest\s+wolfram\|alpha\s+interpretation|closest\s+interpretation|closest\s+match)/i.test(warningText);
  if(closestInterpretationWarning&&!interpretationTypeMatch){
    semanticAlignmentScore-=0.34;
    qualityScore-=0.12;
    reasons.push("closest_interpretation_type_mismatch");
  }
  const assumptionsList=[...(Array.isArray(context?.assumptions)?context.assumptions:[]),...(Array.isArray(context?.parsed?.assumptions)?context.parsed.assumptions:[])].map(x=>String(x||"").trim()).filter(Boolean);
  const assumptionClashLines=assumptionsList.filter(line=>/\bclash\b/i.test(line));
  const genericAssumptionTokens=new Set(["counter","imperative","structure","interactional","interaction","asymmetry","system","model","process","method","rule","law","principle","theory","framework","network","signal","state","value","class","type","function","logic"]);
  const genericLabelTokenHit=labelTokens.find(tok=>genericAssumptionTokens.has(tok)&&assumptionClashLines.some(line=>new RegExp(`\\b${tok.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}\\b`,"i").test(line)));
  if(genericLabelTokenHit){
    semanticAlignmentScore-=0.24;
    qualityScore-=0.08;
    reasons.push("assumption_clash_generic_token");
  }
  const singleWordDrift=labelTokens.length>=2&&interpretationMatchCount===1;
  if(singleWordDrift){
    semanticAlignmentScore-=0.2;
    reasons.push("single_word_drift");
    if(warningSignal){
      semanticAlignmentScore-=0.12;
      reasons.push("single_word_drift_warning_signal");
    }
  }
  qualityScore=Math.max(0,Math.min(1,qualityScore));
  semanticAlignmentScore=Math.max(0,Math.min(1,semanticAlignmentScore));
  const qualityAccept=qualityScore>=qualityThreshold;
  const alignmentAccept=semanticAlignmentScore>=alignmentThreshold;
  const accept=qualityAccept&&alignmentAccept;
  const combinedScore=Math.max(0,Math.min(1,(qualityScore*0.55)+(semanticAlignmentScore*0.45)));
  const minComponent=Math.min(qualityScore,semanticAlignmentScore);
  const confidence=!accept?"low":minComponent>=0.82?"high":"medium";
  return {score:Number(combinedScore.toFixed(3)),accept,confidence,reasons,length:text.length,wordCount:normalizedWords.length,threshold:qualityThreshold,quality_threshold:qualityThreshold,alignment_threshold:alignmentThreshold,snippet_quality_score:Number(qualityScore.toFixed(3)),semantic_alignment_score:Number(semanticAlignmentScore.toFixed(3)),quality_accept:qualityAccept,alignment_accept:alignmentAccept,single_word_drift:singleWordDrift,single_word_drift_warning_signal:Boolean(singleWordDrift&&warningSignal),closest_interpretation_type_mismatch:Boolean(closestInterpretationWarning&&!interpretationTypeMatch),assumption_clash_generic_token:Boolean(genericLabelTokenHit)};
}

export function serializeWolframParsed(parsed){return {inputInterpretation:String(parsed?.inputInterpretation||""),bestDefinition:String(parsed?.bestDefinition||""),altFacts:Array.isArray(parsed?.altFacts)?parsed.altFacts.map(x=>String(x||"")).filter(Boolean):[],assumptions:Array.isArray(parsed?.assumptions)?parsed.assumptions.map(x=>normalizeWolframAssumptionText(x,{})).filter(Boolean):[],didYouMeans:Array.isArray(parsed?.didYouMeans)?parsed.didYouMeans.map(x=>String(x||"")).filter(Boolean):[],warnings:Array.isArray(parsed?.warnings)?parsed.warnings.map(x=>String(x||"")).filter(Boolean):[]};}
