import { WOLFRAM_QUERY_CACHE_MAX, WOLFRAM_QUERY_CACHE_TTL_MS, WOLFRAM_TERM_CACHE_MAX, WOLFRAM_TERM_CACHE_TTL_MS } from '../core/constants.js';
import { WOLFRAM_QUERY_CACHE_MEM, WOLFRAM_TERM_CACHE_MEM } from '../core/state.js';
import { structuredCloneSafe } from '../core/utils.js';
import { persistWolframCaches } from '../core/storage.js';
import { buildWolframEntityRef } from './wolfram-grounding.js';
import { toCanonicalKey } from '../domain/aliases.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Source: ruliad_expedition_v1.1.html
// Module: js/grounding/wolfram-cache.js

export function normalizeWolframCacheKey(query){return String(query||"").replace(/\s+/g," ").trim().toLowerCase();}

export function normalizeWolframTermCacheKey(raw){return String(raw||"").replace(/\s+/g," ").trim().toLowerCase();}

export function wolframCacheNow(){return Date.now();}

export function buildWolframTermCacheKey(term,target,discName){const label=toCanonicalKey(term?.label||"");const entity=toCanonicalKey(buildWolframEntityRef(term?.wolfram_entity)||"");const disc=toCanonicalKey(discName||"");const tgt=toCanonicalKey(target||"");return normalizeWolframTermCacheKey(`${label}|${entity}|${disc}|${tgt}`);}

export function enforceWolframCacheLimit(map,maxEntries){if(map.size<=maxEntries) return;const items=[...map.entries()].sort((a,b)=>Number(b[1]?.cachedAt||0)-Number(a[1]?.cachedAt||0));map.clear();for(const [key,val] of items.slice(0,maxEntries)){map.set(key,val);}}

export function pruneExpiredWolframCache(map,now=wolframCacheNow()){let removed=0;for(const [key,entry] of map.entries()){if(!entry||!Number.isFinite(Number(entry.expiresAt))||Number(entry.expiresAt)<=now){map.delete(key);removed++;}}return removed;}

export function getWolframQueryCache(query){const key=normalizeWolframCacheKey(query);if(!key) return null;const entry=WOLFRAM_QUERY_CACHE_MEM.get(key);if(!entry) return null;if(Number(entry.expiresAt)<=wolframCacheNow()){WOLFRAM_QUERY_CACHE_MEM.delete(key);persistWolframCaches();return null;}return structuredCloneSafe(entry.value);}

export function setWolframQueryCache(query,value){const key=normalizeWolframCacheKey(query);if(!key||!value) return;const now=wolframCacheNow();WOLFRAM_QUERY_CACHE_MEM.set(key,{cachedAt:now,expiresAt:now+WOLFRAM_QUERY_CACHE_TTL_MS,value:structuredCloneSafe(value)});enforceWolframCacheLimit(WOLFRAM_QUERY_CACHE_MEM,WOLFRAM_QUERY_CACHE_MAX);persistWolframCaches();}

export function getWolframTermCache(cacheKey){const key=normalizeWolframTermCacheKey(cacheKey);if(!key) return null;const entry=WOLFRAM_TERM_CACHE_MEM.get(key);if(!entry) return null;if(Number(entry.expiresAt)<=wolframCacheNow()){WOLFRAM_TERM_CACHE_MEM.delete(key);persistWolframCaches();return null;}return structuredCloneSafe(entry.value);}

export function setWolframTermCache(cacheKey,value){const key=normalizeWolframTermCacheKey(cacheKey);if(!key||!value) return;const now=wolframCacheNow();WOLFRAM_TERM_CACHE_MEM.set(key,{cachedAt:now,expiresAt:now+WOLFRAM_TERM_CACHE_TTL_MS,value:structuredCloneSafe(value)});enforceWolframCacheLimit(WOLFRAM_TERM_CACHE_MEM,WOLFRAM_TERM_CACHE_MAX);persistWolframCaches();}
