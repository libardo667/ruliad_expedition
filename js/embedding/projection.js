import { PROJECTION_BASE_SEED } from '../core/constants.js';
import { TERMS } from '../core/state.js';
import { RNG } from '../core/utils.js';
import { normalize3 } from './vector-math.js';
import { loadUMAPModule } from './umap-loader.js';
import { clamp01, fallbackDirection } from '../plot/plot-overlays.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Source: ruliad_expedition_v1.1.html
// Module: js/embedding/projection.js

export async function projectVectorsTo3D(vectors,seed=PROJECTION_BASE_SEED){if(vectors.length===0) return [];if(vectors.length===1) return [[0,0,0]];if(vectors.length===2) return [[-1,0,0],[1,0,0]];try{const {UMAP}=await loadUMAPModule();const rng=new RNG(seed>>>0);const nNeighbors=Math.max(2,Math.min(12,vectors.length-1));const umap=new UMAP({nComponents:3,nNeighbors,minDist:0.15,spread:1.1,random:()=>rng.next()});return umap.fit(vectors);}catch(err){console.warn("UMAP unavailable; using random projection fallback.",err);return randomProjection3D(vectors,seed);}}

export function randomProjection3D(vectors,seed=1337){const dims=vectors[0]?.length||0;const rng=new RNG(seed>>>0);const basis=[new Array(dims),new Array(dims),new Array(dims)];for(let axis=0;axis<3;axis++){let norm=0;for(let i=0;i<dims;i++){const val=(rng.next()*2)-1;basis[axis][i]=val;norm+=val*val;}norm=Math.sqrt(norm)||1;for(let i=0;i<dims;i++) basis[axis][i]/=norm;}return vectors.map(vec=>{const out=[0,0,0];for(let axis=0;axis<3;axis++){let acc=0;for(let i=0;i<dims;i++) acc+=vec[i]*basis[axis][i];out[axis]=acc;}return out;});}

export function normalizePointCloud(points,targetRadius=1.4){if(!points.length) return [];const mean=[0,0,0];for(const p of points){mean[0]+=Number(p[0]||0);mean[1]+=Number(p[1]||0);mean[2]+=Number(p[2]||0);}mean[0]/=points.length;mean[1]/=points.length;mean[2]/=points.length;const centered=points.map(p=>[Number(p[0]||0)-mean[0],Number(p[1]||0)-mean[1],Number(p[2]||0)-mean[2]]);let maxDist=0;for(const p of centered){maxDist=Math.max(maxDist,Math.hypot(p[0],p[1],p[2]));}const scale=maxDist>0?targetRadius/maxDist:1;const rng=new RNG(99);return centered.map(p=>[p[0]*scale+rng.jitter(0.02),p[1]*scale+rng.jitter(0.02),p[2]*scale+rng.jitter(0.02)]);}

export function applyFallbackPositions(){const rng=new RNG(42);for(const term of TERMS){if(term.type==="unique"){const id=term.slices[0]||0;const dir=fallbackDirection(id);const dist=1.3+(1-clamp01(term.centrality||0.5))*0.6;term.pos=[dir[0]*dist+rng.jitter(0.08),dir[1]*dist+rng.jitter(0.08),dir[2]*dist+rng.jitter(0.08)];continue;}if(term.type==="convergent"||term.type==="contradictory"){const ids=term.slices.length?term.slices:[0];const avg=[0,0,0];for(const id of ids){const dir=fallbackDirection(id);avg[0]+=dir[0];avg[1]+=dir[1];avg[2]+=dir[2];}const unit=normalize3(avg,fallbackDirection(ids[0]||0));const dist=term.type==="convergent"?0.8:0.95;term.pos=[unit[0]*dist+rng.jitter(0.06),unit[1]*dist+rng.jitter(0.06),unit[2]*dist+rng.jitter(0.06)];continue;}term.pos=[rng.jitter(0.10),rng.jitter(0.10),rng.jitter(0.10)];}}
