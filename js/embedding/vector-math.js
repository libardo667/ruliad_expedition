// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Module: js/embedding/vector-math.js

export function normalizeEmbeddingVector(vec){const norm=Math.hypot(...vec)||1;return vec.map(v=>v/norm);}

export function averageVector(vectors){if(!vectors.length) return null;const dims=vectors[0]?.length||0;if(!dims) return null;const out=new Array(dims).fill(0);for(const vec of vectors){for(let i=0;i<dims;i++){out[i]+=Number(vec?.[i]||0);}}for(let i=0;i<dims;i++){out[i]/=vectors.length;}return normalizeEmbeddingVector(out);}

export function cosineDistance(a,b){if(!Array.isArray(a)||!Array.isArray(b)||!a.length||!b.length) return null;const dims=Math.min(a.length,b.length);let dot=0,na=0,nb=0;for(let i=0;i<dims;i++){const av=Number(a[i]||0);const bv=Number(b[i]||0);dot+=av*bv;na+=av*av;nb+=bv*bv;}if(na<=0||nb<=0) return null;const cosine=Math.max(-1,Math.min(1,dot/(Math.sqrt(na)*Math.sqrt(nb))));return 1-cosine;}

export function averagePoint3(points){if(!points.length) return null;let x=0,y=0,z=0;for(const p of points){x+=Number(p?.[0]||0);y+=Number(p?.[1]||0);z+=Number(p?.[2]||0);}return [x/points.length,y/points.length,z/points.length];}

export function euclid3(a,b){if(!Array.isArray(a)||!Array.isArray(b)) return null;return Math.hypot((a[0]||0)-(b[0]||0),(a[1]||0)-(b[1]||0),(a[2]||0)-(b[2]||0));}

export function averageNumbers(values){const finite=values.filter(v=>Number.isFinite(v));if(!finite.length) return null;return finite.reduce((sum,v)=>sum+v,0)/finite.length;}

export function normalize3(vec,fallback=[1,0,0]){const len=Math.hypot(vec[0]||0,vec[1]||0,vec[2]||0);if(len<1e-6){const fLen=Math.hypot(fallback[0]||1,fallback[1]||0,fallback[2]||0)||1;return [fallback[0]/fLen,fallback[1]/fLen,fallback[2]/fLen];}return [(vec[0]||0)/len,(vec[1]||0)/len,(vec[2]||0)/len];}
