import { DISCS, DISC_SIM_MATRIX, PROJECTION_STABILITY, TERMS } from '../core/state.js';
import { escapeHtml } from '../core/utils.js';
import { buildEmbeddingText, callEmbeddings } from '../api/embeddings.js';
import { makeAbbr } from '../domain/terms.js';
import { averageNumbers, averagePoint3, averageVector, cosineDistance, euclid3, normalizeEmbeddingVector } from './vector-math.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Module: js/embedding/diagnostics.js

export function computeDiscCentroidsFromVectors(vectors){const centroids={};for(const disc of DISCS){const bucket=[];for(let i=0;i<TERMS.length;i++){if(TERMS[i]?.slices?.includes(disc.id)&&Array.isArray(vectors[i])) bucket.push(vectors[i]);}centroids[disc.id]=averageVector(bucket);}return centroids;}

export function computeDiscSimilarityMatrix(vectors){const centroids=computeDiscCentroidsFromVectors(vectors);const discIds=DISCS.map(d=>d.id);const labels=DISCS.map(d=>d.abbr||makeAbbr(d.name));const distances=discIds.map((leftId,row)=>discIds.map((rightId,col)=>row===col?0:cosineDistance(centroids[leftId],centroids[rightId])));return {discIds,labels,distances,generatedAt:new Date().toISOString()};}

export function computeDiscSimilarityMatrixForTerms(vectors,terms,discs){
  const safeTerms=Array.isArray(terms)?terms:[];
  const safeDiscs=(Array.isArray(discs)?discs:DISCS).filter(d=>d&&d.kind!=="ca");
  if(!safeDiscs.length) return null;
  const centroids={};
  for(const disc of safeDiscs){
    const bucket=[];
    for(let i=0;i<safeTerms.length;i++){
      if(safeTerms[i]?.slices?.includes(disc.id)&&Array.isArray(vectors[i])) bucket.push(vectors[i]);
    }
    centroids[disc.id]=averageVector(bucket);
  }
  const discIds=safeDiscs.map(d=>d.id);
  const labels=safeDiscs.map(d=>d.abbr||makeAbbr(d.name));
  const distances=discIds.map((leftId,row)=>discIds.map((rightId,col)=>row===col?0:cosineDistance(centroids[leftId],centroids[rightId])));
  return {discIds,labels,distances,generatedAt:new Date().toISOString()};
}

export async function computeRunDiscSimilarityMatrixForTerms(target,terms,cfg,discs){
  const safeTerms=Array.isArray(terms)?terms:[];
  if(safeTerms.length<2) return null;
  const embeddingInputs=safeTerms.map(term=>buildEmbeddingText(term,target));
  const vectors=await callEmbeddings(embeddingInputs,cfg);
  const normalizedVectors=vectors.map(normalizeEmbeddingVector);
  return computeDiscSimilarityMatrixForTerms(normalizedVectors,safeTerms,discs);
}

export function computeDiscCentroidsFromPoints(points){const centroids={};for(const disc of DISCS){const bucket=[];for(let i=0;i<TERMS.length;i++){if(TERMS[i]?.slices?.includes(disc.id)&&Array.isArray(points[i])) bucket.push(points[i]);}centroids[disc.id]=averagePoint3(bucket);}return centroids;}

export function buildDiscNeighborMap(centroids,k){const map={};for(const disc of DISCS){const here=centroids[disc.id];if(!here){map[disc.id]=[];continue;}const scores=[];for(const other of DISCS){if(other.id===disc.id) continue;const there=centroids[other.id];const dist=euclid3(here,there);if(dist===null) continue;scores.push({id:other.id,dist});}scores.sort((a,b)=>a.dist-b.dist);map[disc.id]=scores.slice(0,Math.min(k,scores.length)).map(item=>item.id);}return map;}

export function neighborOverlap(a,b){if(!Array.isArray(a)||!Array.isArray(b)||!a.length||!b.length) return null;const left=new Set(a);const right=new Set(b);let inter=0;for(const id of left){if(right.has(id)) inter++;}return inter/Math.max(left.size,right.size,1);}

export function computeProjectionStability(basePoints,reruns){if(!Array.isArray(basePoints)||!basePoints.length||DISCS.length<2){return {runs:1+reruns.length,score:null,label:"exploratory fog",perRun:[],generatedAt:new Date().toISOString()};}const neighborCount=Math.min(2,Math.max(1,DISCS.length-1));const baseNeighbors=buildDiscNeighborMap(computeDiscCentroidsFromPoints(basePoints),neighborCount);const perRun=[];for(const run of reruns){const runNeighbors=buildDiscNeighborMap(computeDiscCentroidsFromPoints(run.points||[]),neighborCount);const overlaps=[];for(const disc of DISCS){const overlap=neighborOverlap(baseNeighbors[disc.id]||[],runNeighbors[disc.id]||[]);if(overlap!==null) overlaps.push(overlap);}perRun.push({seed:run.seed,overlap:averageNumbers(overlaps)});}const score=averageNumbers(perRun.map(item=>item.overlap));const label=score===null?"exploratory fog":score>=0.75?"stable":score>=0.45?"mixed":"exploratory fog";return {runs:1+reruns.length,neighborCount,score,label,perRun,generatedAt:new Date().toISOString()};}

export function renderEmbeddingDiagnostics(){const statusEl=document.getElementById("disc-sim-status");const matrixEl=document.getElementById("disc-sim-matrix");const stabEl=document.getElementById("projection-stability");if(!statusEl||!matrixEl||!stabEl) return;if(!DISC_SIM_MATRIX?.distances?.length){statusEl.textContent="No embedding diagnostics yet.";stabEl.textContent="";matrixEl.innerHTML="";return;}statusEl.textContent="Disc similarity matrix (cosine distance in original embedding space; rotation-invariant). Lower is closer.";const labels=DISC_SIM_MATRIX.labels||DISCS.map(d=>d.abbr);const rows=DISC_SIM_MATRIX.distances.map((row,rowIdx)=>`<tr><th>${escapeHtml(labels[rowIdx]||`D${rowIdx+1}`)}</th>${row.map(cell=>{if(cell===null||cell===undefined||Number.isNaN(cell)) return "<td>-</td>";return `<td>${Number(cell).toFixed(2)}</td>`;}).join("")}</tr>`).join("");matrixEl.innerHTML=`<table class="matrix-table"><thead><tr><th></th>${labels.map(label=>`<th>${escapeHtml(label)}</th>`).join("")}</tr></thead><tbody>${rows}</tbody></table>`;if(!PROJECTION_STABILITY){stabEl.textContent="Projection stability check unavailable.";return;}const scorePct=Number.isFinite(PROJECTION_STABILITY.score)?`${(PROJECTION_STABILITY.score*100).toFixed(1)}%`:"n/a";const runs=Array.isArray(PROJECTION_STABILITY.perRun)?PROJECTION_STABILITY.perRun:[];const runBits=runs.length?` | reruns: ${runs.map(r=>`seed ${r.seed}: ${Number.isFinite(r.overlap)?(r.overlap*100).toFixed(0)+"%":"n/a"}`).join(", ")}`:"";stabEl.textContent=`Projection stability: ${PROJECTION_STABILITY.label} (${scorePct} neighborhood overlap).${runBits}`;}
