import { callLLMJSON, getQualityProfile } from '../api/llm.js';
import { extractJSON, extractJSONLenient, extractLooseJsonFieldValues, repairJSONWithModel, stripJsonCodeFences } from '../api/json-recovery.js';
import { inferDescriptionSourceFromLayers, normalizeTermDescriptions } from '../domain/terms.js';
import { normalizeCitation } from '../domain/citations.js';
import { clamp01 } from '../plot/plot-overlays.js';
import { buildProbeCompactFallbackPrompt } from '../prompt/prompt-builders.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Source: ruliad_expedition_v1.1.html
// Module: js/pipeline/probes.js

export function buildProbeRescueResult({target,discName,rawTexts=[],parseAttempts=[]}={}){const allRaw=(Array.isArray(rawTexts)?rawTexts:[rawTexts]).map(x=>String(x||"")).filter(Boolean);const merged=allRaw.join("\n\n");const cleaned=stripJsonCodeFences(merged).replace(/```+/g," ").replace(/\s+/g," ").trim();const summaryPrefix=`Fallback parse recovery for ${String(discName||"this probe").trim()}`;const summaryBody=cleaned?`${cleaned.slice(0,260)}${cleaned.length>260?"...":""}`:"model output was not valid JSON after retries";const labels=extractLooseJsonFieldValues(merged,"label",10).filter(x=>x.length>=2&&x.length<=120);const descriptions=extractLooseJsonFieldValues(merged,"description",12);const claims=extractLooseJsonFieldValues(merged,"claim",6);const targetLabel=String(target||"Topic").trim()||"Topic";const discLabel=String(discName||"Lens").trim()||"Lens";const defaultLabels=[`${targetLabel} framing`,`${discLabel} constraints`,`${discLabel} dynamics`,`${discLabel} trade-offs`,`${discLabel} risk surface`,`${discLabel} adaptation pathways`].map(x=>x.replace(/\s+/g," ").trim());const chosenLabels=[...new Set([...(labels.length?labels:[]),...defaultLabels])].slice(0,8);const terms=chosenLabels.map((label,idx)=>({label,centrality:Math.max(0.42,0.86-idx*0.06),description:descriptions[idx]||`Recovered fallback term from ${discLabel} parse failure; verify manually.`}));const claimLines=(claims.length?claims:[`Parser fallback used for ${discLabel}; validate this lens manually.`]).slice(0,4);const confidenceNotes=`Structured JSON parse failed across retries. ${parseAttempts.slice(0,4).join(" | ")||"No parse diagnostics captured."}`;return normalizeProbeResult({summary:`${summaryPrefix}: ${summaryBody}`,terms,claims_or_findings:claimLines,citations:[],confidence_notes:confidenceNotes});}

export async function getProbeResultWithRecovery({target,discName,probeSystem,userMsg,cfg}){const parseAttempts=[];const rawSamples=[];const parseTry=(label,text)=>{try{return extractJSON(text);}catch(err1){try{return extractJSONLenient(text);}catch(err2){parseAttempts.push(`${label}: ${err1.message||err1}; lenient: ${err2.message||err2}`);return null;}}};const raw1=await callLLMJSON(probeSystem,userMsg,cfg);rawSamples.push(raw1);const parsed1=parseTry("initial",raw1);if(parsed1) return normalizeProbeResult(parsed1);try{const repaired=await repairJSONWithModel(raw1,`Probe ${discName} on ${target}`,cfg);rawSamples.push(repaired);const parsedRepair=parseTry("repair",repaired);if(parsedRepair) return normalizeProbeResult(parsedRepair);}catch(err){parseAttempts.push(`repair call failed: ${err.message||err}`);}const retryCfg={...cfg,__tempOverride:Math.max(0,Number(getQualityProfile(cfg.qualityMode).temperature||0.15)-0.08)};const raw2=await callLLMJSON(probeSystem,userMsg,retryCfg);rawSamples.push(raw2);const parsed2=parseTry("retry",raw2);if(parsed2) return normalizeProbeResult(parsed2);try{const repaired2=await repairJSONWithModel(raw2,`Probe retry ${discName} on ${target}`,cfg);rawSamples.push(repaired2);const parsedRepair2=parseTry("retry-repair",repaired2);if(parsedRepair2) return normalizeProbeResult(parsedRepair2);}catch(err){parseAttempts.push(`retry-repair call failed: ${err.message||err}`);}try{const fallbackPrompt=buildProbeCompactFallbackPrompt(target,discName);const fallbackRaw=await callLLMJSON("You are a research expert. Return strict valid JSON only.",fallbackPrompt,{...cfg,__tempOverride:0,maxTokens:Math.min(getQualityProfile(cfg.qualityMode).maxTokens,1200)});rawSamples.push(fallbackRaw);const parsedFallback=parseTry("compact-fallback",fallbackRaw);if(parsedFallback){const norm=normalizeProbeResult(parsedFallback);if(norm.summary&&norm.terms?.length) return norm;}}catch(err){parseAttempts.push(`compact-fallback call failed: ${err.message||err}`);}const rescue=buildProbeRescueResult({target,discName,rawTexts:rawSamples,parseAttempts});console.warn(`Probe ${discName} JSON parse failed; using fallback recovery.`,parseAttempts);return rescue;}

export function normalizeProbeTerm(item){
  const label=String(item?.label||"").trim();
  if(!label) return null;
  const description=String(item?.description||"").trim();
  const source=String(item?.description_source||"").trim().toLowerCase()||"llm";
  const descriptions=normalizeTermDescriptions(item?.descriptions,{fallbackDescription:description,fallbackSource:source,label});
  const centrality=clamp01(Number(item?.centrality??0.5));
  return {
    label,
    centrality,
    descriptions,
    description:String(descriptions.displayDescription||description).trim(),
    description_source:inferDescriptionSourceFromLayers(descriptions,source),
    description_provenance:[{source:source||"llm",stage:"probe",note:"Original probe model description"}]
  };
}

export function normalizeProbeResult(parsed){return {summary:String(parsed?.summary||"").trim(),terms:Array.isArray(parsed?.terms)?parsed.terms.map(normalizeProbeTerm).filter(Boolean):[],claims_or_findings:Array.isArray(parsed?.claims_or_findings)?parsed.claims_or_findings.map(t=>String(t||"").trim()).filter(Boolean):[],citations:Array.isArray(parsed?.citations)?parsed.citations.map(normalizeCitation).filter(c=>c.url||c.title||c.publisher||c.quote_or_snippet):[],confidence_notes:String(parsed?.confidence_notes||"").trim()};}
