import { DISCS } from '../core/state.js';
import { clampInt } from '../core/utils.js';
import { callLLMJSON, getQualityProfile } from '../api/llm.js';
import { extractJSON, extractJSONLenient } from '../api/json-recovery.js';
import { toCanonicalKey } from '../domain/aliases.js';
import { resolvePromptBundleWithOverrides } from '../prompt/prompt-system.js';
import { buildProbeSystemPrompt, buildSynthesisPrompt } from '../prompt/prompt-builders.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Module: js/pipeline/synthesis.js

export function parseSynthesisRangeMin(spec,fallback=1){const m=String(spec||"").match(/(\d+)/);return m?clampInt(Number(m[1]),0,12):fallback;}

export function disciplineIndexFromValue(value){if(Number.isInteger(value)&&value>=0&&value<DISCS.length) return value;const numeric=Number.parseInt(String(value||"").trim(),10);if(Number.isInteger(numeric)&&numeric>=0&&numeric<DISCS.length) return numeric;const key=toCanonicalKey(String(value||""));if(!key) return null;for(const d of DISCS){const nameKey=toCanonicalKey(d?.name||"");const abbrKey=toCanonicalKey(d?.abbr||"");if(key===nameKey||key===abbrKey) return d.id;if(nameKey&&key.includes(nameKey)) return d.id;}const probeMatch=String(value||"").match(/probe\s*(\d+)/i);if(probeMatch){const idx=Math.max(1,Number(probeMatch[1]))-1;if(idx>=0&&idx<DISCS.length) return idx;}return null;}

export function coerceSynthesisDisciplines(value){const arr=Array.isArray(value)?value:[value];const ids=[];for(const item of arr){const idx=disciplineIndexFromValue(item);if(Number.isInteger(idx)&&idx>=0&&idx<DISCS.length&&!ids.includes(idx)) ids.push(idx);}return ids;}

export function normalizeSynthesisEntry(item,type,index,target){const raw=(item&&typeof item==="object")?item:{};const labelSource=typeof item==="string"?item:String(raw.label||raw.title||raw.name||"").trim();const label=String(labelSource||"").trim()||`${type}_${index+1}`;const description=String(raw.description||raw.rationale||raw.reason||raw.explanation||"").trim();if(type==="emergent"){return {label,description:description||`Cross-probe synthesis around ${target}.`};}const disciplines=coerceSynthesisDisciplines(raw.disciplines||raw.discipline||raw.probes||raw.probe_ids||raw.discIds||[]);return {label,description:description||`${type} relationship synthesized across probe outputs.`,disciplines};}

export function buildTermCoverageByDiscipline(probeResults){const coverage=new Map();for(const row of (Array.isArray(probeResults)?probeResults:[])){const discId=Number(row?.discId);if(!Number.isInteger(discId)||discId<0||discId>=DISCS.length) continue;for(const term of (row?.terms||[])){const label=String(term?.label||"").trim();if(!label) continue;const key=toCanonicalKey(label)||label.toLowerCase();if(!coverage.has(key)) coverage.set(key,{label,discIds:new Set()});coverage.get(key).discIds.add(discId);}}return coverage;}

export function jaccardFromSets(a,b){const left=a instanceof Set?a:new Set();const right=b instanceof Set?b:new Set();if(!left.size&&!right.size) return 1;let inter=0;for(const v of left){if(right.has(v)) inter++;}const union=left.size+right.size-inter;return union>0?inter/union:0;}

export function buildFallbackSynthesisResult({target,probeResults,quality,existing={convergent:[],contradictory:[],emergent:[]}}={}){const minConv=parseSynthesisRangeMin(quality?.synthConvergent,2);const minContr=parseSynthesisRangeMin(quality?.synthContradictory,1);const minEmerg=parseSynthesisRangeMin(quality?.synthEmergent,1);const out={convergent:[...(existing?.convergent||[])],contradictory:[...(existing?.contradictory||[])],emergent:[...(existing?.emergent||[])]};const seenConv=new Set(out.convergent.map(x=>toCanonicalKey(x?.label||"")).filter(Boolean));const seenContr=new Set(out.contradictory.map(x=>toCanonicalKey(x?.label||"")).filter(Boolean));const seenEmerg=new Set(out.emergent.map(x=>toCanonicalKey(x?.label||"")).filter(Boolean));const coverage=buildTermCoverageByDiscipline(probeResults);const convergentCandidates=[...coverage.values()].filter(x=>x.discIds.size>=2).sort((a,b)=>b.discIds.size-a.discIds.size||String(a.label).localeCompare(String(b.label)));for(const cand of convergentCandidates){if(out.convergent.length>=minConv) break;const key=toCanonicalKey(cand.label||"");if(key&&seenConv.has(key)) continue;out.convergent.push({label:cand.label,disciplines:[...cand.discIds].sort((a,b)=>a-b),description:`Observed across ${cand.discIds.size} probes.`});if(key) seenConv.add(key);}if(out.contradictory.length<minContr){const discTermSets=new Map();for(const row of (probeResults||[])){const discId=Number(row?.discId);if(!Number.isInteger(discId)||discId<0||discId>=DISCS.length) continue;const set=new Set((row?.terms||[]).map(t=>toCanonicalKey(String(t?.label||""))).filter(Boolean));discTermSets.set(discId,set);}const pairs=[];for(let i=0;i<DISCS.length;i++){for(let j=i+1;j<DISCS.length;j++){const setA=discTermSets.get(i)||new Set();const setB=discTermSets.get(j)||new Set();if(!setA.size&&!setB.size) continue;const overlap=jaccardFromSets(setA,setB);pairs.push({i,j,overlap});}}pairs.sort((a,b)=>a.overlap-b.overlap);for(const pair of pairs){if(out.contradictory.length>=minContr) break;const discA=DISCS[pair.i]?.name||`Probe ${pair.i+1}`;const discB=DISCS[pair.j]?.name||`Probe ${pair.j+1}`;const label=`${discA} vs ${discB} framing tension`;const key=toCanonicalKey(label);if(key&&seenContr.has(key)) continue;out.contradictory.push({label,disciplines:[pair.i,pair.j],description:`Low term-overlap (${(pair.overlap*100).toFixed(0)}%) suggests differing priors or mechanisms.`});if(key) seenContr.add(key);}}if(out.emergent.length<minEmerg){const convLabels=out.convergent.map(x=>String(x?.label||"").trim()).filter(Boolean);const contrLabel=String(out.contradictory[0]?.label||"").trim();while(out.emergent.length<minEmerg){const idx=out.emergent.length+1;const label=idx===1&&convLabels.length>=2?`${convLabels[0]} x ${convLabels[1]} integration`:`${String(target||"Topic").trim()||"Topic"} synthesis pattern ${idx}`;const desc=idx===1?`Emerges by reconciling convergent motifs with tensions${contrLabel?` (e.g., ${contrLabel})`:""}.`:`Cross-lens synthesis candidate inferred from probe-level structure.`;const key=toCanonicalKey(label);if(key&&seenEmerg.has(key)){break;}out.emergent.push({label,description:desc});if(key) seenEmerg.add(key);}}return out;}

export function normalizeSynthesisResult(raw,target,probeResults,quality){const base=raw&&typeof raw==="object"?raw:{};const convRaw=Array.isArray(base.convergent)?base.convergent:[];const contrRaw=Array.isArray(base.contradictory)?base.contradictory:[];const emergRaw=Array.isArray(base.emergent)?base.emergent:[];const convergent=convRaw.map((item,idx)=>normalizeSynthesisEntry(item,"convergent",idx,target)).filter(item=>item.label&&Array.isArray(item.disciplines)&&item.disciplines.length>0);const contradictory=contrRaw.map((item,idx)=>normalizeSynthesisEntry(item,"contradictory",idx,target)).filter(item=>item.label&&Array.isArray(item.disciplines)&&item.disciplines.length>0);const emergent=emergRaw.map((item,idx)=>normalizeSynthesisEntry(item,"emergent",idx,target)).filter(item=>item.label);const fallbacked=buildFallbackSynthesisResult({target,probeResults,quality,existing:{convergent,contradictory,emergent}});return {convergent:fallbacked.convergent,contradictory:fallbacked.contradictory,emergent:fallbacked.emergent};}

export async function repairSynthesisJSONWithModel(rawText,contextLabel,cfg){const repairSystem="You repair malformed JSON. Return only valid JSON.";const repairPrompt=`Task context: ${contextLabel}\n\nRepair the malformed JSON below. Preserve meaning and fields. Do not add markdown.\nReturn strict JSON only.\nExpected top-level object keys: convergent, contradictory, emergent.\n\nMalformed text:\n${String(rawText||"").slice(0,24000)}`;return callLLMJSON(repairSystem,repairPrompt,{...cfg,__tempOverride:0,__maxTokens:Math.max(900,Math.floor(getQualityProfile(cfg.qualityMode).maxTokens*0.9))});}

export function buildSynthesisCompactFallbackPrompt(target,probeResults,quality){const allTerms=probeResults.map(r=>`${DISCS[r.discId]?.name||`Probe ${r.discId+1}`}: ${(r.terms||[]).slice(0,10).map(t=>String(t?.label||"").trim()).filter(Boolean).join(", ")}`).join("\n");return `Topic: "${target}"\n\nProbe term snapshots:\n${allTerms}\n\nReturn strict JSON only:\n{\n  "convergent":[{"label":"","disciplines":[0,1],"description":""}],\n  "contradictory":[{"label":"","disciplines":[0,2],"description":""}],\n  "emergent":[{"label":"","description":""}]\n}\n\nRules:\n- Include at least ${parseSynthesisRangeMin(quality?.synthConvergent,2)} convergent items\n- Include at least ${parseSynthesisRangeMin(quality?.synthContradictory,1)} contradictory items\n- Include at least ${parseSynthesisRangeMin(quality?.synthEmergent,1)} emergent items\n- disciplines must be integer probe indices\n- no markdown`; }

export async function getSynthesisResultWithRecovery(target,probeResults,quality,cfg,{contextLabel="synthesis"}={}){const parseAttempts=[];const rawSamples=[];const parseTry=(label,text)=>{try{return extractJSON(text);}catch(err1){try{return extractJSONLenient(text);}catch(err2){parseAttempts.push(`${label}: ${err1.message||err1}; lenient: ${err2.message||err2}`);return null;}}};const synthDefaults={systemPrompt:buildProbeSystemPrompt(cfg),userPrompt:buildSynthesisPrompt(target,probeResults,quality,cfg)};const synthBundle=resolvePromptBundleWithOverrides("synthesis",{target,cfg,quality,defaults:synthDefaults});const synthMsg=synthBundle.userPrompt;const probeSystem=synthBundle.systemPrompt||synthDefaults.systemPrompt;try{const raw=await callLLMJSON(probeSystem,synthMsg,cfg);rawSamples.push(raw);const parsed=parseTry("initial",raw);if(parsed) return normalizeSynthesisResult(parsed,target,probeResults,quality);}catch(err){parseAttempts.push(`initial call failed: ${err.message||err}`);}try{const rawForRepair=rawSamples.length?rawSamples[rawSamples.length-1]:synthMsg;const repairedRaw=await repairSynthesisJSONWithModel(rawForRepair,`${contextLabel} repair`,cfg);rawSamples.push(repairedRaw);const parsed=parseTry("repair",repairedRaw);if(parsed) return normalizeSynthesisResult(parsed,target,probeResults,quality);}catch(err){parseAttempts.push(`repair call failed: ${err.message||err}`);}try{const retryCfg={...cfg,__tempOverride:Math.max(0,Number(getQualityProfile(cfg.qualityMode).temperature||0.2)-0.08)};const raw=await callLLMJSON(probeSystem,synthMsg,retryCfg);rawSamples.push(raw);const parsed=parseTry("retry",raw);if(parsed) return normalizeSynthesisResult(parsed,target,probeResults,quality);}catch(err){parseAttempts.push(`retry call failed: ${err.message||err}`);}try{const retryRawForRepair=rawSamples.length?rawSamples[rawSamples.length-1]:synthMsg;const repairedRetryRaw=await repairSynthesisJSONWithModel(retryRawForRepair,`${contextLabel} retry-repair`,cfg);rawSamples.push(repairedRetryRaw);const parsed=parseTry("retry-repair",repairedRetryRaw);if(parsed) return normalizeSynthesisResult(parsed,target,probeResults,quality);}catch(err){parseAttempts.push(`retry-repair call failed: ${err.message||err}`);}try{const compactPrompt=buildSynthesisCompactFallbackPrompt(target,probeResults,quality);const raw=await callLLMJSON("You synthesize cross-probe structures. Return strict JSON only.",compactPrompt,{...cfg,__tempOverride:0,__maxTokens:Math.min(Math.max(getQualityProfile(cfg.qualityMode).maxTokens,1500),3000)});rawSamples.push(raw);const parsed=parseTry("compact-fallback",raw);if(parsed) return normalizeSynthesisResult(parsed,target,probeResults,quality);}catch(err){parseAttempts.push(`compact-fallback call failed: ${err.message||err}`);}console.warn(`Synthesis recovery fallback applied (${contextLabel}).`,parseAttempts);return normalizeSynthesisResult({},target,probeResults,quality);}
