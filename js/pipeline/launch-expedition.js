import { COLORS, PROJECTION_BASE_SEED, PROJECTION_STABILITY_RUNS } from '../core/constants.js';
import { ACTIVE_ARTIFACT_KEY, CALL_LOGS, CA_PROBE_OUTPUT, CITATIONS, CITATION_UNMAPPED_SUPPORTING_TERMS, CURRENT_RUN_ID, DISCS, DISC_SIM_MATRIX, EVIDENCE_FILTER_STATE, LAST_RUN, MODE_STATE, PROJECTION_STABILITY, RUN_STATE, SEMANTIC_EDGES, TERMS, activeSetupMode, activeSlices, activeTypes, isGenerating, lastClaimsText, lastCritiqueText, lastMarkdownText, lastOutlineText, lastReportText, plotInited, sessionConfig, setActiveArtifactKey, setCallLogs, setCAProbeOutput, setCitations, setCitationUnmappedSupportingTerms, setCurrentRunId, setDiscs, setDiscSimMatrix, setEvidenceFilterState, setIsGenerating, setLastRun, setProjectionStability, setRunState, setSemanticEdges, setSessionConfig, setTerms, setActiveSlices, setActiveTypes, setLastClaimsText, setLastCritiqueText, setLastMarkdownText, setLastOutlineText, setLastReportText, setPlotInited } from '../core/state.js';
import { progressEl } from '../core/refs.js';
import { clampInt } from '../core/utils.js';
import { setProbeState, showToast } from '../ui/notifications.js';
import { switchMainTab } from '../ui/tabs.js';
import { getCurrentProbeSpecs, renderDisciplineInputs } from '../ui/setup-panel.js';
import { closeModal } from '../ui/modals.js';
import { setArtifactDrawer, setExportMenu } from '../ui/artifact-drawer-ui.js';
import { getProbeResultWithRecovery } from './probes.js';
import { getSynthesisResultWithRecovery, normalizeSynthesisResult } from './synthesis.js';
import { normalizeMode } from '../api/provider.js';
import { getQualityProfile, readApiConfig, validateApiConfig } from '../api/llm.js';
import { buildEmbeddingText, callEmbeddings } from '../api/embeddings.js';
import { buildTerms, makeAbbr } from '../domain/terms.js';
import { saveRunToHistory } from '../io/run-history.js';
import { collectCitations } from '../domain/citations.js';
import { applySecondPassCleanup, buildRunSnapshot, computeRunId, safeConfigForRun } from '../domain/run-metadata.js';
import { appendDerivedCATermsToTerms, buildCATermsFromMetrics, deriveCAFromRun } from '../ca/derive-ca.js';
import { renderCAPanel } from '../ca/render-ca-panel.js';
import { normalizeEmbeddingVector } from '../embedding/vector-math.js';
import { applyFallbackPositions, normalizePointCloud, projectVectorsTo3D } from '../embedding/projection.js';
import { computeDiscSimilarityMatrix, computeProjectionStability, renderEmbeddingDiagnostics } from '../embedding/diagnostics.js';
import { extractSemanticEdges } from '../embedding/semantic-edges.js';
import { refinePositionsWithEdges } from '../embedding/force-layout.js';
import { showViz } from '../plot/plot-render.js';
import { clearNodeFilters, renderNodeFilterResults } from '../plot/sidebar.js';
import { disposeGallery } from '../plot/gallery.js';
import { initArtifactStore, syncArtifactStoreFromRun } from '../artifacts/artifact-store.js';
import { runRedTeamPass } from '../artifacts/artifact-generators.js';
import { resolvePromptBundleWithOverrides } from '../prompt/prompt-system.js';
import { buildProbeSystemPrompt, buildProbeUserPrompt, buildRedTeamPrompt, buildSynthesisPrompt } from '../prompt/prompt-builders.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Module: js/pipeline/launch-expedition.js

export async function launchExpedition(){
  const target=document.getElementById("target-input").value.trim();
  if(!target){showToast("Please enter a target concept.");return;}
  const cfg=readApiConfig();
  const quality=getQualityProfile(cfg.qualityMode);
  const cfgError=validateApiConfig(cfg);
  if(cfgError){showToast(cfgError);return;}
  if(normalizeMode(cfg)==="direct"&&location.protocol==="file:"){showToast("Tip: if auth fails in direct mode, serve this file from localhost instead of file://.");}
  setSessionConfig(cfg);
  setCallLogs([]);
  setCitations([]);
  setDiscSimMatrix(null);
  setProjectionStability(null);
  setCAProbeOutput(null);
  initArtifactStore();
  const discInputEls=Array.from(document.querySelectorAll(".disc-input")).filter(el=>el.value.trim());
  const discNames=discInputEls.map(el=>el.value.trim());
  if(discNames.length<2){showToast("Please fill in at least 2 disciplines.");return;}
  const discSpecs=discInputEls.map(el=>({name:el.value.trim(),color:el.dataset.color||"",kind:"llm"}));
  const probeSystemDefault=buildProbeSystemPrompt(cfg);
  const probeSystemBundle=resolvePromptBundleWithOverrides("probe_system",{target,cfg,quality,defaults:{systemPrompt:probeSystemDefault,userPrompt:""}});
  const probeSystem=probeSystemBundle.systemPrompt||probeSystemDefault;
  const probeTemplateDefaults={systemPrompt:probeSystem,userPrompt:buildProbeUserPrompt(target,"__DISCIPLINE__",quality,cfg)};
  const probeTemplateBundle=resolvePromptBundleWithOverrides("probe_user",{discName:"__DISCIPLINE__",target,cfg,quality,defaults:probeTemplateDefaults});
  const synthesisDefaults={systemPrompt:buildProbeSystemPrompt(cfg),userPrompt:buildSynthesisPrompt(target,[],quality,cfg)};
  const synthesisBundle=resolvePromptBundleWithOverrides("synthesis",{target,cfg,quality,defaults:synthesisDefaults});
  const redTeamDefaults={systemPrompt:"You are a skeptical reviewer.",userPrompt:buildRedTeamPrompt(target,[],{contradictory:[],emergent:[]},cfg)};
  const redTeamBundle=resolvePromptBundleWithOverrides("artifact_red_team",{target,cfg,quality,defaults:redTeamDefaults});
  const runFingerprint={target,probes:discSpecs.map(x=>x.name),config:safeConfigForRun(cfg),prompts:{probeSystem,probeUserTemplate:probeTemplateBundle.userPrompt,synthTemplate:synthesisBundle.userPrompt,redTeamTemplate:redTeamBundle.userPrompt}};
  setCurrentRunId(computeRunId(runFingerprint));
  setRunState({runId:CURRENT_RUN_ID,target,config:cfg,probeResults:[],synthResult:{convergent:[],contradictory:[],emergent:[]},generatedAt:new Date().toISOString(),caProbe:null});
  setDiscs(discSpecs.map((spec,i)=>({id:i,name:spec.name,abbr:makeAbbr(spec.name),col:spec.color||COLORS[i%COLORS.length],kind:spec.kind})));
  setIsGenerating(true);
  switchMainTab("plot",{silent:true});
  const prog=progressEl;
  prog.style.display="flex";
  const sourceLabel=cfg.sourceUrls?.length?` | SOURCES: ${cfg.sourceUrls.length} URL(s)`:"";
  document.getElementById("prog-target-label").textContent=`TARGET: ${target.toUpperCase()} | CHAT MODEL: ${cfg.researchModel} | EMBED MODEL: ${cfg.embeddingModel} | QUALITY: ${quality.id.toUpperCase()} | WEB: ${cfg.webSearch?"ON":"OFF"} | CA: ${cfg.enableComputationalIrreducibility?"ON":"OFF"}${sourceLabel}`;
  const probeListEl=document.getElementById("probe-list");
  probeListEl.innerHTML="";
  for(const d of DISCS){const el=document.createElement("div");el.className="probe-item";el.innerHTML=`<div class="probe-dot idle" id="dot-${d.id}"></div><span class="probe-name" style="color:${d.col}">${d.name}</span><span class="probe-status" id="status-${d.id}">QUEUED</span>`;probeListEl.appendChild(el);}
  const probePromises=DISCS.map(async(d)=>{
    setProbeState(d.id,"running","RESEARCHING...");
    try{
      const discSourceText=cfg.sourceByDisc?.[d.name]||cfg.sourceText||"";
      const discCfg=discSourceText!==cfg.sourceText?{...cfg,sourceText:discSourceText}:cfg;
      const probeDefaults={systemPrompt:probeSystem,userPrompt:buildProbeUserPrompt(target,d.name,quality,discCfg)};
      const probeBundle=resolvePromptBundleWithOverrides("probe_user",{discName:d.name,target,cfg:discCfg,quality,defaults:probeDefaults});
      const norm=await getProbeResultWithRecovery({target,discName:d.name,probeSystem:probeBundle.systemPrompt||probeSystem,userMsg:probeBundle.userPrompt,cfg:discCfg});
      setProbeState(d.id,"done",`${norm.terms?.length||0} TERMS`);
      return {discId:d.id,summary:norm.summary,terms:Array.isArray(norm.terms)?norm.terms:[],claims_or_findings:norm.claims_or_findings,citations:norm.citations,confidence_notes:norm.confidence_notes};
    }catch(err){
      setProbeState(d.id,"error","ERROR");
      console.error(`Probe ${d.name} failed:`,err);
      return {discId:d.id,summary:"",terms:[],claims_or_findings:[],citations:[],confidence_notes:""};
    }
  });
  const probeResults=await Promise.all(probePromises);
  RUN_STATE.probeResults=probeResults;
  RUN_STATE.caProbe=null;
  const synthBar=document.getElementById("synth-bar");
  synthBar.className="synth-bar running";
  synthBar.textContent="SYNTHESIS - identifying convergences, contradictions, emergent features...";
  let synthResult={convergent:[],contradictory:[],emergent:[]};
  try{
    synthResult=await getSynthesisResultWithRecovery(target,probeResults,quality,cfg,{contextLabel:"launch"});
    synthBar.className="synth-bar done";
    synthBar.textContent=`SYNTHESIS COMPLETE - ${synthResult.convergent?.length||0} convergent | ${synthResult.contradictory?.length||0} contradictions | ${synthResult.emergent?.length||0} emergent`;
  }catch(err){
    synthBar.className="synth-bar error";
    synthBar.textContent="SYNTHESIS ERROR - proceeding with fallback synthesis";
    console.error("Synthesis failed:",err);
    synthResult=normalizeSynthesisResult({},target,probeResults,quality);
  }
  RUN_STATE.synthResult=synthResult;
  if(quality.cleanup){
    synthBar.className="synth-bar running";
    synthBar.textContent="TERM CLEANUP - resolving near-duplicate wording...";
    try{await applySecondPassCleanup(target,probeResults,synthResult,cfg);synthBar.textContent="TERM CLEANUP COMPLETE";}
    catch(err){console.warn("Cleanup pass failed:",err);synthBar.textContent="TERM CLEANUP SKIPPED - using first pass terms";}
  }
  buildTerms(probeResults,synthResult);
  collectCitations();
  if(TERMS.length){
    synthBar.className="synth-bar running";
    try{
      await assignSemanticPositions(target,cfg,msg=>{synthBar.textContent=msg;});
      synthBar.className="synth-bar done";
      synthBar.textContent=`VECTOR LAYOUT COMPLETE - ${TERMS.length} terms positioned by semantic distance`;
    }catch(err){
      console.error("Embedding layout failed:",err);
      applyFallbackPositions();
      setDiscSimMatrix(null);
      setProjectionStability(null);
      synthBar.className="synth-bar error";
      synthBar.textContent="VECTOR LAYOUT ERROR - using fallback geometry";
      showToast("Embedding layout failed. Fallback geometry was applied.");
    }
  }else{
    applyFallbackPositions();
    setDiscSimMatrix(null);
    setProjectionStability(null);
  }
  setSemanticEdges(null);
  if(TERMS.length>=4){
    synthBar.className="synth-bar running";
    synthBar.textContent="SEMANTIC EDGES - analyzing relationships between terms...";
    try{
      const edgeResult=await extractSemanticEdges(target,cfg,quality);
      if(edgeResult&&edgeResult.relationships.length>0){
        setSemanticEdges(edgeResult);
        if(quality.id==="rigor"){
          synthBar.textContent="SEMANTIC EDGES - refining positions with force layout...";
          const termIndex=new Map();
          for(let i=0;i<TERMS.length;i++) termIndex.set(TERMS[i].label.toLowerCase().trim(),i);
          const currentPositions=TERMS.map(t=>[...t.pos]);
          const refined=refinePositionsWithEdges(currentPositions,edgeResult.relationships,termIndex);
          for(let i=0;i<TERMS.length;i++) TERMS[i].pos=refined[i]||TERMS[i].pos;
        }
        synthBar.className="synth-bar done";
        synthBar.textContent=`SEMANTIC EDGES COMPLETE - ${edgeResult.relationships.length} relationships identified`;
      }else{
        synthBar.className="synth-bar done";
        synthBar.textContent="SEMANTIC EDGES - no relationships extracted";
      }
    }catch(err){
      console.warn("Semantic edge extraction failed:",err);
      setSemanticEdges(null);
      synthBar.className="synth-bar error";
      synthBar.textContent="SEMANTIC EDGES SKIPPED - proceeding without relationship graph";
    }
  }
  if(cfg.enableComputationalIrreducibility){
    synthBar.className="synth-bar running";
    synthBar.textContent="COMPUTATIONAL IRREDUCIBILITY - deriving CA from run topology...";
    try{
      const caResult=await deriveCAFromRun(target,cfg,probeResults,synthResult,{
        discSimilarityMatrix:DISC_SIM_MATRIX,
        projectionStability:PROJECTION_STABILITY
      });
      setCAProbeOutput(caResult);
      appendDerivedCATermsToTerms(buildCATermsFromMetrics(caResult));
      RUN_STATE.caProbe=caResult;
      const densityPct=(Number((caResult?.metrics?.densityFinal??caResult?.metrics?.density)||0)*100).toFixed(1);
      const volatilityPct=(Number((caResult?.metrics?.volatilityFinal??caResult?.metrics?.volatility)||0)*100).toFixed(1);
      synthBar.className="synth-bar done";
      synthBar.textContent=`CA DIAGNOSTIC COMPLETE - Rule ${caResult?.rule??"n/a"} | ${densityPct}% density | ${volatilityPct}% volatility`;
    }catch(err){
      console.error("CA diagnostic failed:",err);
      setCAProbeOutput(null);
      RUN_STATE.caProbe=null;
      synthBar.className="synth-bar error";
      synthBar.textContent="CA DIAGNOSTIC SKIPPED - error in derivation";
      showToast("CA diagnostic derivation failed. Output is otherwise available.");
    }
  }else{
    setCAProbeOutput(null);
    RUN_STATE.caProbe=null;
  }
  if(cfg.redTeam){await runRedTeamPass(true);}
  setLastRun(buildRunSnapshot(target,probeResults,synthResult,cfg));
  saveRunToHistory(LAST_RUN).catch(()=>{});
  syncArtifactStoreFromRun();
  await new Promise(resolve=>setTimeout(resolve,500));
  showViz(target);
}

export async function assignSemanticPositions(target,cfg,setStatus){const notify=(msg)=>{if(typeof setStatus==="function") setStatus(msg);};setDiscSimMatrix(null);setProjectionStability(null);const embeddingInputs=TERMS.map(term=>buildEmbeddingText(term,target));const embedModel=String(cfg?.embeddingModel||"").trim()||"(unspecified embedding model)";const vectors=await callEmbeddings(embeddingInputs,cfg,(batchNo,total)=>{notify(`VECTOR LAYOUT - ${embedModel} batch ${batchNo}/${total}...`);});const normalizedVectors=vectors.map(normalizeEmbeddingVector);setDiscSimMatrix(computeDiscSimilarityMatrix(normalizedVectors));notify("VECTOR LAYOUT - projecting semantic manifold to 3D...");const basePoints=normalizePointCloud(await projectVectorsTo3D(normalizedVectors,PROJECTION_BASE_SEED),1.45);for(let i=0;i<TERMS.length;i++){TERMS[i].pos=basePoints[i]||[0,0,0];}const rerunCount=Math.max(0,Math.min(4,PROJECTION_STABILITY_RUNS-1));const reruns=[];for(let idx=0;idx<rerunCount;idx++){const seed=PROJECTION_BASE_SEED+idx+1;notify(`VECTOR LAYOUT - projection stability check ${idx+1}/${rerunCount}...`);const runPoints=normalizePointCloud(await projectVectorsTo3D(normalizedVectors,seed),1.45);reruns.push({seed,points:runPoints});}setProjectionStability(computeProjectionStability(basePoints,reruns));renderEmbeddingDiagnostics();}

export function resetToSetup(){disposeGallery();if(plotInited) Plotly.purge("plot");setPlotInited(false);setTerms([]);setDiscs([]);setCitations([]);setCallLogs([]);setRunState(null);setCurrentRunId(null);setActiveSlices(new Set());setActiveTypes(new Set());setSessionConfig(null);setLastRun(null);setDiscSimMatrix(null);setProjectionStability(null);setCAProbeOutput(null);setSemanticEdges(null);setCitationUnmappedSupportingTerms([]);setLastReportText("");setLastClaimsText("");setLastOutlineText("");setLastCritiqueText("");setLastMarkdownText("");setActiveArtifactKey("");setIsGenerating(false);setEvidenceFilterState({sourceType:"all",termLabel:""});clearNodeFilters();document.getElementById("evidence-filter-bar").innerHTML="";document.getElementById("evidence-modal-content").innerHTML="";document.getElementById("detail").style.display="none";renderCAPanel();renderNodeFilterResults();closeModal("raw-modal");closeModal("report-modal");closeModal("evidence-modal");closeModal("claims-modal");closeModal("outline-modal");closeModal("critique-modal");closeModal("replication-modal");closeModal("artifact-modal");setArtifactDrawer(false);setExportMenu(false);initArtifactStore();if(activeSetupMode&&activeSetupMode!=="landing"){MODE_STATE[activeSetupMode]=null;}renderDisciplineInputs(clampInt(document.getElementById("lens-count-input")?.value||7,2,12),getCurrentProbeSpecs());switchMainTab("generator",{silent:true});}
