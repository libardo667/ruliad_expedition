import { COLORS, PROJECTION_BASE_SEED, PROJECTION_STABILITY_RUNS } from '../core/constants.js';
import { ACTIVE_ARTIFACT_KEY, AMBIGUITY_QUEUE, CALL_LOGS, CA_PROBE_OUTPUT, CITATIONS, CITATION_UNMAPPED_SUPPORTING_TERMS, CURRENT_RUN_ID, DISCS, DISC_SIM_MATRIX, EVIDENCE_FILTER_STATE, LAST_RUN, PROJECTION_STABILITY, RUN_STATE, TERMS, WOLFRAM_GROUNDING_DIAGNOSTICS, activeSlices, activeTypes, isGenerating, lastClaimsText, lastCritiqueText, lastMarkdownText, lastOutlineText, lastReportText, plotInited, sessionConfig } from '../core/state.js';
import { progressEl } from '../core/refs.js';
import { clampInt } from '../core/utils.js';
import { setProbeState, showToast, updateAmbiguityQueueUIState } from '../ui/notifications.js';
import { switchMainTab } from '../ui/tabs.js';
import { getCurrentProbeSpecs, renderDisciplineInputs } from '../ui/setup-panel.js';
import { closeModal } from '../ui/modals.js';
import { setArtifactDrawer, setExportMenu } from '../ui/artifact-drawer-ui.js';
import { getProbeResultWithRecovery } from './probes.js';
import { getSynthesisResultWithRecovery, normalizeSynthesisResult } from './synthesis.js';
import { normalizeMode } from '../api/provider.js';
import { getQualityProfile, readApiConfig, validateApiConfig } from '../api/llm.js';
import { buildEmbeddingText, callEmbeddings } from '../api/embeddings.js';
import { computeRunGroundingStats } from '../grounding/wolfram-score.js';
import { groundProbeTermsWithWolfram } from '../grounding/wolfram-grounding.js';
import { buildTerms, makeAbbr } from '../domain/terms.js';
import { collectCitations } from '../domain/citations.js';
import { applySecondPassCleanup, buildRunSnapshot, computeRunId, safeConfigForRun } from '../domain/run-metadata.js';
import { appendDerivedCATermsToTerms, buildCATermsFromMetrics, deriveCAFromRun } from '../ca/derive-ca.js';
import { renderCAPanel } from '../ca/render-ca-panel.js';
import { normalizeEmbeddingVector } from '../embedding/vector-math.js';
import { applyFallbackPositions, normalizePointCloud, projectVectorsTo3D } from '../embedding/projection.js';
import { computeDiscSimilarityMatrix, computeProjectionStability, renderEmbeddingDiagnostics } from '../embedding/diagnostics.js';
import { showViz } from '../plot/plot-render.js';
import { clearNodeFilters, renderNodeFilterResults } from '../plot/sidebar.js';
import { initArtifactStore, syncArtifactStoreFromRun } from '../artifacts/artifact-store.js';
import { runRedTeamPass } from '../artifacts/artifact-generators.js';
import { resolvePromptBundleWithOverrides } from '../prompt/prompt-system.js';
import { buildProbeSystemPrompt, buildProbeUserPrompt, buildRedTeamPrompt, buildSynthesisPrompt } from '../prompt/prompt-builders.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Source: ruliad_expedition_v1.1.html
// Module: js/pipeline/launch-expedition.js

export async function launchExpedition(){
  const target=document.getElementById("target-input").value.trim();
  if(!target){showToast("Please enter a target concept.");return;}
  const cfg=readApiConfig();
  const quality=getQualityProfile(cfg.qualityMode);
  const cfgError=validateApiConfig(cfg);
  if(cfgError){showToast(cfgError);return;}
  if(normalizeMode(cfg)==="direct"&&location.protocol==="file:"){showToast("Tip: if auth fails in direct mode, serve this file from localhost instead of file://.");}
  sessionConfig=cfg;
  CALL_LOGS=[];
  CITATIONS=[];
  WOLFRAM_GROUNDING_DIAGNOSTICS=[];
  AMBIGUITY_QUEUE=[];
  updateAmbiguityQueueUIState();
  DISC_SIM_MATRIX=null;
  PROJECTION_STABILITY=null;
  CA_PROBE_OUTPUT=null;
  initArtifactStore();
  const discNames=Array.from(document.querySelectorAll(".disc-input")).map(el=>el.value.trim()).filter(Boolean);
  if(discNames.length<2){showToast("Please fill in at least 2 disciplines.");return;}
  const discSpecs=[...discNames.map(name=>({name,kind:"llm"}))];
  const probeSystemDefault=buildProbeSystemPrompt(cfg);
  const probeSystemBundle=resolvePromptBundleWithOverrides("probe_system",{target,cfg,quality,defaults:{systemPrompt:probeSystemDefault,userPrompt:""}});
  const probeSystem=probeSystemBundle.systemPrompt||probeSystemDefault;
  const probeTemplateDefaults={systemPrompt:probeSystem,userPrompt:buildProbeUserPrompt(target,"__DISCIPLINE__",quality,cfg)};
  const probeTemplateBundle=resolvePromptBundleWithOverrides("probe_user",{discName:"__DISCIPLINE__",target,cfg,quality,defaults:probeTemplateDefaults});
  const synthesisDefaults={systemPrompt:buildProbeSystemPrompt(cfg),userPrompt:buildSynthesisPrompt(target,[],quality,cfg)};
  const synthesisBundle=resolvePromptBundleWithOverrides("synthesis",{target,cfg,quality,defaults:synthesisDefaults});
  const redTeamDefaults={systemPrompt:"You are a skeptical reviewer.",userPrompt:buildRedTeamPrompt(target,[],{contradictory:[],emergent:[]},cfg)};
  const redTeamBundle=resolvePromptBundleWithOverrides("artifact_red_team",{target,cfg,quality,defaults:redTeamDefaults});
  const runFingerprint={target,probes:discSpecs.map(x=>x.name),config:safeConfigForRun(cfg),prompts:{probeSystem,probeUserTemplate:probeTemplateBundle.userPrompt,synthTemplate:synthesisBundle.userPrompt,redTeamTemplate:redTeamBundle.userPrompt}};
  CURRENT_RUN_ID=computeRunId(runFingerprint);
  RUN_STATE={runId:CURRENT_RUN_ID,target,config:cfg,probeResults:[],synthResult:{convergent:[],contradictory:[],emergent:[]},generatedAt:new Date().toISOString(),caProbe:null,wolframGroundingDiagnostics:[],ambiguityQueue:[]};
  DISCS=discSpecs.map((spec,i)=>({id:i,name:spec.name,abbr:makeAbbr(spec.name),col:COLORS[i%COLORS.length],kind:spec.kind}));
  isGenerating=true;
  switchMainTab("plot",{silent:true});
  const prog=progressEl;
  prog.style.display="flex";
  document.getElementById("prog-target-label").textContent=`TARGET: ${target.toUpperCase()} | CHAT MODEL: ${cfg.researchModel} | EMBED MODEL: ${cfg.embeddingModel} | QUALITY: ${quality.id.toUpperCase()} | WEB: ${cfg.webSearch?"ON":"OFF"} | WOLFRAM: ${(cfg.wolframEntityGrounding||cfg.enableComputationalIrreducibility)?"ON":"OFF"}`;
  const probeListEl=document.getElementById("probe-list");
  probeListEl.innerHTML="";
  for(const d of DISCS){const el=document.createElement("div");el.className="probe-item";el.innerHTML=`<div class="probe-dot idle" id="dot-${d.id}"></div><span class="probe-name" style="color:${d.col}">${d.name}</span><span class="probe-status" id="status-${d.id}">QUEUED</span>`;probeListEl.appendChild(el);}
  const probePromises=DISCS.map(async(d)=>{
    setProbeState(d.id,"running","RESEARCHING...");
    try{
      const probeDefaults={systemPrompt:probeSystem,userPrompt:buildProbeUserPrompt(target,d.name,quality,cfg)};
      const probeBundle=resolvePromptBundleWithOverrides("probe_user",{discName:d.name,target,cfg,quality,defaults:probeDefaults});
      let norm=await getProbeResultWithRecovery({target,discName:d.name,probeSystem:probeBundle.systemPrompt||probeSystem,userMsg:probeBundle.userPrompt,cfg});
      norm=await groundProbeTermsWithWolfram(norm,target,d.name,cfg);
      setProbeState(d.id,"done",`${norm.terms?.length||0} TERMS`);
      return {discId:d.id,summary:norm.summary,terms:Array.isArray(norm.terms)?norm.terms:[],claims_or_findings:norm.claims_or_findings,citations:norm.citations,confidence_notes:norm.confidence_notes};
    }catch(err){
      setProbeState(d.id,"error","ERROR");
      console.error(`Probe ${d.name} failed:`,err);
      return {discId:d.id,summary:"",terms:[],claims_or_findings:[],citations:[],confidence_notes:""};
    }
  });
  const probeResults=await Promise.all(probePromises);
  RUN_STATE.probeResults=probeResults;
  RUN_STATE.caProbe=null;
  const synthBar=document.getElementById("synth-bar");
  synthBar.className="synth-bar running";
  synthBar.textContent="SYNTHESIS - identifying convergences, contradictions, emergent features...";
  let synthResult={convergent:[],contradictory:[],emergent:[]};
  try{
    synthResult=await getSynthesisResultWithRecovery(target,probeResults,quality,cfg,{contextLabel:"launch"});
    synthBar.className="synth-bar done";
    synthBar.textContent=`SYNTHESIS COMPLETE - ${synthResult.convergent?.length||0} convergent | ${synthResult.contradictory?.length||0} contradictions | ${synthResult.emergent?.length||0} emergent`;
  }catch(err){
    synthBar.className="synth-bar error";
    synthBar.textContent="SYNTHESIS ERROR - proceeding with fallback synthesis";
    console.error("Synthesis failed:",err);
    synthResult=normalizeSynthesisResult({},target,probeResults,quality);
  }
  RUN_STATE.synthResult=synthResult;
  if(quality.cleanup){
    synthBar.className="synth-bar running";
    synthBar.textContent="TERM CLEANUP - resolving near-duplicate wording...";
    try{await applySecondPassCleanup(target,probeResults,synthResult,cfg);synthBar.textContent="TERM CLEANUP COMPLETE";}
    catch(err){console.warn("Cleanup pass failed:",err);synthBar.textContent="TERM CLEANUP SKIPPED - using first pass terms";}
  }
  buildTerms(probeResults,synthResult);
  collectCitations();
  if(TERMS.length){
    synthBar.className="synth-bar running";
    try{
      await assignSemanticPositions(target,cfg,msg=>{synthBar.textContent=msg;});
      synthBar.className="synth-bar done";
      synthBar.textContent=`VECTOR LAYOUT COMPLETE - ${TERMS.length} terms positioned by semantic distance`;
    }catch(err){
      console.error("Embedding layout failed:",err);
      applyFallbackPositions();
      DISC_SIM_MATRIX=null;
      PROJECTION_STABILITY=null;
      synthBar.className="synth-bar error";
      synthBar.textContent="VECTOR LAYOUT ERROR - using fallback geometry";
      showToast("Embedding layout failed. Fallback geometry was applied.");
    }
  }else{
    applyFallbackPositions();
    DISC_SIM_MATRIX=null;
    PROJECTION_STABILITY=null;
  }
  if(cfg.enableComputationalIrreducibility){
    synthBar.className="synth-bar running";
    synthBar.textContent="COMPUTATIONAL IRREDUCIBILITY - deriving CA from expedition topology...";
    try{
      const caResult=await deriveCAFromRun(target,cfg,probeResults,synthResult,{
        discSimilarityMatrix:DISC_SIM_MATRIX,
        projectionStability:PROJECTION_STABILITY,
        groundingStats:computeRunGroundingStats(TERMS,CITATIONS)
      });
      CA_PROBE_OUTPUT=caResult;
      appendDerivedCATermsToTerms(buildCATermsFromMetrics(caResult));
      RUN_STATE.caProbe=caResult;
      const densityPct=(Number((caResult?.metrics?.densityFinal??caResult?.metrics?.density)||0)*100).toFixed(1);
      const volatilityPct=(Number((caResult?.metrics?.volatilityFinal??caResult?.metrics?.volatility)||0)*100).toFixed(1);
      synthBar.className="synth-bar done";
      synthBar.textContent=`CA DIAGNOSTIC COMPLETE - Rule ${caResult?.rule??"n/a"} | ${densityPct}% density | ${volatilityPct}% volatility`;
    }catch(err){
      console.error("CA diagnostic failed:",err);
      CA_PROBE_OUTPUT=null;
      RUN_STATE.caProbe=null;
      synthBar.className="synth-bar error";
      synthBar.textContent="CA DIAGNOSTIC SKIPPED - error in derivation";
      showToast("CA diagnostic derivation failed. Expedition output is otherwise available.");
    }
  }else{
    CA_PROBE_OUTPUT=null;
    RUN_STATE.caProbe=null;
  }
  if(cfg.redTeam){await runRedTeamPass(true);}
  LAST_RUN=buildRunSnapshot(target,probeResults,synthResult,cfg);
  syncArtifactStoreFromRun();
  await new Promise(resolve=>setTimeout(resolve,500));
  showViz(target);
}

export async function assignSemanticPositions(target,cfg,setStatus){const notify=(msg)=>{if(typeof setStatus==="function") setStatus(msg);};DISC_SIM_MATRIX=null;PROJECTION_STABILITY=null;const embeddingInputs=TERMS.map(term=>buildEmbeddingText(term,target));const embedModel=String(cfg?.embeddingModel||"").trim()||"(unspecified embedding model)";const vectors=await callEmbeddings(embeddingInputs,cfg,(batchNo,total)=>{notify(`VECTOR LAYOUT - ${embedModel} batch ${batchNo}/${total}...`);});const normalizedVectors=vectors.map(normalizeEmbeddingVector);DISC_SIM_MATRIX=computeDiscSimilarityMatrix(normalizedVectors);notify("VECTOR LAYOUT - projecting semantic manifold to 3D...");const basePoints=normalizePointCloud(await projectVectorsTo3D(normalizedVectors,PROJECTION_BASE_SEED),1.45);for(let i=0;i<TERMS.length;i++){TERMS[i].pos=basePoints[i]||[0,0,0];}const rerunCount=Math.max(0,Math.min(4,PROJECTION_STABILITY_RUNS-1));const reruns=[];for(let idx=0;idx<rerunCount;idx++){const seed=PROJECTION_BASE_SEED+idx+1;notify(`VECTOR LAYOUT - projection stability check ${idx+1}/${rerunCount}...`);const runPoints=normalizePointCloud(await projectVectorsTo3D(normalizedVectors,seed),1.45);reruns.push({seed,points:runPoints});}PROJECTION_STABILITY=computeProjectionStability(basePoints,reruns);renderEmbeddingDiagnostics();}

export function resetToSetup(){if(plotInited) Plotly.purge("plot");plotInited=false;TERMS=[];DISCS=[];CITATIONS=[];CALL_LOGS=[];RUN_STATE=null;CURRENT_RUN_ID=null;activeSlices=new Set();activeTypes=new Set();sessionConfig=null;LAST_RUN=null;DISC_SIM_MATRIX=null;PROJECTION_STABILITY=null;CA_PROBE_OUTPUT=null;WOLFRAM_GROUNDING_DIAGNOSTICS=[];AMBIGUITY_QUEUE=[];CITATION_UNMAPPED_SUPPORTING_TERMS=[];lastReportText="";lastClaimsText="";lastOutlineText="";lastCritiqueText="";lastMarkdownText="";ACTIVE_ARTIFACT_KEY="";isGenerating=false;EVIDENCE_FILTER_STATE={sourceType:"all",termLabel:"",provider:"all"};clearNodeFilters();document.getElementById("evidence-filter-bar").innerHTML="";document.getElementById("evidence-modal-content").innerHTML="";document.getElementById("ambiguity-modal-content").innerHTML="";document.getElementById("detail").style.display="none";updateAmbiguityQueueUIState();renderCAPanel();renderNodeFilterResults();closeModal("raw-modal");closeModal("report-modal");closeModal("evidence-modal");closeModal("ambiguity-modal");closeModal("claims-modal");closeModal("outline-modal");closeModal("critique-modal");closeModal("replication-modal");closeModal("artifact-modal");setArtifactDrawer(false);setExportMenu(false);initArtifactStore();renderDisciplineInputs(clampInt(document.getElementById("lens-count-input")?.value||7,2,12),getCurrentProbeSpecs());switchMainTab("generator",{silent:true});}
