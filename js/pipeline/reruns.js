import { CA_PROBE_OUTPUT, CITATIONS, DISCS, DISC_SIM_MATRIX, LAST_RUN, PROJECTION_STABILITY, RUN_STATE, TERMS } from '../core/state.js';
import { showToast } from '../ui/notifications.js';
import { assignSemanticPositions } from './launch-expedition.js';
import { getProbeResultWithRecovery } from './probes.js';
import { getSynthesisResultWithRecovery } from './synthesis.js';
import { getQualityProfile, readApiConfig, validateApiConfig } from '../api/llm.js';
import { computeRunGroundingStats } from '../grounding/wolfram-score.js';
import { groundProbeTermsWithWolfram } from '../grounding/wolfram-grounding.js';
import { buildTerms } from '../domain/terms.js';
import { collectCitations } from '../domain/citations.js';
import { buildRunSnapshot } from '../domain/run-metadata.js';
import { appendDerivedCATermsToTerms, buildCATermsFromMetrics, deriveCAFromRun } from '../ca/derive-ca.js';
import { renderCAPanel } from '../ca/render-ca-panel.js';
import { renderPlot } from '../plot/plot-render.js';
import { buildStats } from '../plot/sidebar.js';
import { markArtifactsStale, syncArtifactStoreFromRun } from '../artifacts/artifact-store.js';
import { resolvePromptBundleWithOverrides } from '../prompt/prompt-system.js';
import { buildProbeSystemPrompt, buildProbeUserPrompt } from '../prompt/prompt-builders.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Source: ruliad_expedition_v1.1.html
// Module: js/pipeline/reruns.js

export async function rerunSynthesis(){
  if(!RUN_STATE?.probeResults?.length){showToast("No probe data to re-synthesize.");return;}
  const cfg=readApiConfig();
  const cfgError=validateApiConfig(cfg);
  if(cfgError){showToast(cfgError);return;}
  const quality=getQualityProfile(cfg.qualityMode);
  const synthBar=document.getElementById("synth-bar");
  synthBar.className="synth-bar running";
  synthBar.textContent="SYNTHESIS - re-running...";
  try{
    const synthResult=await getSynthesisResultWithRecovery(RUN_STATE.target,RUN_STATE.probeResults,quality,cfg,{contextLabel:"rerun"});
    RUN_STATE.synthResult=synthResult;
    buildTerms(RUN_STATE.probeResults,synthResult);
    collectCitations();
    await assignSemanticPositions(RUN_STATE.target,cfg,msg=>{synthBar.textContent=msg;});
    if(cfg.enableComputationalIrreducibility){
      synthBar.textContent="CA DIAGNOSTIC - deriving run fingerprint...";
      const caOutput=await deriveCAFromRun(RUN_STATE.target,cfg,RUN_STATE.probeResults,synthResult,{
        discSimilarityMatrix:DISC_SIM_MATRIX,
        projectionStability:PROJECTION_STABILITY,
        groundingStats:computeRunGroundingStats(TERMS,CITATIONS)
      });
      appendDerivedCATermsToTerms(buildCATermsFromMetrics(caOutput));
      RUN_STATE.caProbe=caOutput;
    }else{
      CA_PROBE_OUTPUT=null;
      RUN_STATE.caProbe=null;
    }
    synthBar.className="synth-bar done";
    synthBar.textContent=`SYNTHESIS COMPLETE - ${synthResult.convergent?.length||0} convergent | ${synthResult.contradictory?.length||0} contradictions | ${synthResult.emergent?.length||0} emergent`;
    LAST_RUN=buildRunSnapshot(RUN_STATE.target,RUN_STATE.probeResults,synthResult,cfg);
    syncArtifactStoreFromRun();
    markArtifactsStale(["claims","outline","deep_report","red_team","replication","markdown"]);
    renderPlot();
    buildStats();
  }catch(err){
    console.error("Rerun synthesis failed:",err);
    synthBar.className="synth-bar error";
    synthBar.textContent="SYNTHESIS ERROR - see console";
    showToast("Synthesis rerun failed.");
  }
}

export async function rerunProbe(discId){
  if(RUN_STATE?.probeResults?.length===0){showToast("No probe data to rerun.");return;}
  const cfg=readApiConfig();
  const cfgError=validateApiConfig(cfg);
  if(cfgError){showToast(cfgError);return;}
  const target=RUN_STATE.target;
  const quality=getQualityProfile(cfg.qualityMode);
  const disc=DISCS.find(d=>d.id===discId);
  if(!disc){showToast("Probe not found.");return;}
  const probeSystemDefault=buildProbeSystemPrompt(cfg);
  const probeSystemBundle=resolvePromptBundleWithOverrides("probe_system",{target,cfg,quality,defaults:{systemPrompt:probeSystemDefault,userPrompt:""}});
  try{
    showToast(`Re-running ${disc.name}...`);
    if(disc.kind==="ca"){
      const caOutput=await deriveCAFromRun(target,cfg,RUN_STATE.probeResults,RUN_STATE.synthResult||{convergent:[],contradictory:[],emergent:[]},{
        discSimilarityMatrix:DISC_SIM_MATRIX,
        projectionStability:PROJECTION_STABILITY,
        groundingStats:computeRunGroundingStats(TERMS,CITATIONS)
      });
      appendDerivedCATermsToTerms(buildCATermsFromMetrics(caOutput));
      RUN_STATE.caProbe=caOutput;
      LAST_RUN=buildRunSnapshot(target,RUN_STATE.probeResults,RUN_STATE.synthResult||{convergent:[],contradictory:[],emergent:[]},cfg);
      syncArtifactStoreFromRun();
      markArtifactsStale(["claims","outline","deep_report","red_team","replication","markdown"]);
      renderPlot();
      buildStats();
      renderCAPanel();
      showToast("Run-derived CA diagnostics refreshed.");
      return;
    }
    const probeDefaults={systemPrompt:probeSystemBundle.systemPrompt||probeSystemDefault,userPrompt:buildProbeUserPrompt(target,disc.name,quality,cfg)};
    const probeBundle=resolvePromptBundleWithOverrides("probe_user",{discName:disc.name,target,cfg,quality,defaults:probeDefaults});
    let norm=await getProbeResultWithRecovery({target,discName:disc.name,probeSystem:probeBundle.systemPrompt||probeSystemBundle.systemPrompt||probeSystemDefault,userMsg:probeBundle.userPrompt,cfg});
    norm=await groundProbeTermsWithWolfram(norm,target,disc.name,cfg);
    const updated={discId,summary:norm.summary,terms:Array.isArray(norm.terms)?norm.terms:[],claims_or_findings:norm.claims_or_findings,citations:norm.citations,confidence_notes:norm.confidence_notes};
    const idx=RUN_STATE.probeResults.findIndex(r=>r.discId===discId);
    if(idx>=0){RUN_STATE.probeResults[idx]=updated;}else{RUN_STATE.probeResults.push(updated);}
    buildTerms(RUN_STATE.probeResults,RUN_STATE.synthResult||{convergent:[],contradictory:[],emergent:[]});
    collectCitations();
    await assignSemanticPositions(target,cfg,()=>{});
    if(cfg.enableComputationalIrreducibility){
      const caOutput=await deriveCAFromRun(target,cfg,RUN_STATE.probeResults,RUN_STATE.synthResult||{convergent:[],contradictory:[],emergent:[]},{
        discSimilarityMatrix:DISC_SIM_MATRIX,
        projectionStability:PROJECTION_STABILITY,
        groundingStats:computeRunGroundingStats(TERMS,CITATIONS)
      });
      appendDerivedCATermsToTerms(buildCATermsFromMetrics(caOutput));
      RUN_STATE.caProbe=caOutput;
    }else{
      CA_PROBE_OUTPUT=null;
      RUN_STATE.caProbe=null;
    }
    LAST_RUN=buildRunSnapshot(target,RUN_STATE.probeResults,RUN_STATE.synthResult||{convergent:[],contradictory:[],emergent:[]},cfg);
    syncArtifactStoreFromRun();
    markArtifactsStale(["claims","outline","deep_report","red_team","replication","markdown"]);
    renderPlot();
    buildStats();
    renderCAPanel();
    showToast(`Probe ${disc.name} updated.`);
  }catch(err){
    console.error("Probe rerun failed:",err);
    showToast("Probe rerun failed.");
  }
}
