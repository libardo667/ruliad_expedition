import { FALLBACK_DIRS } from '../core/constants.js';
import { DISCS, TERMS, activeSlices, activeTypes, nodeColorMode, showGroundingOverlays, showSurfaces, surfaceOpacity } from '../core/state.js';
import { getTermGroundingOutcome } from '../domain/grounding-status.js';
import { normalize3 } from '../embedding/vector-math.js';
import { getVisibleNodeTerms } from './sidebar.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Source: ruliad_expedition_v1.1.html
// Module: js/plot/plot-overlays.js

export function clamp01(v){return Math.max(0,Math.min(1,Number(v)||0));}

export function clampSurfaceOpacity(v){return Math.max(0,Math.min(0.35,Number(v)||0));}

export function fallbackDirection(idx){return FALLBACK_DIRS[idx%FALLBACK_DIRS.length]||[1,0,0];}

export function computeDisciplineAnchors(poolTerms=TERMS){const anchors={};for(const d of DISCS){const points=(poolTerms||[]).filter(t=>t.slices.includes(d.id));if(!points.length){anchors[d.id]=fallbackDirection(d.id).map(v=>v*1.2);continue;}const centroid=[0,0,0];for(const term of points){centroid[0]+=term.pos[0];centroid[1]+=term.pos[1];centroid[2]+=term.pos[2];}centroid[0]/=points.length;centroid[1]/=points.length;centroid[2]/=points.length;if(Math.hypot(centroid[0],centroid[1],centroid[2])<0.08){const dir=fallbackDirection(d.id);anchors[d.id]=[dir[0]*0.9,dir[1]*0.9,dir[2]*0.9];}else{anchors[d.id]=centroid;}}return anchors;}

export function buildSurface(discId,anchors,poolTerms=TERMS){const points=(poolTerms||[]).filter(t=>t.slices.includes(discId));if(points.length<3) return null;const col=DISCS[discId]?.col||"#fff";const cx=points.reduce((s,t)=>s+t.pos[0],0)/points.length;const cy=points.reduce((s,t)=>s+t.pos[1],0)/points.length;const cz=points.reduce((s,t)=>s+t.pos[2],0)/points.length;const baseDir=anchors[discId]||fallbackDirection(discId);const dir=normalize3(baseDir,fallbackDirection(discId));const tmp=Math.abs(dir[0])<0.9?[1,0,0]:[0,1,0];const u=[tmp[1]*dir[2]-tmp[2]*dir[1],tmp[2]*dir[0]-tmp[0]*dir[2],tmp[0]*dir[1]-tmp[1]*dir[0]];const unitU=normalize3(u,[0,1,0]);const v=[dir[1]*unitU[2]-dir[2]*unitU[1],dir[2]*unitU[0]-dir[0]*unitU[2],dir[0]*unitU[1]-dir[1]*unitU[0]];const angles=points.map(term=>{const dx=term.pos[0]-cx,dy=term.pos[1]-cy,dz=term.pos[2]-cz;return Math.atan2(dx*v[0]+dy*v[1]+dz*v[2],dx*unitU[0]+dy*unitU[1]+dz*unitU[2]);});const sorted=[...points.map((_,i)=>i)].sort((a,b)=>angles[a]-angles[b]);const x=[cx],y=[cy],z=[cz];for(const idx of sorted){x.push(points[idx].pos[0]);y.push(points[idx].pos[1]);z.push(points[idx].pos[2]);}x.push(points[sorted[0]].pos[0]);y.push(points[sorted[0]].pos[1]);z.push(points[sorted[0]].pos[2]);const i=[],j=[],k=[];const n=sorted.length;for(let q=1;q<=n;q++){i.push(0);j.push(q);k.push(q<n?q+1:1);}return {type:"mesh3d",x,y,z,i,j,k,color:col,opacity:clampSurfaceOpacity(surfaceOpacity),hoverinfo:"none",showlegend:false,flatshading:true,lighting:{ambient:0.9,diffuse:0.1}};}

export function markerSizeByCentrality(term,minSize,maxSize){const c=clamp01(term?.centrality??0.5);return minSize+(maxSize-minSize)*c;}

export function getGroundingConfidenceRank(term){const level=String(term?.grounding?.wolframConfidence?.level||"none").toLowerCase();if(level==="high") return 3;if(level==="medium") return 2;if(level==="low") return 1;const score=Number(term?.grounding?.wolframConfidence?.score);if(Number.isFinite(score)){if(score>=0.75) return 3;if(score>=0.4) return 2;if(score>0) return 1;}return 0;}

export function groundingColorForTerm(term){const outcome=getTermGroundingOutcome(term);const rank=getGroundingConfidenceRank(term);if(outcome==="grounded"){if(rank>=3) return "#16a34a";if(rank>=2) return "#0ea5e9";return "#84cc16";}if(outcome==="metadata_only") return "#f59e0b";if(outcome==="rejected") return "#ef4444";if(outcome==="local_defined") return "#0ea5e9";return "#64748b";}

export function getEmergentRingColor(){const theme=document.documentElement.getAttribute("data-theme")||"light";if(theme==="dark") return "#67e8f9";if(theme==="contrast") return "#00ffff";return "#0e7490";}

export function hasWolframGrounding(term){const grounding=term?.grounding||{};return Boolean((grounding?.wolframQueriesTried||[]).length||(grounding?.wolframEntities||[]).length||(grounding?.wolframInterpretations||[]).length);}

export function isUnresolvedGrounding(term){const outcome=getTermGroundingOutcome(term);if(outcome==="rejected") return true;if(outcome==="not_attempted"||outcome==="local_defined") return false;const interpretations=(term?.grounding?.wolframInterpretations||[]);if(Array.isArray(interpretations)&&interpretations.length>1) return true;const resolution=String(term?.grounding?.wolframResolution||"").toLowerCase();if(/fallback|ambiguous|did.?you.?mean/.test(resolution)) return true;return false;}

export function appendGroundingOverlayTraces(traces,pool){if(!showGroundingOverlays||!Array.isArray(pool)||!pool.length) return;const haloHigh=[],haloMed=[],haloLow=[],unresolved=[];for(const term of pool){if(!term) continue;if(isUnresolvedGrounding(term)){unresolved.push(term);continue;}if(getTermGroundingOutcome(term)==="grounded"){const rank=getGroundingConfidenceRank(term);if(rank>=3) haloHigh.push(term);else if(rank>=2) haloMed.push(term);else haloLow.push(term);}}const ringTrace=(terms,name,color,sizeBoost,lineWidth,symbol,showlegend,legendgroup)=>{if(!terms.length) return null;return {type:"scatter3d",mode:"markers",name,x:terms.map(t=>t.pos[0]),y:terms.map(t=>t.pos[1]),z:terms.map(t=>t.pos[2]),text:terms.map(t=>t.label),hovertemplate:"<b>%{text}</b><br><i>grounding overlay</i><extra></extra>",marker:{symbol,size:terms.map(t=>markerSizeByCentrality(t,8,16)+sizeBoost),color:"rgba(0,0,0,0)",line:{color,width:lineWidth},opacity:0.95},legendgroup,showlegend};};const highTrace=ringTrace(haloHigh,"Grounded Halo (high confidence)","#22c55e",8,3.1,"circle-open",true,"grounding-halo");const medTrace=ringTrace(haloMed,"Grounded Halo (medium confidence)","#14b8a6",7,2.1,"circle-open",true,"grounding-halo");const lowTrace=ringTrace(haloLow,"Grounded Halo (low confidence)","#84cc16",6,1.2,"circle-open",false,"grounding-halo");const unresolvedTrace=ringTrace(unresolved,"Unresolved / ambiguous","#f97316",9,2.2,"circle-open-dot",true,"grounding-ambiguous");for(const trace of [highTrace,medTrace,lowTrace,unresolvedTrace]){if(trace) traces.push(trace);}}

export function buildTraces(visibleTerms=getVisibleNodeTerms()){const traces=[];const pool=Array.isArray(visibleTerms)?visibleTerms:[];const anchors=computeDisciplineAnchors(pool);if(showSurfaces){for(const d of DISCS){if(!activeSlices.has(d.id)) continue;const surface=buildSurface(d.id,anchors,pool);if(surface) traces.push(surface);}}for(const d of DISCS){if(!activeSlices.has(d.id)) continue;const dir=normalize3(anchors[d.id],fallbackDirection(d.id));const tip=dir.map(v=>v*1.55);const labelPos=dir.map(v=>v*1.72);traces.push({type:"scatter3d",mode:"lines",x:[0,tip[0]],y:[0,tip[1]],z:[0,tip[2]],line:{color:d.col+"28",width:1.2},hoverinfo:"none",showlegend:false});traces.push({type:"scatter3d",mode:"text",x:[labelPos[0]],y:[labelPos[1]],z:[labelPos[2]],text:[d.abbr],textfont:{color:d.col,size:9,family:"Courier New"},textposition:"middle center",hoverinfo:"none",showlegend:false});}
if(activeTypes.has("unique")){for(const d of DISCS){if(!activeSlices.has(d.id)) continue;const ts=pool.filter(t=>t.type==="unique"&&t.slices[0]===d.id);if(!ts.length) continue;const colors=ts.map(t=>nodeColorMode==="grounding"?groundingColorForTerm(t):d.col);traces.push({type:"scatter3d",mode:"markers",name:d.abbr,x:ts.map(t=>t.pos[0]),y:ts.map(t=>t.pos[1]),z:ts.map(t=>t.pos[2]),text:ts.map(t=>t.label),customdata:ts.map(t=>clamp01(t.centrality)),hovertemplate:`<b>%{text}</b><br>${d.name}<br>centrality %{customdata:.2f}<br><i>unique</i><extra></extra>`,marker:{color:colors,size:ts.map(t=>markerSizeByCentrality(t,6,14)),opacity:nodeColorMode==="grounding"?0.92:0.85,symbol:"circle",line:{color:nodeColorMode==="grounding"?"#0f172a66":d.col+"66",width:nodeColorMode==="grounding"?1.1:0.5}},legendgroup:d.abbr,showlegend:true});}} 
if(activeTypes.has("convergent")){const ts=pool.filter(t=>t.type==="convergent");if(ts.length){const colors=ts.map(t=>{if(nodeColorMode==="grounding") return groundingColorForTerm(t);const n=t.slices.length;if(n>=6) return "#fff";if(n>=4) return "#aaaaff";if(n>=2) return "#7777cc";return "#5555aa";});traces.push({type:"scatter3d",mode:"markers",name:"Convergent",x:ts.map(t=>t.pos[0]),y:ts.map(t=>t.pos[1]),z:ts.map(t=>t.pos[2]),text:ts.map(t=>t.label),customdata:ts.map(t=>t.slices.length),hovertemplate:"<b>%{text}</b><br>%{customdata} disciplines<br><i>convergent</i><extra></extra>",marker:{color:colors,size:ts.map(t=>markerSizeByCentrality(t,8,18)+(t.slices.length/(DISCS.length||7))*4),opacity:nodeColorMode==="grounding"?0.95:0.92,symbol:"diamond",line:{color:nodeColorMode==="grounding"?"#0f172a88":"#ffffff44",width:nodeColorMode==="grounding"?1.2:0.5}},legendgroup:"convergent",showlegend:true});}}
if(activeTypes.has("contradictory")){const ts=pool.filter(t=>t.type==="contradictory");if(ts.length){const edgeX=[],edgeY=[],edgeZ=[];for(const term of ts){for(const slice of term.slices){if(!activeSlices.has(slice)) continue;const anchor=anchors[slice];if(!anchor) continue;edgeX.push(term.pos[0],anchor[0],null);edgeY.push(term.pos[1],anchor[1],null);edgeZ.push(term.pos[2],anchor[2],null);}}if(edgeX.length){traces.push({type:"scatter3d",mode:"lines",name:"Contradiction Edges",x:edgeX,y:edgeY,z:edgeZ,line:{color:"#ff950044",width:1.3},hoverinfo:"none",legendgroup:"contradictory",showlegend:false});}const colors=ts.map(t=>nodeColorMode==="grounding"?groundingColorForTerm(t):"#ff9500");traces.push({type:"scatter3d",mode:"markers",name:"Contradictory",x:ts.map(t=>t.pos[0]),y:ts.map(t=>t.pos[1]),z:ts.map(t=>t.pos[2]),text:ts.map(t=>t.label),hovertemplate:"<b>%{text}</b><br><i>tension zone</i><extra></extra>",marker:{color:colors,size:ts.map(t=>markerSizeByCentrality(t,12,22)),opacity:1,symbol:"cross",line:{color:nodeColorMode==="grounding"?"#0f172a88":"#ffcc00",width:nodeColorMode==="grounding"?1.3:1.5}},legendgroup:"contradictory",showlegend:true});}}
if(activeTypes.has("emergent")){const ts=pool.filter(t=>t.type==="emergent");if(ts.length){const ringColor=getEmergentRingColor();traces.push({type:"scatter3d",mode:"markers+text",name:"Emergent",x:ts.map(t=>t.pos[0]),y:ts.map(t=>t.pos[1]),z:ts.map(t=>t.pos[2]),text:ts.map(t=>t.label),textposition:"top center",textfont:{color:ringColor,size:9,family:"Courier New"},hovertemplate:"<b>%{text}</b><br><i>synthesis only</i><extra></extra>",marker:{color:ringColor,size:ts.map(t=>markerSizeByCentrality(t,14,26)),opacity:1,symbol:"circle-open",line:{color:ringColor,width:2.6}},legendgroup:"emergent",showlegend:true});}}
appendGroundingOverlayTraces(traces,pool);
return traces;}
