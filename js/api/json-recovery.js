import { callLLMJSON, getQualityProfile } from './llm.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Source: ruliad_expedition_v1.1.html
// Module: js/api/json-recovery.js

export function stripJsonCodeFences(text){const src=String(text||"");const matches=[...src.matchAll(/```(?:[a-z0-9_-]+)?\s*([\s\S]*?)```/ig)].map(m=>String(m?.[1]||"").trim()).filter(Boolean);if(!matches.length) return src;const preferred=[...matches].sort((a,b)=>b.length-a.length).find(chunk=>/[{\[]/.test(chunk));return preferred||matches[0]||src;}

export function findBalancedJsonCandidates(text){const src=String(text||"");const out=[];const stack=[];let start=-1;let quote="";let escape=false;for(let i=0;i<src.length;i++){const ch=src[i];if(escape){escape=false;continue;}if(quote){if(ch==="\\"){escape=true;continue;}if(ch===quote){quote="";}continue;}if(ch==="\""||ch==="'"){quote=ch;continue;}if(ch==="{"||ch==="["){if(stack.length===0) start=i;stack.push(ch);continue;}if(ch==="}"||ch==="]"){if(!stack.length) continue;const top=stack[stack.length-1];const ok=(top==="{"&&ch==="}")||(top==="["&&ch==="]");if(!ok){stack.length=0;start=-1;continue;}stack.pop();if(stack.length===0&&start!==-1){const piece=src.slice(start,i+1).trim();if(piece) out.push(piece);start=-1;}}}return out;}

export function escapeNewlinesInsideJsonStrings(text){const src=String(text||"");let out="";let quote="";let escape=false;for(let i=0;i<src.length;i++){const ch=src[i];if(escape){out+=ch;escape=false;continue;}if(quote){if(ch==="\\"){out+=ch;escape=true;continue;}if(ch===quote){out+=ch;quote="";continue;}if(ch==="\r") continue;if(ch==="\n"){out+="\\n";continue;}out+=ch;continue;}if(ch==="\""||ch==="'"){quote=ch;out+=ch;continue;}out+=ch;}return out;}

export function sanitizeJsonCandidate(text){let out=String(text||"").trim();out=out.replace(/^\uFEFF/,"").replace(/[\u201C\u201D]/g,"\"").replace(/[\u2018\u2019]/g,"'");out=out.replace(/\/\*[\s\S]*?\*\//g,"").replace(/^\s*\/\/.*$/gm,"");out=escapeNewlinesInsideJsonStrings(out);out=out.replace(/,\s*([}\]])/g,"$1").replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F]/g," ");return out.trim();}

export function buildJsonParseCandidates(text){const raw=String(text||"");const stripped=stripJsonCodeFences(raw);const out=[];const push=(value)=>{const val=String(value||"").trim();if(!val) return;if(!out.includes(val)) out.push(val);};for(const variant of [raw,stripped]){push(variant);const firstObj=variant.indexOf("{");const lastObj=variant.lastIndexOf("}");if(firstObj!==-1&&lastObj!==-1&&lastObj>firstObj) push(variant.slice(firstObj,lastObj+1));const firstArr=variant.indexOf("[");const lastArr=variant.lastIndexOf("]");if(firstArr!==-1&&lastArr!==-1&&lastArr>firstArr) push(variant.slice(firstArr,lastArr+1));for(const chunk of findBalancedJsonCandidates(variant)){push(chunk);}}for(const candidate of [...out]){push(sanitizeJsonCandidate(candidate));}return out.sort((a,b)=>b.length-a.length);}

export function parseJsonFromModelText(text){const candidates=buildJsonParseCandidates(text);let lastErr=null;for(const candidate of candidates){try{return JSON.parse(candidate);}catch(err){lastErr=err;}}throw new Error(`Could not parse JSON from model response${lastErr?`: ${lastErr.message||lastErr}`:"."}`);}

export function extractJSON(text){if(typeof text!=="string") throw new Error("Expected model response text.");return parseJsonFromModelText(text);}

export function extractJSONLenient(text){if(typeof text!=="string") throw new Error("Expected model response text.");return parseJsonFromModelText(text);}

export async function repairJSONWithModel(rawText,contextLabel,cfg){const repairSystem="You repair malformed JSON. Return only valid JSON.";const repairPrompt=`Task context: ${contextLabel}\n\nRepair the malformed JSON below. Preserve meaning and fields. Do not add markdown.\nReturn strict JSON only.\nExpected top-level object keys: summary, terms, claims_or_findings, citations, confidence_notes.\n\nMalformed text:\n${String(rawText||"").slice(0,24000)}`;return callLLMJSON(repairSystem,repairPrompt,{...cfg,__tempOverride:0,maxTokens:Math.max(900,Math.floor(getQualityProfile(cfg.qualityMode).maxTokens*0.9))});}

export function decodeLooseJsonString(value){return String(value||"").replace(/\\"/g,"\"").replace(/\\\\/g,"\\").replace(/\\n/g," ").replace(/\s+/g," ").trim();}

export function extractLooseJsonFieldValues(raw,field,maxItems=12){const src=String(raw||"");const safeField=String(field||"").replace(/[.*+?^${}()|[\]\\]/g,"\\$&");const re=new RegExp(`"${safeField}"\\s*:\\s*"((?:\\\\.|[^"\\\\])*)"`,`gi`);const out=[];let match=null;while((match=re.exec(src))&&out.length<maxItems){const val=decodeLooseJsonString(match[1]);if(val&&!out.includes(val)) out.push(val);}return out;}
