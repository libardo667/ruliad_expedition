import { DISCS } from '../core/state.js';
import { providerFetch } from './provider.js';
import { getQualityProfile, recordCall } from './llm.js';
import { applyDisplayDescriptionForTerm } from '../domain/terms.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Module: js/api/embeddings.js

export async function callEmbeddings(inputs,cfg,onBatch){const quality=getQualityProfile(cfg.qualityMode);const batchSize=quality.embedBatchSize;const out=[];const totalBatches=Math.max(1,Math.ceil(inputs.length/batchSize));for(let i=0;i<inputs.length;i+=batchSize){const batchNo=Math.floor(i/batchSize)+1;if(onBatch) onBatch(batchNo,totalBatches);const chunk=inputs.slice(i,i+batchSize);const body={model:cfg.embeddingModel,input:chunk,encoding_format:"float"};const startedAt=new Date().toISOString();const data=await providerFetch("embeddings",body,cfg);const vectors=(data.data||[]).map(row=>row.embedding).filter(v=>Array.isArray(v));if(vectors.length!==chunk.length){throw new Error(`Embedding batch mismatch (${vectors.length}/${chunk.length}).`);}recordCall({kind:"embeddings",timestamp:startedAt,model:cfg.embeddingModel,batch:batchNo,totalBatches,input_count:chunk.length,vector_dimensions:Array.isArray(vectors[0])?vectors[0].length:null,request:{model:cfg.embeddingModel,encoding_format:"float",input_count:chunk.length},response_meta:{object:String(data?.object||""),usage:data?.usage||null,data_count:Array.isArray(data?.data)?data.data.length:0}});out.push(...vectors);}return out;}

export function buildEmbeddingText(term,target){applyDisplayDescriptionForTerm(term,{fallbackDescription:term.description,fallbackSource:term.description_source});const discs=term.slices.map(i=>DISCS[i]?.name).filter(Boolean).join(" | ")||"synthesis";return `Target: ${target}. Type: ${term.type}. Disciplines: ${discs}. Term: ${term.label}. Description: ${term.description}`;}
