import { PROJECTION_BASE_SEED } from '../core/constants.js';
import { DISCS, RUN_STATE, TERMS } from '../core/state.js';
import { RNG, clampInt } from '../core/utils.js';
import { KNOWN_RULE_CLASSES } from '../domain/grounding-status.js';
import { medianOfNumbers } from './metrics.js';
import { averageNumbers } from '../embedding/vector-math.js';
import { clamp01 } from '../plot/plot-overlays.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Module: js/ca/automata.js

export function estimateWolframRuleClass(rule){
  const r=clampInt(rule,0,255);
  const known=KNOWN_RULE_CLASSES[r];
  if(known&&Number.isInteger(known.class)){
    return {wolframClass:known.class,wolframClassLabel:`Class ${known.class} (${known.label})`,classSource:"known_rule_lookup"};
  }
  return {wolframClass:null,wolframClassLabel:"unclassified (likely Class 2 or 3)",classSource:"fallback_default"};
}

export function resolveCARuleFallbackCounts(context={}){
  const synth=(context?.synthResult&&typeof context.synthResult==="object")?context.synthResult:(RUN_STATE?.synthResult||{});
  const probeCount=context?.probeCount;
  const termCount=context?.termCount;
  const convergentCount=context?.convergentCount;
  const contradictoryCount=context?.contradictoryCount;
  const emergentCount=context?.emergentCount;
  return {
    probeCount:clampInt(Number.isFinite(Number(probeCount))?Number(probeCount):DISCS.filter(d=>d?.kind!=="ca").length,0,999),
    termCount:clampInt(Number.isFinite(Number(termCount))?Number(termCount):TERMS.length,0,9999),
    convergentCount:clampInt(Number.isFinite(Number(convergentCount))?Number(convergentCount):(Array.isArray(synth?.convergent)?synth.convergent.length:0),0,9999),
    contradictoryCount:clampInt(Number.isFinite(Number(contradictoryCount))?Number(contradictoryCount):(Array.isArray(synth?.contradictory)?synth.contradictory.length:0),0,9999),
    emergentCount:clampInt(Number.isFinite(Number(emergentCount))?Number(emergentCount):(Array.isArray(synth?.emergent)?synth.emergent.length:0),0,9999)
  };
}

export function computeCARuleFallbackHash(context={}){
  const counts=resolveCARuleFallbackCounts(context);
  const rule=((counts.probeCount*31)^(counts.termCount*17)^((counts.convergentCount*7)+(counts.contradictoryCount*13)+(counts.emergentCount*23)))&0xFF;
  const classMeta=estimateWolframRuleClass(rule);
  return {
    rule,
    derivation:"fallback_hash",
    medianDistance:null,
    selectedPairs:[],
    fallbackInputs:counts,
    wolframClass:classMeta.wolframClass,
    wolframClassLabel:classMeta.wolframClassLabel,
    wolframClassSource:classMeta.classSource
  };
}

export function takeWithWrap(items,count){
  const list=Array.isArray(items)?items:[];
  if(!list.length||count<=0) return [];
  const out=[];
  for(let i=0;i<count;i++){
    const item=list[i%list.length];
    out.push(item&&typeof item==="object"?{...item}:item);
  }
  return out;
}

export function deriveRuleFromSimilarityMatrix(simMatrix,context={}){
  if(!simMatrix||typeof simMatrix!=="object"||!Array.isArray(simMatrix.distances)||simMatrix.distances.length<2){
    return computeCARuleFallbackHash(context);
  }
  const distances=simMatrix.distances;
  const size=distances.length;
  const labels=Array.isArray(simMatrix.labels)&&simMatrix.labels.length===size?simMatrix.labels.map(label=>String(label||"").trim()):new Array(size).fill("").map((_,idx)=>DISCS[idx]?.abbr||`D${idx+1}`);
  const pairs=[];
  for(let row=0;row<size;row++){
    for(let col=row+1;col<size;col++){
      const distance=Number(distances?.[row]?.[col]);
      if(!Number.isFinite(distance)) continue;
      pairs.push({
        row,
        col,
        probeA:labels[row]||`D${row+1}`,
        probeB:labels[col]||`D${col+1}`,
        distance
      });
    }
  }
  if(!pairs.length){
    return computeCARuleFallbackHash(context);
  }
  const medianDistance=medianOfNumbers(pairs.map(pair=>pair.distance));
  const sortedDesc=[...pairs].sort((a,b)=>b.distance-a.distance||a.row-b.row||a.col-b.col);
  const sortedAsc=[...pairs].sort((a,b)=>a.distance-b.distance||a.row-b.row||a.col-b.col);
  const highPairs=takeWithWrap(sortedDesc,4);
  const lowPairs=takeWithWrap(sortedAsc,4);
  const selectedByBit=[
    lowPairs[3],
    lowPairs[2],
    lowPairs[1],
    lowPairs[0],
    highPairs[3],
    highPairs[2],
    highPairs[1],
    highPairs[0]
  ].map((pair,bitIndex)=>{
    const bit=Number(pair?.distance)>=Number(medianDistance)?1:0;
    return {
      bitIndex,
      probeA:String(pair?.probeA||""),
      probeB:String(pair?.probeB||""),
      distance:Number(pair?.distance),
      bit
    };
  });
  let rule=0;
  for(const item of selectedByBit){
    rule|=(item.bit<<item.bitIndex);
  }
  rule&=0xFF;
  const classMeta=estimateWolframRuleClass(rule);
  return {
    rule,
    derivation:"similarity_matrix",
    medianDistance:Number.isFinite(Number(medianDistance))?Number(medianDistance):null,
    selectedPairs:selectedByBit,
    wolframClass:classMeta.wolframClass,
    wolframClassLabel:classMeta.wolframClassLabel,
    wolframClassSource:classMeta.classSource
  };
}

export function deriveWidthFromTermCount(terms){
  const safeTerms=Array.isArray(terms)?terms:[];
  const termCount=safeTerms.length;
  const width=normalizeOddWidth(clampInt((termCount*2)+1,31,401));
  return {width,termCount};
}

export function deriveStepsFromSynthesisDepth(synthResult,terms,groundingStats){
  const synth=(synthResult&&typeof synthResult==="object")?synthResult:{};
  const safeTerms=Array.isArray(terms)?terms:[];
  const stats=(groundingStats&&typeof groundingStats==="object")?groundingStats:{};
  const baseSteps=48;
  const convergentCount=Array.isArray(synth.convergent)?synth.convergent.length:0;
  const contradictoryCount=Array.isArray(synth.contradictory)?synth.contradictory.length:0;
  const emergentCount=Array.isArray(synth.emergent)?synth.emergent.length:0;
  const convergentBonus=convergentCount*3;
  const contradictoryBonus=contradictoryCount*6;
  const emergentBonus=emergentCount*8;
  const avgCitationsPerNode=Number(stats.avgCitationsPerNode);
  const evidenceBonus=Math.floor((Number.isFinite(avgCitationsPerNode)?avgCitationsPerNode:0)*4);
  const multiProbeTerms=safeTerms.filter(term=>Array.isArray(term?.slices)&&term.slices.length>=2).length;
  const coverageBonus=Math.floor(multiProbeTerms*1.5);
  const breakdown={
    base:baseSteps,
    convergent:convergentBonus,
    contradictory:contradictoryBonus,
    emergent:emergentBonus,
    evidence:evidenceBonus,
    coverage:coverageBonus
  };
  const total=baseSteps+convergentBonus+contradictoryBonus+emergentBonus+evidenceBonus+coverageBonus;
  const steps=clampInt(total,48,240);
  return {
    steps,
    breakdown,
    counts:{convergentCount,contradictoryCount,emergentCount,multiProbeTerms}
  };
}

export function buildInitialRowFromProbes(discs,terms,probeResults,width){
  const safeDiscs=Array.isArray(discs)?discs:[];
  const safeTerms=Array.isArray(terms)?terms:[];
  const safeProbeResults=Array.isArray(probeResults)?probeResults:[];
  const probeCount=Math.max(1,safeDiscs.length);
  const w=normalizeOddWidth(width);
  const initialRow=new Uint8Array(w);
  const segmentWidth=Math.floor(w/probeCount);
  const remainder=w-(segmentWidth*probeCount);
  const probeSegments=[];
  for(let i=0;i<probeCount;i++){
    const segStart=(i*segmentWidth)+Math.min(i,remainder);
    const segEnd=segStart+segmentWidth+(i<remainder?1:0);
    const disc=safeDiscs[i]||{};
    const discId=Number.isInteger(Number(disc?.id))?Number(disc.id):i;
    const probeTerms=safeTerms.filter(term=>Array.isArray(term?.slices)&&term.slices.includes(discId));
    let meanCentrality=averageNumbers(probeTerms.map(term=>Number(term?.centrality)));
    if(!Number.isFinite(meanCentrality)) meanCentrality=0.5;
    const convergentFraction=probeTerms.length?probeTerms.filter(term=>String(term?.type||"").trim().toLowerCase()!=="unique").length/Math.max(probeTerms.length,1):0;
    const citationDensity=probeTerms.length?clamp01(probeTerms.filter(term=>Array.isArray(term?.citations)&&term.citations.length>0).length/Math.max(probeTerms.length,1)):0;
    const seedDensity=clamp01((meanCentrality*0.4)+(convergentFraction*0.35)+(citationDensity*0.25));
    const rng=new RNG(PROJECTION_BASE_SEED+(i*7)+1);
    for(let x=segStart;x<segEnd&&x<w;x++){
      initialRow[x]=rng.next()<seedDensity?1:0;
    }
    if(segEnd>segStart){
      const center=Math.floor((segStart+segEnd)/2);
      if(center>=0&&center<w) initialRow[center]=1;
    }
    const probeResult=safeProbeResults.find(row=>Number(row?.discId)===discId)||null;
    probeSegments.push({
      probeId:discId,
      name:String(disc?.name||`Probe ${i+1}`),
      start:segStart,
      end:segEnd,
      seedDensity:Number(seedDensity.toFixed(4)),
      termCount:probeTerms.length,
      probeResultTermCount:Array.isArray(probeResult?.terms)?probeResult.terms.length:0
    });
  }
  return {initialRow,probeSegments,width:w,probeCount};
}

export function normalizeOddWidth(width){let w=clampInt(width,31,401);if(w%2===0) w=Math.min(401,w+1);return w;}

export function simulateElementaryCA(rule,steps,width,initialRow=null){
  const w=normalizeOddWidth(width);
  const s=clampInt(steps,16,240);
  const r=clampInt(rule,0,255);
  const grid=[];
  let row=new Array(w).fill(0);
  if(initialRow!==null&&initialRow!==undefined){
    if(!Array.isArray(initialRow)&&!(initialRow instanceof Uint8Array)){
      throw new Error("simulateElementaryCA: initialRow must be an Array or Uint8Array when provided.");
    }
    if(initialRow.length!==w){
      throw new Error(`simulateElementaryCA: initialRow length (${initialRow.length}) must equal width (${w}).`);
    }
    row=Array.from(initialRow,cell=>Number(cell)===1?1:0);
  }else{
    row[Math.floor(w/2)]=1;
  }
  grid.push([...row]);
  for(let y=1;y<s;y++){
    const next=new Array(w).fill(0);
    for(let x=0;x<w;x++){
      const left=row[x-1]||0;
      const center=row[x]||0;
      const right=row[x+1]||0;
      const idx=(left<<2)|(center<<1)|right;
      next[x]=(r>>idx)&1;
    }
    grid.push(next);
    row=next;
  }
  return {rule:r,steps:s,width:w,grid};
}

export function isRunDerivedCAOutput(output){
  const derivation=output?.derivation;
  if(!derivation||typeof derivation!=="object") return false;
  return Boolean(derivation.rule||derivation.steps||derivation.width||derivation.initialRow);
}
