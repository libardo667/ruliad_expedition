import { PROJECTION_BASE_SEED } from '../core/constants.js';
import { CA_PROBE_OUTPUT, CITATIONS, DISCS, DISC_SIM_MATRIX, PROJECTION_STABILITY, TERMS, WOLFRAM_GROUNDING_DIAGNOSTICS } from '../core/state.js';
import { RNG, clampInt, structuredCloneSafe } from '../core/utils.js';
import { normalizeMode } from '../api/provider.js';
import { extractWolframStructured, fetchWolframJSON, selectWolframSnippetFromParsed } from '../grounding/wolfram-parse.js';
import { computeGroundingStats } from '../grounding/wolfram-score.js';
import { mergeGroundingBlocks, normalizeGroundingBlock } from '../grounding/wolfram-grounding.js';
import { inferDescriptionSourceFromLayers, mergeDescription, mergeTermDescriptions, mergeType, normalizeTermDescriptions } from '../domain/terms.js';
import { toCanonicalKey } from '../domain/aliases.js';
import { mergeDescriptionProvenance, mergeDescriptionSource } from '../domain/citations.js';
import { KNOWN_RULE_CLASSES, refreshTermSignalFields } from '../domain/grounding-status.js';
import { buildInitialRowFromProbes, deriveRuleFromSimilarityMatrix, deriveStepsFromSynthesisDepth, deriveWidthFromTermCount, estimateWolframRuleClass, simulateElementaryCA } from './automata.js';
import { classifyTrajectoryTrend, computeAutomataMetrics, modeValue } from './metrics.js';
import { renderAutomataDataUrl } from './render-ca-panel.js';
import { averageNumbers } from '../embedding/vector-math.js';
import { computeRunDiscSimilarityMatrixForTerms } from '../embedding/diagnostics.js';
import { clamp01 } from '../plot/plot-overlays.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Source: ruliad_expedition_v1.1.html
// Module: js/ca/derive-ca.js

export function extractWolframClassNumber(value,label=""){
  if(Number.isFinite(Number(value))) return clampInt(Number(value),1,4);
  const txt=String(label||"");
  const m=txt.match(/class\s*(\d)/i);
  if(!m) return null;
  return clampInt(Number(m[1]),1,4);
}

export function formatWolframClassForReplication(value,label=""){
  const classNo=extractWolframClassNumber(value,label);
  if(Number.isFinite(Number(classNo))) return `Class ${Number(classNo)}`;
  const txt=String(label||"").trim();
  return txt||"unclassified";
}

export function summarizeReplicationCAFingerprints(results,models){
  const out=[];
  const modelList=Array.isArray(models)?models:[];
  const rows=Array.isArray(results)?results:[];
  for(const model of modelList){
    const modelRows=rows.filter(row=>String(row?.model||"")===String(model||""));
    const valid=modelRows.filter(row=>!row?.error&&row?.caFingerprint&&typeof row.caFingerprint==="object");
    if(!valid.length){
      const fallbackErr=String(modelRows.find(row=>row?.caError)?.caError||modelRows.find(row=>row?.error)?.error||"no successful CA fingerprint");
      out.push({model,error:fallbackErr});
      continue;
    }
    const ruleMode=modeValue(valid.map(row=>Number(row.caFingerprint?.rule)));
    const trendMode=modeValue(valid.map(row=>String(row.caFingerprint?.volatilityTrend||"stable")));
    const classMode=modeValue(valid.map(row=>formatWolframClassForReplication(row.caFingerprint?.wolframClass,row.caFingerprint?.wolframClassLabel)));
    const classLabel=String(classMode.value||"unclassified");
    const classNo=extractWolframClassNumber(null,classLabel);
    out.push({
      model,
      rule:clampInt(Number(ruleMode.value)||0,0,255),
      classLabel,
      classNo:Number.isFinite(Number(classNo))?Number(classNo):null,
      classKey:classLabel,
      volatilityTrend:String(trendMode.value||"stable"),
      runCount:valid.length
    });
  }
  return out;
}

export function formatReplicationCAFingerprintSection(results,models){
  const modelSummaries=summarizeReplicationCAFingerprints(results,models);
  if(!modelSummaries.length){
    return "CA fingerprint stability:\n- no replication models were evaluated.";
  }
  const lines=["CA fingerprint stability:"];
  for(const row of modelSummaries){
    if(row.error){
      lines.push(`- ${row.model}: unavailable (${row.error})`);
      continue;
    }
    lines.push(`- ${row.model}: Rule ${row.rule} (${row.classLabel}) | vol trend: ${row.volatilityTrend}`);
  }
  const ok=modelSummaries.filter(row=>!row.error);
  if(!ok.length){
    lines.push("-> No successful CA fingerprints were produced.");
    return lines.join("\n");
  }
  const classMode=modeValue(ok.map(row=>row.classKey));
  if(classMode.value){
    lines.push(`-> ${classMode.count}/${ok.length} models agree on ${classMode.value} regime.`);
  }
  const ruleMode=modeValue(ok.map(row=>row.rule));
  if(ruleMode.value!==null&&ruleMode.value!==""){
    lines.push(`-> Rule agreement: ${ruleMode.count}/${ok.length} models share Rule ${clampInt(Number(ruleMode.value)||0,0,255)}.`);
  }
  const trendMode=modeValue(ok.map(row=>row.volatilityTrend));
  if(trendMode.value){
    lines.push(`-> Volatility trend agreement: ${trendMode.count}/${ok.length} models are ${trendMode.value}.`);
  }
  const dominantClassNo=extractWolframClassNumber(null,classMode.value);
  if(Number.isFinite(Number(dominantClassNo))){
    const lower=ok.filter(row=>Number.isFinite(Number(row.classNo))&&Number(row.classNo)<Number(dominantClassNo));
    if(lower.length){
      lines.push(`-> ${lower.map(row=>row.model).join(", ")} shows a lower-class regime, suggesting more collapsed inter-probe tension.`);
    }
  }
  return lines.join("\n");
}

export async function deriveReplicationCAFingerprint(target,cfg,probeResults,synthResult,terms,citations){
  if(!cfg?.enableComputationalIrreducibility) return null;
  const llmDiscs=DISCS.filter(d=>d?.kind!=="ca");
  const runTerms=Array.isArray(terms)?terms:[];
  const runCitations=Array.isArray(citations)?citations:[];
  let discSimilarityMatrix=null;
  if(runTerms.length){
    try{
      discSimilarityMatrix=await computeRunDiscSimilarityMatrixForTerms(target,runTerms,cfg,llmDiscs);
    }catch(err){
      console.warn("Replication CA fingerprint: similarity matrix derivation failed; using fallback hash.",err);
      discSimilarityMatrix=null;
    }
  }
  const groundingStats=computeGroundingStats(runTerms,runCitations,[]);
  const prevCAOutput=CA_PROBE_OUTPUT;
  try{
    const caCfg={...cfg,wolframAppId:""};
    const caResult=await deriveCAFromRun(target,caCfg,probeResults,synthResult,{
      discSimilarityMatrix,
      groundingStats,
      terms:runTerms,
      citations:runCitations,
      groundingDiagnostics:[],
      discs:llmDiscs
    });
    if(!caResult||typeof caResult!=="object") return null;
    const ruleMeta=caResult?.derivation?.rule&&typeof caResult.derivation.rule==="object"?caResult.derivation.rule:{};
    return {
      rule:clampInt(Number(caResult?.rule)||0,0,255),
      wolframClass:Number.isFinite(Number(ruleMeta?.wolframClass))?Number(ruleMeta.wolframClass):null,
      wolframClassLabel:String(ruleMeta?.wolframClassLabel||"unclassified (likely Class 2 or 3)"),
      volatilityTrend:String(caResult?.trajectories?.volatilityTrend||"stable"),
      densityTrend:String(caResult?.trajectories?.densityTrend||"stable"),
      spreadTrend:String(caResult?.trajectories?.spreadTrend||"stable"),
      derivationSource:String(ruleMeta?.source||"fallback_hash"),
      densityFinal:Number(caResult?.metrics?.densityFinal??caResult?.metrics?.density??0)||0,
      volatilityFinal:Number(caResult?.metrics?.volatilityFinal??caResult?.metrics?.volatility??0)||0,
      spreadFinal:Number(caResult?.metrics?.spreadFinal??caResult?.metrics?.spread??0)||0
    };
  }finally{
    CA_PROBE_OUTPUT=prevCAOutput;
  }
}

export function buildRunDerivedCommentary(params={}){
  const rule=clampInt(Number(params?.rule),0,255);
  const target=String(params?.target||"this target").trim()||"this target";
  const termCount=clampInt(Number(params?.termCount)||0,0,99999);
  const width=clampInt(Number(params?.width)||0,0,99999);
  const steps=clampInt(Number(params?.steps)||0,0,99999);
  const discNames=Array.isArray(params?.discNames)?params.discNames.map(x=>String(x||"").trim()).filter(Boolean):[];
  const probeSegments=Array.isArray(params?.probeSegments)?params.probeSegments:[];
  const synth=params?.synthResult&&typeof params.synthResult==="object"?params.synthResult:{};
  const groundingStats=params?.groundingStats&&typeof params.groundingStats==="object"?params.groundingStats:{};
  const stepsBreakdown=params?.stepsBreakdown&&typeof params.stepsBreakdown==="object"?params.stepsBreakdown:{};
  const trajectories=params?.trajectories&&typeof params.trajectories==="object"?params.trajectories:{};
  const ruleDerivation=params?.ruleDerivation&&typeof params.ruleDerivation==="object"?params.ruleDerivation:{derivation:String(params?.ruleDerivation||"manual_config")};
  const classFromParam=params?.wolframClass;
  const classMeta=Number.isInteger(Number(classFromParam))?{wolframClass:Number(classFromParam),wolframClassLabel:`Class ${Number(classFromParam)}`}:(estimateWolframRuleClass(rule)||{wolframClass:null,wolframClassLabel:"unclassified (likely Class 2 or 3)"});
  const classLabel=String(params?.wolframClassLabel||classMeta?.wolframClassLabel||"unclassified (likely Class 2 or 3)");
  const pct=(value,digits=0)=>`${(Math.max(0,Math.min(1,Number(value)||0))*100).toFixed(digits)}%`;
  const numberOr=(value,fallback=0)=>Number.isFinite(Number(value))?Number(value):fallback;
  const toSeries=(value)=>Array.isArray(value)?value:(ArrayBuffer.isView(value)?Array.from(value):[]);
  const densityFinal=numberOr(trajectories.densityFinal,numberOr(trajectories.density,0));
  const volatilityFinal=numberOr(trajectories.volatilityFinal,numberOr(trajectories.volatility,0));
  const spreadFinal=numberOr(trajectories.spreadFinal,numberOr(trajectories.spread,0));
  const densityTrend=String(trajectories.densityTrend||classifyTrajectoryTrend(toSeries(trajectories.density))).trim()||"stable";
  const volatilityTrend=String(trajectories.volatilityTrend||classifyTrajectoryTrend(toSeries(trajectories.volatility))).trim()||"stable";
  const spreadTrend=String(trajectories.spreadTrend||classifyTrajectoryTrend(toSeries(trajectories.spread))).trim()||"stable";
  const selectedPairs=Array.isArray(ruleDerivation?.selectedPairs)?ruleDerivation.selectedPairs.filter(item=>item&&Number.isFinite(Number(item.distance))):[];
  const topDistancePair=[...selectedPairs].sort((a,b)=>Number(b.distance)-Number(a.distance))[0]||null;
  const derivationType=String(ruleDerivation?.derivation||"manual_config").trim().toLowerCase();
  const probeNameByAbbr=new Map(DISCS.map(d=>[toCanonicalKey(d?.abbr||""),String(d?.name||"").trim()]));
  const resolveProbeLabel=(label)=>{
    const text=String(label||"").trim();
    if(!text) return text;
    const mapped=probeNameByAbbr.get(toCanonicalKey(text));
    return mapped||text;
  };
  const ruleSentence=(()=>{
    if(derivationType==="similarity_matrix"){
      if(topDistancePair){
        const a=resolveProbeLabel(topDistancePair.probeA);
        const b=resolveProbeLabel(topDistancePair.probeB);
        const dist=Number(topDistancePair.distance).toFixed(3);
        const median=Number.isFinite(Number(ruleDerivation?.medianDistance))?` around a median distance of ${Number(ruleDerivation.medianDistance).toFixed(3)}`:"";
        return `This expedition's tension topology maps to Rule ${rule} (${classLabel}), derived from disc-similarity extremes${median}; the highest-tension pair is ${a} vs ${b} (distance ${dist}).`;
      }
      return `This expedition's tension topology maps to Rule ${rule} (${classLabel}), derived from disc-similarity distance extremes.`;
    }
    if(derivationType==="fallback_hash"){
      return `This expedition maps to Rule ${rule} (${classLabel}) via deterministic fallback hashing because similarity-matrix diagnostics were unavailable.`;
    }
    return `This expedition uses Rule ${rule} (${classLabel}) under ${derivationType.replace(/_/g," ")} derivation.`;
  })();
  const initialSentence=(()=>{
    if(!probeSegments.length){
      const probeCount=Math.max(1,discNames.length||DISCS.filter(d=>d?.kind!=="ca").length||1);
      return `Initial conditions use a centered seed across width ${width||"(unspecified)"} with ${probeCount} probe lenses and ${termCount} terms in scope.`;
    }
    const ranked=[...probeSegments].map(seg=>({
      name:String(seg?.name||`Probe ${Number(seg?.probeId)+1}`),
      seedDensity:Math.max(0,Math.min(1,Number(seg?.seedDensity)||0))
    })).sort((a,b)=>b.seedDensity-a.seedDensity);
    const top=ranked.slice(0,2).map(item=>`${item.name} (${pct(item.seedDensity,0)} seed density)`).join(" and ");
    const sparse=ranked[ranked.length-1]?`${ranked[ranked.length-1].name} (${pct(ranked[ranked.length-1].seedDensity,0)})`:"";
    const probeCount=Math.max(1,probeSegments.length);
    return `${probeCount} probes seed the initial row asymmetrically across width ${width}: ${top}${sparse?`, while ${sparse} is sparsest`:""}.`;
  })();
  const stepsSentence=(()=>{
    const breakdownBits=[];
    const c=clampInt(Number(stepsBreakdown?.convergent)||0,0,9999);
    const k=clampInt(Number(stepsBreakdown?.contradictory)||0,0,9999);
    const e=clampInt(Number(stepsBreakdown?.emergent)||0,0,9999);
    const v=clampInt(Number(stepsBreakdown?.evidence)||0,0,9999);
    const g=clampInt(Number(stepsBreakdown?.coverage)||0,0,9999);
    if(c) breakdownBits.push(`${c} convergent-bonus`);
    if(k) breakdownBits.push(`${k} contradiction-bonus`);
    if(e) breakdownBits.push(`${e} emergent-bonus`);
    if(v) breakdownBits.push(`${v} evidence-bonus`);
    if(g) breakdownBits.push(`${g} coverage-bonus`);
    const breakdownText=breakdownBits.length?` (${breakdownBits.join(", ")})`:"";
    return `After ${steps} steps${breakdownText}, the pattern ends at ${pct(densityFinal,0)} density, ${pct(volatilityFinal,0)} volatility, and ${pct(spreadFinal,0)} spread.`;
  })();
  const trajectorySentence=`Trajectory signals: density is ${densityTrend}, volatility is ${volatilityTrend}, and spread is ${spreadTrend}.`;
  const boundarySentence=(()=>{
    const boundaryActivity=trajectories?.boundaryActivity&&typeof trajectories.boundaryActivity==="object"?trajectories.boundaryActivity:{};
    const candidates=[];
    for(const [idxRaw,series] of Object.entries(boundaryActivity)){
      const idx=Number(idxRaw);
      const arr=toSeries(series).map(v=>Number(v)).filter(Number.isFinite);
      const mean=averageNumbers(arr);
      if(!Number.isInteger(idx)||mean===null) continue;
      candidates.push({idx,mean});
    }
    candidates.sort((a,b)=>b.mean-a.mean);
    const topBoundary=candidates[0]||null;
    if(topBoundary&&probeSegments[topBoundary.idx]&&probeSegments[topBoundary.idx+1]){
      const left=String(probeSegments[topBoundary.idx]?.name||`Probe ${topBoundary.idx+1}`);
      const right=String(probeSegments[topBoundary.idx+1]?.name||`Probe ${topBoundary.idx+2}`);
      const boundaryText=`Boundary activity peaks between ${left} and ${right} (${pct(topBoundary.mean,0)} mean local activation)`;
      if(topDistancePair){
        const a=resolveProbeLabel(topDistancePair.probeA);
        const b=resolveProbeLabel(topDistancePair.probeB);
        return `${boundaryText}; the highest-distance rule pair (${a} vs ${b}) indicates this interface is a key irreducibility hotspot.`;
      }
      return `${boundaryText}, indicating persistent interface churn.`;
    }
    if(topDistancePair){
      const a=resolveProbeLabel(topDistancePair.probeA);
      const b=resolveProbeLabel(topDistancePair.probeB);
      return `Highest-distance pair ${a} vs ${b} (distance ${Number(topDistancePair.distance).toFixed(3)}) marks the strongest cross-probe tension interface in this run.`;
    }
    return "Boundary-activity diagnostics are limited for this run, but aggregate trajectories still indicate interaction-regime drift over time.";
  })();
  const epistemicSentence=(()=>{
    const convergentCount=Array.isArray(synth?.convergent)?synth.convergent.length:0;
    const contradictoryCount=Array.isArray(synth?.contradictory)?synth.contradictory.length:0;
    const emergentCount=Array.isArray(synth?.emergent)?synth.emergent.length:0;
    const avgCites=Number(groundingStats?.avgCitationsPerNode);
    const evidenceNote=Number.isFinite(avgCites)?`with ${avgCites.toFixed(2)} citations/node`:"with sparse citation diagnostics";
    const regime=volatilityFinal>=0.38||volatilityTrend==="increasing"?"computationally irreducible and turbulence-prone":spreadFinal>=0.6?"diffusive and integrative across probe boundaries":"comparatively bounded and locally stable";
    return `Epistemic character for "${target}": ${regime}, shaped by ${convergentCount} convergences, ${contradictoryCount} contradictions, ${emergentCount} emergent insights, ${evidenceNote}.`;
  })();
  return [ruleSentence,initialSentence,stepsSentence,trajectorySentence,boundarySentence,epistemicSentence].filter(Boolean).join("\n\n");
}

export function buildCATermsFromMetrics(caOutput){
  const out=caOutput&&typeof caOutput==="object"?caOutput:{};
  const rule=clampInt(Number(out.rule)||0,0,255);
  const metrics=out?.metrics&&typeof out.metrics==="object"?out.metrics:{};
  const density=Number.isFinite(Number(metrics?.density))?Number(metrics.density):0;
  const volatility=Number.isFinite(Number(metrics?.volatility))?Number(metrics.volatility):0;
  const spread=Number.isFinite(Number(metrics?.spread))?Number(metrics.spread):0;
  const syntheticGrounding=normalizeGroundingBlock({groundingEligibility:"synthetic_local",groundingSkipReason:"Run-derived CA diagnostic term computed locally from expedition outputs."},{defaultStatus:"not_attempted"});
  return [
    {
      label:`Rule ${rule} Local Interaction Dynamics`,
      centrality:0.96,
      description:"Run-derived elementary update rule where each cell depends on nearest-neighbor state.",
      descriptions:{synthesisSummary:"Run-derived elementary update rule where each cell depends on nearest-neighbor state."},
      description_source:"synthesis",
      description_provenance:[{source:"synthesis",stage:"ca_diagnostic",note:"Derived from post-synthesis CA diagnostic fingerprint."}],
      grounding:syntheticGrounding
    },
    {
      label:"Diffusion Bandwidth",
      centrality:0.78,
      description:`Active-cell spread ratio across rows: ${(spread*100).toFixed(1)}%.`,
      descriptions:{synthesisSummary:`Active-cell spread ratio across rows: ${(spread*100).toFixed(1)}%.`},
      description_source:"synthesis",
      description_provenance:[{source:"synthesis",stage:"ca_diagnostic",note:"Derived from run CA spread metric."}],
      grounding:syntheticGrounding
    },
    {
      label:"Transition Volatility",
      centrality:0.82,
      description:`Adjacent-state transition ratio: ${(volatility*100).toFixed(1)}%.`,
      descriptions:{synthesisSummary:`Adjacent-state transition ratio: ${(volatility*100).toFixed(1)}%.`},
      description_source:"synthesis",
      description_provenance:[{source:"synthesis",stage:"ca_diagnostic",note:"Derived from run CA volatility metric."}],
      grounding:syntheticGrounding
    },
    {
      label:"Computational Irreducibility",
      centrality:0.9,
      description:`Run-derived CA regime density ${(density*100).toFixed(1)}%, indicating iterative interaction effects dominate closed-form shortcuts.`,
      descriptions:{synthesisSummary:`Run-derived CA regime density ${(density*100).toFixed(1)}%, indicating iterative interaction effects dominate closed-form shortcuts.`},
      description_source:"synthesis",
      description_provenance:[{source:"synthesis",stage:"ca_diagnostic",note:"Derived from run-level CA diagnostic commentary."}],
      grounding:syntheticGrounding
    }
  ];
}

export function appendDerivedCATermsToTerms(caTerms){
  const terms=Array.isArray(caTerms)?caTerms:[];
  if(!terms.length) return 0;
  const rng=new RNG(PROJECTION_BASE_SEED+1979);
  let added=0;
  for(const raw of terms){
    const label=String(raw?.label||"").trim();
    if(!label) continue;
    const existing=TERMS.find(t=>toCanonicalKey(t?.label||"")===toCanonicalKey(label));
    const baseSource=String(raw?.description_source||"").trim().toLowerCase()||"synthesis";
    const descriptions=normalizeTermDescriptions(raw?.descriptions,{fallbackDescription:String(raw?.description||""),fallbackSource:baseSource,label});
    const node={
      label,
      descriptions,
      description:String(descriptions.displayDescription||raw?.description||"").trim(),
      centrality:clamp01(Number(raw?.centrality??0.5)),
      slices:[],
      type:"emergent",
      pos:[rng.jitter(0.18),rng.jitter(0.18),rng.jitter(0.18)],
      citations:[],
      aliases:[],
      description_source:inferDescriptionSourceFromLayers(descriptions,baseSource),
      description_provenance:mergeDescriptionProvenance(raw?.description_provenance,[{source:baseSource,stage:"ca_diagnostic",note:"Run-derived CA diagnostic term appended post-synthesis."}]),
      grounding:normalizeGroundingBlock(raw?.grounding,{defaultStatus:"not_attempted"})
    };
    if(existing){
      existing.descriptions=mergeTermDescriptions(existing.descriptions,node.descriptions,node.label);
      existing.description=String(existing.descriptions.displayDescription||mergeDescription(existing.description,node.description)).trim();
      existing.centrality=Math.max(Number(existing.centrality||0),Number(node.centrality||0));
      existing.type=mergeType(existing.type,node.type);
      existing.description_source=inferDescriptionSourceFromLayers(existing.descriptions,mergeDescriptionSource(existing.description_source,node.description_source));
      existing.description_provenance=mergeDescriptionProvenance(existing.description_provenance,node.description_provenance);
      existing.grounding=mergeGroundingBlocks(existing.grounding,node.grounding);
      continue;
    }
    TERMS.push(node);
    added++;
  }
  refreshTermSignalFields(TERMS);
  return added;
}

export async function deriveCAFromRun(target,cfg,probeResults,synthResult,embeddingDiagnostics){
  if(!cfg?.enableComputationalIrreducibility){
    CA_PROBE_OUTPUT=null;
    return null;
  }
  const diagnostics=embeddingDiagnostics&&typeof embeddingDiagnostics==="object"?embeddingDiagnostics:{};
  const llmDiscs=(Array.isArray(diagnostics?.discs)?diagnostics.discs:DISCS).filter(d=>d?.kind!=="ca");
  const runTerms=Array.isArray(diagnostics?.terms)?diagnostics.terms:TERMS;
  const runCitations=Array.isArray(diagnostics?.citations)?diagnostics.citations:CITATIONS;
  const runGroundingDiagnostics=Array.isArray(diagnostics?.groundingDiagnostics)?diagnostics.groundingDiagnostics:WOLFRAM_GROUNDING_DIAGNOSTICS;
  const groundingStats=diagnostics?.groundingStats&&typeof diagnostics.groundingStats==="object"?diagnostics.groundingStats:computeGroundingStats(runTerms,runCitations,runGroundingDiagnostics);
  const similarityMatrix=diagnostics?.discSimilarityMatrix&&typeof diagnostics.discSimilarityMatrix==="object"
    ?diagnostics.discSimilarityMatrix
    :diagnostics?.similarityMatrix&&typeof diagnostics.similarityMatrix==="object"
      ?diagnostics.similarityMatrix
      :(DISC_SIM_MATRIX&&typeof DISC_SIM_MATRIX==="object"?DISC_SIM_MATRIX:null);
  const derivedRuleDerivation=deriveRuleFromSimilarityMatrix(similarityMatrix,{probeCount:llmDiscs.length,termCount:runTerms.length,synthResult});
  const derivedWidthDerivation=deriveWidthFromTermCount(runTerms);
  const derivedStepsDerivation=deriveStepsFromSynthesisDepth(synthResult,runTerms,groundingStats);
  const ruleOverride=Number.isFinite(Number(cfg?.caRuleOverride))?clampInt(Number(cfg.caRuleOverride),0,255):Number.isFinite(Number(cfg?.caRule))?clampInt(Number(cfg.caRule),0,255):null;
  const stepsOverride=Number.isFinite(Number(cfg?.caStepsOverride))?clampInt(Number(cfg.caStepsOverride),16,240):Number.isFinite(Number(cfg?.caSteps))?clampInt(Number(cfg.caSteps),16,240):null;
  const widthOverride=Number.isFinite(Number(cfg?.caWidthOverride))?clampInt(Number(cfg.caWidthOverride),31,401):Number.isFinite(Number(cfg?.caWidth))?clampInt(Number(cfg.caWidth),31,401):null;
  const resolvedRule=ruleOverride??derivedRuleDerivation.rule;
  const resolvedWidth=widthOverride??derivedWidthDerivation.width;
  const resolvedSteps=stepsOverride??derivedStepsDerivation.steps;
  const ruleDerivation=ruleOverride===null
    ?derivedRuleDerivation
    :{...derivedRuleDerivation,rule:resolvedRule,derivation:"manual_override",manualOverride:true,derivedRule:derivedRuleDerivation.rule,derivedSource:derivedRuleDerivation.derivation};
  const stepsDerivation=stepsOverride===null
    ?derivedStepsDerivation
    :{...derivedStepsDerivation,steps:resolvedSteps,manualOverride:true,derivedSteps:derivedStepsDerivation.steps};
  const widthDerivation=widthOverride===null
    ?derivedWidthDerivation
    :{...derivedWidthDerivation,width:resolvedWidth,manualOverride:true,derivedWidth:derivedWidthDerivation.width};
  const rowDerivation=buildInitialRowFromProbes(llmDiscs,runTerms,probeResults,resolvedWidth);
  const sim=simulateElementaryCA(resolvedRule,resolvedSteps,resolvedWidth,rowDerivation.initialRow);
  const metrics=computeAutomataMetrics(sim,rowDerivation.probeSegments);
  const imageUrl=renderAutomataDataUrl(sim,rowDerivation.probeSegments);
  const query=`CellularAutomaton[${sim.rule}, {${Array.from(rowDerivation.initialRow).join(",")}}, {${sim.steps}, ${sim.width}}]`;
  let wolframNote="";
  if(cfg?.wolframAppId&&normalizeMode(cfg)==="proxy"){
    try{
      const data=await fetchWolframJSON(query,cfg,{target,discName:"Computational Irreducibility",termLabel:`Rule ${sim.rule} Local Interaction Dynamics`,resolutionLabel:"ca_run_derived"});
      const parsed=extractWolframStructured(data);
      const selected=selectWolframSnippetFromParsed(parsed);
      const txt=String(selected?.snippet||"").trim();
      if(txt) wolframNote=` Wolfram returned: ${txt.slice(0,180)}.`;
      if(Array.isArray(parsed.didYouMeans)&&parsed.didYouMeans.length) wolframNote+=` Interpretation alternatives: ${parsed.didYouMeans.slice(0,3).join(", ")}.`;
    }catch(err){
      wolframNote=` Wolfram call failed: ${err.message||err}.`;
    }
  }else if(cfg?.wolframAppId&&normalizeMode(cfg)!=="proxy"){
    wolframNote=" Wolfram lookup skipped in direct mode (CORS).";
  }
  const commentary=`${buildRunDerivedCommentary({
    rule:sim.rule,
    ruleDerivation,
    wolframClass:ruleDerivation?.wolframClass,
    wolframClassLabel:ruleDerivation?.wolframClassLabel,
    steps:sim.steps,
    stepsBreakdown:stepsDerivation.breakdown,
    width:sim.width,
    termCount:widthDerivation.termCount,
    probeSegments:rowDerivation.probeSegments,
    trajectories:{
      density:metrics?.trajectories?.density,
      volatility:metrics?.trajectories?.volatility,
      spread:metrics?.trajectories?.spread,
      probeActivity:metrics?.probeActivity,
      boundaryActivity:metrics?.boundaryActivity,
      densityFinal:metrics?.densityFinal,
      volatilityFinal:metrics?.volatilityFinal,
      spreadFinal:metrics?.spreadFinal,
      densityTrend:metrics?.densityTrend,
      volatilityTrend:metrics?.volatilityTrend,
      spreadTrend:metrics?.spreadTrend
    },
    target,
    discNames:llmDiscs.map(d=>d?.name).filter(Boolean),
    synthResult,
    groundingStats
  })}${wolframNote}`.trim();
  const toNumberSeries=(series)=>ArrayBuffer.isView(series)?Array.from(series,value=>Number(value)||0):Array.isArray(series)?series.map(value=>Number(value)||0):[];
  const toSeriesMap=(input)=>{
    const out={};
    const src=input&&typeof input==="object"?input:{};
    for(const [key,value] of Object.entries(src)){
      out[key]=toNumberSeries(value);
    }
    return out;
  };
  const aggregateDensity=Number.isFinite(Number(metrics?.density))?Number(metrics.density):0;
  const aggregateVolatility=Number.isFinite(Number(metrics?.volatility))?Number(metrics.volatility):0;
  const aggregateSpread=Number.isFinite(Number(metrics?.spread))?Number(metrics.spread):0;
  const normalizedMetrics={
    density:aggregateDensity,
    volatility:aggregateVolatility,
    spread:aggregateSpread,
    densityFinal:aggregateDensity,
    volatilityFinal:aggregateVolatility,
    spreadFinal:aggregateSpread
  };
  const trajectoryDensity=toNumberSeries(metrics?.trajectories?.density);
  const trajectoryVolatility=toNumberSeries(metrics?.trajectories?.volatility);
  const trajectorySpread=toNumberSeries(metrics?.trajectories?.spread);
  const normalizedTrajectories={
    density:trajectoryDensity,
    volatility:trajectoryVolatility,
    spread:trajectorySpread,
    probeActivity:toSeriesMap(metrics?.probeActivity),
    boundaryActivity:toSeriesMap(metrics?.boundaryActivity),
    densityTrend:String(metrics?.densityTrend||classifyTrajectoryTrend(trajectoryDensity)||"stable"),
    volatilityTrend:String(metrics?.volatilityTrend||classifyTrajectoryTrend(trajectoryVolatility)||"stable"),
    spreadTrend:String(metrics?.spreadTrend||classifyTrajectoryTrend(trajectorySpread)||"stable")
  };
  const knownClassLabel=KNOWN_RULE_CLASSES?.[sim.rule]?.label||"";
  const rawClassLabel=String(ruleDerivation?.wolframClassLabel||"").trim();
  const classLabelFromParens=rawClassLabel.match(/\(([^)]+)\)/)?.[1]||"";
  const normalizedClassLabel=knownClassLabel||String(classLabelFromParens||rawClassLabel||"unclassified (likely Class 2 or 3)").trim();
  const normalizedSelectedPairs=(Array.isArray(ruleDerivation?.selectedPairs)?ruleDerivation.selectedPairs:[]).map(pair=>({
    probeA:String(pair?.probeA||""),
    probeB:String(pair?.probeB||""),
    distance:Number.isFinite(Number(pair?.distance))?Number(pair.distance):0,
    bit:clampInt(Number(pair?.bit)||0,0,1)
  }));
  const derivation={
    rule:{
      source:String(ruleDerivation?.derivation||"fallback_hash"),
      medianDistance:Number.isFinite(Number(ruleDerivation?.medianDistance))?Number(ruleDerivation.medianDistance):null,
      selectedPairs:normalizedSelectedPairs,
      wolframClass:Number.isFinite(Number(ruleDerivation?.wolframClass))?Number(ruleDerivation.wolframClass):null,
      wolframClassLabel:normalizedClassLabel
    },
    steps:{
      base:clampInt(Number(stepsDerivation?.breakdown?.base)||0,0,9999),
      convergentBonus:clampInt(Number(stepsDerivation?.breakdown?.convergent)||0,0,9999),
      contradictoryBonus:clampInt(Number(stepsDerivation?.breakdown?.contradictory)||0,0,9999),
      emergentBonus:clampInt(Number(stepsDerivation?.breakdown?.emergent)||0,0,9999),
      evidenceBonus:clampInt(Number(stepsDerivation?.breakdown?.evidence)||0,0,9999),
      coverageBonus:clampInt(Number(stepsDerivation?.breakdown?.coverage)||0,0,9999)
    },
    width:{
      termCount:clampInt(Number(widthDerivation?.termCount)||0,0,999999)
    },
    initialRow:{
      probeSegments:(Array.isArray(rowDerivation?.probeSegments)?rowDerivation.probeSegments:[]).map(seg=>({
        probeId:Number.isFinite(Number(seg?.probeId))?Number(seg.probeId):0,
        name:String(seg?.name||""),
        start:clampInt(Number(seg?.start)||0,0,sim.width),
        end:clampInt(Number(seg?.end)||0,0,sim.width),
        seedDensity:clamp01(Number(seg?.seedDensity)||0)
      }))
    }
  };
  const out={
    rule:sim.rule,
    steps:sim.steps,
    width:sim.width,
    derivation,
    grid:Array.isArray(sim.grid)?sim.grid.map(row=>Array.isArray(row)?row.map(cell=>Number(cell)===1?1:0):[]):[],
    query,
    imageUrl,
    commentary,
    generatedAt:new Date().toISOString(),
    metrics:normalizedMetrics,
    trajectories:normalizedTrajectories,
    probeActivity:normalizedTrajectories.probeActivity,
    boundaryActivity:normalizedTrajectories.boundaryActivity,
    ruleDerivation,
    widthDerivation,
    stepsDerivation,
    initialRow:Array.from(rowDerivation.initialRow),
    probeSegments:rowDerivation.probeSegments,
    groundingStatsSnapshot:groundingStats,
    embeddingDiagnosticsSnapshot:structuredCloneSafe({similarityMatrix,discSimilarityMatrix:similarityMatrix,projectionStability:diagnostics?.projectionStability??PROJECTION_STABILITY})
  };
  CA_PROBE_OUTPUT=out;
  return out;
}
