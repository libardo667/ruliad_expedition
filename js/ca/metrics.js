import { clampInt } from '../core/utils.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Module: js/ca/metrics.js

export function modeValue(values){
  const counts=new Map();
  let bestValue=null;
  let bestCount=0;
  for(const raw of (Array.isArray(values)?values:[])){
    const value=raw===null||raw===undefined?"":String(raw);
    const count=(counts.get(value)||0)+1;
    counts.set(value,count);
    if(count>bestCount){bestCount=count;bestValue=value;}
  }
  return {value:bestValue,count:bestCount,total:Array.isArray(values)?values.length:0};
}

export function medianOfNumbers(values){
  const nums=(Array.isArray(values)?values:[]).map(v=>Number(v)).filter(Number.isFinite).sort((a,b)=>a-b);
  if(!nums.length) return null;
  const mid=Math.floor(nums.length/2);
  if(nums.length%2===1) return nums[mid];
  return (nums[mid-1]+nums[mid])/2;
}

export function maxContiguousAliveRun(row){
  const safeRow=Array.isArray(row)?row:[];
  let best=0;
  let current=0;
  for(let i=0;i<safeRow.length;i++){
    if(Number(safeRow[i])===1){
      current++;
      if(current>best) best=current;
    }else{
      current=0;
    }
  }
  return best;
}

export function trajectoryLinearRegressionSlope(values){
  const arr=Array.isArray(values)?values.map(v=>Number(v)).filter(Number.isFinite):[];
  const n=arr.length;
  if(n<2) return 0;
  const meanX=(n-1)/2;
  const meanY=arr.reduce((sum,v)=>sum+v,0)/n;
  let numer=0;
  let denom=0;
  for(let i=0;i<n;i++){
    const dx=i-meanX;
    numer+=dx*(arr[i]-meanY);
    denom+=dx*dx;
  }
  return denom>0?numer/denom:0;
}

export function countMeanZeroCrossings(values){
  const arr=Array.isArray(values)?values.map(v=>Number(v)).filter(Number.isFinite):[];
  if(arr.length<2) return 0;
  const mean=arr.reduce((sum,v)=>sum+v,0)/arr.length;
  let prevSign=0;
  let crossings=0;
  for(const value of arr){
    const centered=value-mean;
    const sign=centered>0?1:(centered<0?-1:0);
    if(sign===0) continue;
    if(prevSign!==0&&sign!==prevSign) crossings++;
    prevSign=sign;
  }
  return crossings;
}

export function classifyTrajectoryTrend(values,{slopeThreshold=0.001}={}){
  const arr=Array.isArray(values)?values.map(v=>Number(v)).filter(Number.isFinite):[];
  if(arr.length<2) return "stable";
  const slope=trajectoryLinearRegressionSlope(arr);
  const oscillation=countMeanZeroCrossings(arr);
  if(Math.abs(slope)<slopeThreshold&&oscillation>(arr.length/4)) return "oscillating";
  if(slope>slopeThreshold) return "increasing";
  if(slope<-slopeThreshold) return "decreasing";
  return "stable";
}

export function computeMetricTrajectories(grid,probeSegments){
  const safeGrid=Array.isArray(grid)?grid:[];
  const steps=safeGrid.length;
  const width=steps?Math.max(1,Array.isArray(safeGrid[0])?safeGrid[0].length:0):0;
  const safeSegments=Array.isArray(probeSegments)?probeSegments:[];
  const density=new Float32Array(steps);
  const volatility=new Float32Array(steps);
  const spread=new Float32Array(steps);
  const probeActivity={};
  for(const seg of safeSegments){
    const probeId=Number.isInteger(Number(seg?.probeId))?Number(seg.probeId):0;
    probeActivity[probeId]=new Float32Array(steps);
  }
  const boundaryActivity={};
  for(let i=0;i<Math.max(0,safeSegments.length-1);i++){
    boundaryActivity[i]=new Float32Array(steps);
  }
  for(let y=0;y<steps;y++){
    const row=Array.isArray(safeGrid[y])?safeGrid[y]:[];
    const rowWidth=Math.max(1,width||row.length||1);
    let aliveCount=0;
    let transitionCount=0;
    for(let x=0;x<rowWidth;x++){
      const value=Number(row[x])===1?1:0;
      if(value===1) aliveCount++;
      if(x>0){
        const prev=Number(row[x-1])===1?1:0;
        if(prev!==value) transitionCount++;
      }
    }
    density[y]=aliveCount/rowWidth;
    volatility[y]=transitionCount/rowWidth;
    spread[y]=maxContiguousAliveRun(row)/rowWidth;
    for(const seg of safeSegments){
      const probeId=Number.isInteger(Number(seg?.probeId))?Number(seg.probeId):0;
      const start=clampInt(Number(seg?.start)||0,0,rowWidth);
      const end=clampInt(Number(seg?.end)||0,0,rowWidth);
      const segWidth=Math.max(1,end-start);
      let segAlive=0;
      for(let x=start;x<end;x++){
        if(Number(row[x])===1) segAlive++;
      }
      if(!probeActivity[probeId]) probeActivity[probeId]=new Float32Array(steps);
      probeActivity[probeId][y]=segAlive/segWidth;
    }
    for(let i=0;i<Math.max(0,safeSegments.length-1);i++){
      const boundary=clampInt(Number(safeSegments[i]?.end)||0,0,rowWidth);
      const zoneStart=Math.max(0,boundary-3);
      const zoneEnd=Math.min(rowWidth,boundary+4);
      const zoneWidth=Math.max(1,zoneEnd-zoneStart);
      let zoneAlive=0;
      for(let x=zoneStart;x<zoneEnd;x++){
        if(Number(row[x])===1) zoneAlive++;
      }
      if(!boundaryActivity[i]) boundaryActivity[i]=new Float32Array(steps);
      boundaryActivity[i][y]=zoneAlive/zoneWidth;
    }
  }
  const densityArr=Array.from(density);
  const volatilityArr=Array.from(volatility);
  const spreadArr=Array.from(spread);
  return {
    density,
    volatility,
    spread,
    probeActivity,
    boundaryActivity,
    densityFinal:steps?density[steps-1]:0,
    volatilityFinal:steps?volatility[steps-1]:0,
    spreadFinal:steps?spread[steps-1]:0,
    densityTrend:classifyTrajectoryTrend(densityArr),
    volatilityTrend:classifyTrajectoryTrend(volatilityArr),
    spreadTrend:classifyTrajectoryTrend(spreadArr)
  };
}

export function computeAutomataMetrics(sim,probeSegments){
  const grid=Array.isArray(sim?.grid)?sim.grid:[];
  const simWidth=Math.max(1,Number(sim?.width)||0);
  const total=grid.length*simWidth;
  let alive=0;
  let transitions=0;
  let band=0;
  for(const row of grid){
    let rowAlive=0;
    for(let i=0;i<row.length;i++){
      if(row[i]){alive++;rowAlive++;}
      if(i>0&&row[i]!==row[i-1]) transitions++;
    }
    band=Math.max(band,rowAlive);
  }
  const density=total?alive/total:0;
  const volatility=total?transitions/total:0;
  const spread=simWidth?band/simWidth:0;
  const out={density,volatility,spread};
  if(probeSegments!==undefined&&probeSegments!==null){
    const trajectories=computeMetricTrajectories(grid,probeSegments);
    out.trajectories={
      density:trajectories.density,
      volatility:trajectories.volatility,
      spread:trajectories.spread
    };
    out.probeActivity=trajectories.probeActivity;
    out.boundaryActivity=trajectories.boundaryActivity;
    out.densityFinal=trajectories.densityFinal;
    out.volatilityFinal=trajectories.volatilityFinal;
    out.spreadFinal=trajectories.spreadFinal;
    out.densityTrend=trajectories.densityTrend;
    out.volatilityTrend=trajectories.volatilityTrend;
    out.spreadTrend=trajectories.spreadTrend;
  }
  return out;
}
