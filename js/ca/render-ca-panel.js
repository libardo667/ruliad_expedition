import { CA_PROBE_OUTPUT, DISCS } from '../core/state.js';
import { clampInt, escapeHtml } from '../core/utils.js';
import { isRunDerivedCAOutput } from './automata.js';
import { clamp01 } from '../plot/plot-overlays.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Module: js/ca/render-ca-panel.js

export function renderAutomataDataUrl(sim,probeSegments){
  const grid=sim?.grid||[];
  const w=sim?.width||0;
  const h=sim?.steps||0;
  if(!w||!h) return "";
  const scale=Math.max(1,Math.floor(360/Math.max(w,h)));
  const canvas=document.createElement("canvas");
  canvas.width=w*scale;
  canvas.height=h*scale;
  const ctx=canvas.getContext("2d");
  ctx.fillStyle="#ffffff";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle="#111827";
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      if(grid[y]?.[x]) ctx.fillRect(x*scale,y*scale,scale,scale);
    }
  }
  if(Array.isArray(probeSegments)&&probeSegments.length){
    ctx.globalAlpha=0.25;
    for(const seg of probeSegments){
      const start=Number(seg?.start);
      if(!Number.isFinite(start)||start<=0) continue;
      const probeId=Number(seg?.probeId);
      ctx.fillStyle=DISCS[probeId]?.col||"#666";
      ctx.fillRect(start*scale,0,1,h*scale);
    }
    ctx.globalAlpha=1;
  }
  return canvas.toDataURL("image/png");
}

export function buildDerivationDetailHTML(output){
  const out=output&&typeof output==="object"?output:{};
  if(!isRunDerivedCAOutput(out)){
    return "<div>Legacy CA snapshot imported; derivation metadata unavailable.</div>";
  }
  const derivation=out?.derivation&&typeof out.derivation==="object"?out.derivation:{};
  const rule=derivation?.rule&&typeof derivation.rule==="object"?derivation.rule:{};
  const steps=derivation?.steps&&typeof derivation.steps==="object"?derivation.steps:{};
  const width=derivation?.width&&typeof derivation.width==="object"?derivation.width:{};
  const initialRow=derivation?.initialRow&&typeof derivation.initialRow==="object"?derivation.initialRow:{};
  const segments=Array.isArray(initialRow?.probeSegments)?initialRow.probeSegments:[];
  const lines=[];
  const ruleSource=escapeHtml(String(rule?.source||"unknown"));
  const medianDistance=Number(rule?.medianDistance);
  const ruleBase=Number.isFinite(medianDistance)
    ?`Rule source: ${ruleSource} | median distance ${medianDistance.toFixed(3)}`
    :`Rule source: ${ruleSource}`;
  lines.push(`<div>${ruleBase}</div>`);
  if(Number.isFinite(Number(rule?.wolframClass))){
    lines.push(`<div>Wolfram class: ${Number(rule.wolframClass)} (${escapeHtml(String(rule?.wolframClassLabel||"unclassified"))})</div>`);
  }else if(String(rule?.wolframClassLabel||"").trim()){
    lines.push(`<div>Wolfram class: ${escapeHtml(String(rule.wolframClassLabel).trim())}</div>`);
  }
  const selectedPairs=Array.isArray(rule?.selectedPairs)?rule.selectedPairs:[];
  if(selectedPairs.length){
    const top=[...selectedPairs].sort((a,b)=>Number(b?.distance||0)-Number(a?.distance||0))[0];
    if(top) lines.push(`<div>Top tension pair: ${escapeHtml(String(top?.probeA||"?"))} vs ${escapeHtml(String(top?.probeB||"?"))} (distance ${Number(top?.distance||0).toFixed(3)}, bit ${clampInt(Number(top?.bit)||0,0,1)})</div>`);
  }
  lines.push(`<div>Steps breakdown: base ${clampInt(Number(steps?.base)||0,0,9999)} + conv ${clampInt(Number(steps?.convergentBonus)||0,0,9999)} + contr ${clampInt(Number(steps?.contradictoryBonus)||0,0,9999)} + emerg ${clampInt(Number(steps?.emergentBonus)||0,0,9999)} + evidence ${clampInt(Number(steps?.evidenceBonus)||0,0,9999)} + coverage ${clampInt(Number(steps?.coverageBonus)||0,0,9999)}</div>`);
  if(Number.isFinite(Number(width?.termCount))){
    lines.push(`<div>Width derivation term count: ${clampInt(Number(width.termCount),0,999999)}</div>`);
  }
  if(segments.length){
    const ranked=[...segments].map(seg=>({name:String(seg?.name||`Probe ${Number(seg?.probeId)+1}`),seedDensity:clamp01(Number(seg?.seedDensity)||0)})).sort((a,b)=>b.seedDensity-a.seedDensity);
    const top=ranked[0];
    const bottom=ranked[ranked.length-1];
    lines.push(`<div>Initial row segments: ${segments.length} probes | densest ${escapeHtml(String(top?.name||"n/a"))} (${((top?.seedDensity||0)*100).toFixed(0)}%) | sparsest ${escapeHtml(String(bottom?.name||"n/a"))} (${((bottom?.seedDensity||0)*100).toFixed(0)}%)</div>`);
  }
  return lines.join("");
}

export function renderTrajectoryChart(canvas,trajectories){
  if(!canvas||!trajectories) return;
  const ctx=canvas.getContext("2d");
  if(!ctx) return;
  const toSeries=(value)=>Array.isArray(value)?value:(ArrayBuffer.isView(value)?Array.from(value):[]);
  const w=canvas.width;
  const h=canvas.height;
  ctx.clearRect(0,0,w,h);
  const series=[
    {data:toSeries(trajectories?.density).map(v=>clamp01(Number(v)||0)),color:"#60a5fa",label:"density"},
    {data:toSeries(trajectories?.volatility).map(v=>clamp01(Number(v)||0)),color:"#ff6b35",label:"volatility"},
    {data:toSeries(trajectories?.spread).map(v=>clamp01(Number(v)||0)),color:"#7fff2a",label:"spread"}
  ];
  for(const s of series){
    if(!s.data||!s.data.length) continue;
    ctx.beginPath();
    ctx.strokeStyle=s.color;
    ctx.lineWidth=1.5;
    ctx.globalAlpha=0.8;
    for(let i=0;i<s.data.length;i++){
      const x=s.data.length<=1?0:(i/(s.data.length-1))*w;
      const y=h-(s.data[i]*h);
      if(i===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }
  ctx.globalAlpha=1;
}

export function drawCATrajectoryMiniChart(output){
  const wrap=document.getElementById("ca-trajectory-wrap");
  const canvas=document.getElementById("ca-trajectory-canvas");
  if(!wrap||!canvas) return;
  const trajectories=output?.trajectories&&typeof output.trajectories==="object"?output.trajectories:null;
  const hasSeries=Boolean((trajectories?.density&&trajectories.density.length)||(trajectories?.volatility&&trajectories.volatility.length)||(trajectories?.spread&&trajectories.spread.length));
  if(!hasSeries){
    wrap.style.display="none";
    const ctx=canvas.getContext("2d");
    if(ctx) ctx.clearRect(0,0,canvas.width,canvas.height);
    return;
  }
  wrap.style.display="block";
  renderTrajectoryChart(canvas,trajectories);
}

export function renderCAPanel(){
  const panel=document.getElementById("ca-panel");
  if(!panel) return;
  if(!CA_PROBE_OUTPUT){panel.style.display="none";return;}
  panel.style.display="flex";
  const runDerived=isRunDerivedCAOutput(CA_PROBE_OUTPUT);
  const d=CA_PROBE_OUTPUT.derivation||{};
  const m=CA_PROBE_OUTPUT.metrics||{};
  const t=CA_PROBE_OUTPUT.trajectories||{};
  const titleEl=document.getElementById("ca-title");
  const metaEl=document.getElementById("ca-meta");
  const derivationEl=document.getElementById("ca-derivation");
  const imgEl=document.getElementById("ca-image");
  const commentaryEl=document.getElementById("ca-commentary");
  const classLabel=runDerived?String(d?.rule?.wolframClassLabel||"unclassified"):"legacy snapshot";
  if(titleEl) titleEl.textContent=runDerived?`Rule ${CA_PROBE_OUTPUT.rule} (${classLabel}) - run-derived`:`Rule ${CA_PROBE_OUTPUT.rule} (${classLabel}) - imported`;
  if(metaEl){
    const densityFinal=Number(m?.densityFinal??m?.density??0)||0;
    const volatilityFinal=Number(m?.volatilityFinal??m?.volatility??0)||0;
    const densityTrend=String(t?.densityTrend||"").trim();
    const volatilityTrend=String(t?.volatilityTrend||"").trim();
    const densityText=`density ${(densityFinal*100).toFixed(1)}%${densityTrend?` (${densityTrend})`:""}`;
    const volatilityText=`volatility ${(volatilityFinal*100).toFixed(1)}%${volatilityTrend?` (${volatilityTrend})`:""}`;
    metaEl.textContent=`${CA_PROBE_OUTPUT.steps} steps | ${CA_PROBE_OUTPUT.width} cells | ${densityText} | ${volatilityText}`;
  }
  if(derivationEl) derivationEl.innerHTML=buildDerivationDetailHTML(CA_PROBE_OUTPUT);
  if(imgEl&&CA_PROBE_OUTPUT.imageUrl) imgEl.src=CA_PROBE_OUTPUT.imageUrl;
  const trajCanvas=document.getElementById("ca-trajectory-canvas");
  if(trajCanvas&&t?.density){
    renderTrajectoryChart(trajCanvas,t);
    const trajectoryWrap=document.getElementById("ca-trajectory-wrap");
    if(trajectoryWrap) trajectoryWrap.style.display="block";
  }else{
    drawCATrajectoryMiniChart(null);
  }
  if(commentaryEl) commentaryEl.textContent=CA_PROBE_OUTPUT.commentary||"";
}
