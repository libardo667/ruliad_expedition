import { CURRENT_RUN_ID, LAST_RUN, RUN_STATE, WOLFRAM_GROUNDING_DIAGNOSTICS } from '../core/state.js';
import { showToast } from '../ui/notifications.js';
import { escapeHtml, hashString } from '../core/utils.js';
import { toCanonicalKey } from '../domain/aliases.js';
import { WA_GRAPH_STATUS_META } from '../domain/grounding-status.js';
import { downloadBlob } from './exporters.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Source: ruliad_expedition_v1.1.html
// Module: js/artifacts/wa-graph-export.js

export function waGraphStatusLabel(bucket){return WA_GRAPH_STATUS_META[bucket]?.label||String(bucket||"unknown");}

export function waGraphStatusColor(bucket){return WA_GRAPH_STATUS_META[bucket]?.color||"#64748b";}

export function hexToRgbaColor(hex,alpha=1){const raw=String(hex||"").trim().replace(/^#/,"");const full=raw.length===3?raw.split("").map(ch=>ch+ch).join(""):raw;if(!/^[0-9a-fA-F]{6}$/.test(full)) return `rgba(100,116,139,${Math.max(0,Math.min(1,alpha))})`;const r=parseInt(full.slice(0,2),16);const g=parseInt(full.slice(2,4),16);const b=parseInt(full.slice(4,6),16);return `rgba(${r},${g},${b},${Math.max(0,Math.min(1,alpha))})`;}

export function normalizeWAGraphLabel(value,fallback="(none)"){const txt=String(value||"").replace(/\s+/g," ").trim();return txt||fallback;}

export function resolveWAGraphOutcomeBucket(item){
  const status=String(item?.status||"").trim().toLowerCase();
  const reasons=(Array.isArray(item?.reasons)?item.reasons:[]).map(x=>String(x||"").trim().toLowerCase()).filter(Boolean);
  if(status.includes("no_plaintext")||status==="cache_hit_term_no_match"||reasons.includes("empty")) return "no_plaintext";
  if(status==="rejected_category_mismatch"||reasons.some(reason=>reason.startsWith("category_mismatch_")||reason==="forced_metadata_only_category_mismatch")) return "rejected_category_mismatch";
  if(status==="accepted_metadata_only"||status==="accepted_annotation_only") return "metadata_only";
  if(Boolean(item?.accepted)&&item?.appliedToDescription===false) return "metadata_only";
  if(status==="accepted") return "accepted";
  if(Boolean(item?.accepted)&&status.startsWith("accepted")) return "accepted";
  return "rejected_low_confidence";
}

export function buildWAGroundingGraphData(diagnostics=WOLFRAM_GROUNDING_DIAGNOSTICS){
  const statusOrder=["accepted","metadata_only","rejected_category_mismatch","rejected_low_confidence","no_plaintext"];
  const diagList=Array.isArray(diagnostics)?diagnostics.filter(item=>item&&typeof item==="object"):[];
  const statusCounts=Object.fromEntries(statusOrder.map(key=>[key,0]));
  const data={generatedAt:new Date().toISOString(),diagnosticsCount:diagList.length,statusOrder,statusCounts,nodes:[],links:[],paths:[],interpretationCollisions:[],retryHotspots:[],uniqueTerms:0,uniqueQueries:0,uniqueInterpretations:0,pathCount:0};
  if(!diagList.length) return data;
  const nodeMap=new Map();
  const linkMap=new Map();
  const pathMap=new Map();
  const termQueryCounts=new Map();
  const interpretationStats=new Map();
  const ensureNode=(kind,label)=>{
    const normalized=normalizeWAGraphLabel(label,kind==="term"?"(unknown term)":kind==="query"?"(no query)":"(no interpretation)");
    const canonical=toCanonicalKey(normalized)||hashString(`${kind}:${normalized.toLowerCase()}`);
    const id=`${kind}:${canonical}`;
    if(!nodeMap.has(id)) nodeMap.set(id,{id,kind,label:normalized,count:0});
    const node=nodeMap.get(id);
    node.count++;
    return node;
  };
  const ensureStatusNode=(bucket)=>{
    const id=`status:${bucket}`;
    if(!nodeMap.has(id)) nodeMap.set(id,{id,kind:"status",label:waGraphStatusLabel(bucket),count:0,statusBucket:bucket});
    const node=nodeMap.get(id);
    node.count++;
    return node;
  };
  const addLink=(sourceId,targetId,kind,statusBucket)=>{
    const id=`${kind}|${sourceId}|${targetId}`;
    if(!linkMap.has(id)) linkMap.set(id,{id,kind,source:sourceId,target:targetId,value:0,statusCounts:{}});
    const link=linkMap.get(id);
    link.value++;
    if(statusBucket) link.statusCounts[statusBucket]=(link.statusCounts[statusBucket]||0)+1;
    return link;
  };
  for(const diag of diagList){
    const termLabel=normalizeWAGraphLabel(diag?.termLabel,"(unknown term)");
    const queryLabel=normalizeWAGraphLabel(diag?.query,"(no query)");
    const interpretationLabel=normalizeWAGraphLabel(diag?.chosenInterpretation||diag?.inputInterpretation||diag?.bestDefinition||diag?.snippet,"(no interpretation)");
    const statusBucket=resolveWAGraphOutcomeBucket(diag);
    if(statusCounts[statusBucket]===undefined) statusCounts[statusBucket]=0;
    statusCounts[statusBucket]++;
    const termNode=ensureNode("term",termLabel);
    const queryNode=ensureNode("query",queryLabel);
    const interpretationNode=ensureNode("interpretation",interpretationLabel);
    const statusNode=ensureStatusNode(statusBucket);
    const termQueryKey=`${termNode.id}|${queryNode.id}`;
    termQueryCounts.set(termQueryKey,(termQueryCounts.get(termQueryKey)||0)+1);
    addLink(termNode.id,queryNode.id,"term_query",statusBucket);
    addLink(queryNode.id,interpretationNode.id,"query_interpretation",statusBucket);
    addLink(interpretationNode.id,statusNode.id,"interpretation_status",statusBucket);
    const pathKey=`${termNode.id}|${queryNode.id}|${interpretationNode.id}|${statusBucket}`;
    if(!pathMap.has(pathKey)) pathMap.set(pathKey,{term:termNode.label,query:queryNode.label,interpretation:interpretationNode.label,statusBucket,count:0,reasons:new Set(),rawStatuses:new Set()});
    const path=pathMap.get(pathKey);
    path.count++;
    const reasons=(Array.isArray(diag?.reasons)?diag.reasons:[]).map(x=>String(x||"").trim()).filter(Boolean);
    for(const reason of reasons){if(path.reasons.size<10) path.reasons.add(reason);}
    const rawStatus=String(diag?.status||"").trim();
    if(rawStatus) path.rawStatuses.add(rawStatus);
    if(!interpretationStats.has(interpretationNode.id)) interpretationStats.set(interpretationNode.id,{interpretation:interpretationNode.label,totalCount:0,terms:new Set(),queries:new Set(),statusCounts:{}});
    const interpStat=interpretationStats.get(interpretationNode.id);
    interpStat.totalCount++;
    interpStat.terms.add(termNode.label);
    interpStat.queries.add(queryNode.label);
    interpStat.statusCounts[statusBucket]=(interpStat.statusCounts[statusBucket]||0)+1;
  }
  const kindRank={term:1,query:2,interpretation:3,status:4};
  data.nodes=[...nodeMap.values()].sort((a,b)=>(kindRank[a.kind]||99)-(kindRank[b.kind]||99)||Number(b.count)-Number(a.count)||String(a.label).localeCompare(String(b.label)));
  data.links=[...linkMap.values()].map(link=>{
    const breakdown=Object.entries(link.statusCounts||{}).map(([bucket,count])=>({statusBucket:bucket,label:waGraphStatusLabel(bucket),count:Number(count)||0,color:waGraphStatusColor(bucket)})).sort((a,b)=>Number(b.count)-Number(a.count));
    const dominant=breakdown[0]?.statusBucket||"";
    const retryCount=link.kind==="term_query"?Math.max(0,(termQueryCounts.get(`${link.source}|${link.target}`)||link.value)-1):Math.max(0,Number(link.value)-1);
    return {id:link.id,kind:link.kind,source:link.source,target:link.target,value:Number(link.value)||0,retryCount,dominantStatusBucket:dominant,statusBreakdown:breakdown};
  }).sort((a,b)=>Number(b.value)-Number(a.value)||String(a.kind).localeCompare(String(b.kind)));
  data.paths=[...pathMap.values()].map(path=>({term:path.term,query:path.query,interpretation:path.interpretation,statusBucket:path.statusBucket,statusLabel:waGraphStatusLabel(path.statusBucket),count:path.count,retries:Math.max(0,path.count-1),reasons:[...path.reasons],statuses:[...path.rawStatuses]})).sort((a,b)=>Number(b.count)-Number(a.count)||String(a.term).localeCompare(String(b.term)));
  data.interpretationCollisions=[...interpretationStats.values()].map(item=>{const statusBreakdown=Object.entries(item.statusCounts||{}).map(([bucket,count])=>({statusBucket:bucket,label:waGraphStatusLabel(bucket),count:Number(count)||0,color:waGraphStatusColor(bucket)})).sort((a,b)=>Number(b.count)-Number(a.count));return {interpretation:item.interpretation,totalCount:item.totalCount,termCount:item.terms.size,queryCount:item.queries.size,terms:[...item.terms].sort(),queries:[...item.queries].sort(),statusBreakdown};}).filter(item=>item.termCount>=2).sort((a,b)=>Number(b.termCount)-Number(a.termCount)||Number(b.totalCount)-Number(a.totalCount)||String(a.interpretation).localeCompare(String(b.interpretation)));
  data.retryHotspots=[...termQueryCounts.entries()].filter(([,count])=>Number(count)>1).map(([pair,count])=>{const [termId,queryId]=pair.split("|");return {term:nodeMap.get(termId)?.label||"(unknown term)",query:nodeMap.get(queryId)?.label||"(no query)",count:Number(count)||0,retries:Math.max(0,(Number(count)||0)-1)};}).sort((a,b)=>Number(b.count)-Number(a.count)||String(a.term).localeCompare(String(b.term)));
  data.uniqueTerms=data.nodes.filter(node=>node.kind==="term").length;
  data.uniqueQueries=data.nodes.filter(node=>node.kind==="query").length;
  data.uniqueInterpretations=data.nodes.filter(node=>node.kind==="interpretation").length;
  data.pathCount=data.paths.length;
  return data;
}

export function buildWAGroundingGraphText(data){
  if(!data?.diagnosticsCount) return "No Wolfram grounding diagnostics captured yet.";
  const lines=[
    "WA Interpretation Graph",
    `Generated: ${data.generatedAt||new Date().toISOString()}`,
    `Diagnostics: ${Number(data.diagnosticsCount)||0}`,
    `Unique terms: ${Number(data.uniqueTerms)||0} | Queries: ${Number(data.uniqueQueries)||0} | Interpretations: ${Number(data.uniqueInterpretations)||0}`,
    "",
    "Outcome buckets:"
  ];
  for(const bucket of (data.statusOrder||[])){lines.push(`- ${waGraphStatusLabel(bucket)}: ${Number(data.statusCounts?.[bucket]||0)}`);}
  lines.push("");
  lines.push("Top weighted paths (count | retries):");
  const topPaths=Array.isArray(data.paths)?data.paths.slice(0,18):[];
  if(!topPaths.length){lines.push("- none");}
  else{for(const row of topPaths){lines.push(`- ${row.count} | ${row.retries} :: ${row.term} -> ${row.query} -> ${row.interpretation} -> ${waGraphStatusLabel(row.statusBucket)}`);}}
  lines.push("");
  lines.push("Top interpretation collisions:");
  const collisions=Array.isArray(data.interpretationCollisions)?data.interpretationCollisions.slice(0,12):[];
  if(!collisions.length){lines.push("- none");}
  else{for(const row of collisions){lines.push(`- ${row.interpretation} :: terms ${row.termCount}, paths ${row.totalCount}`);}}
  return lines.join("\n");
}

export function buildWAGroundingGraphHTML(data){
  if(!data?.diagnosticsCount) return `<div class="artifact-meta">No Wolfram grounding diagnostics captured yet.</div>`;
  const statusTags=(data.statusOrder||[]).map(bucket=>`<span class="tag" style="border-color:${waGraphStatusColor(bucket)};color:${waGraphStatusColor(bucket)}">${escapeHtml(waGraphStatusLabel(bucket))}: ${Number(data.statusCounts?.[bucket]||0)}</span>`).join("");
  const pathRows=(Array.isArray(data.paths)?data.paths.slice(0,22):[]).map(row=>`<tr><td>${escapeHtml(row.term)}</td><td>${escapeHtml(row.query)}</td><td>${escapeHtml(row.interpretation)}</td><td><span class="tag" style="border-color:${waGraphStatusColor(row.statusBucket)};color:${waGraphStatusColor(row.statusBucket)}">${escapeHtml(waGraphStatusLabel(row.statusBucket))}</span></td><td>${Number(row.count)||0}</td><td>${Number(row.retries)||0}</td></tr>`).join("");
  const collisionRows=(Array.isArray(data.interpretationCollisions)?data.interpretationCollisions.slice(0,14):[]).map(item=>{const terms=item.terms.slice(0,5).join(" | ");const extra=item.terms.length>5?` +${item.terms.length-5} more`:"";const status=item.statusBreakdown.slice(0,2).map(x=>`${waGraphStatusLabel(x.statusBucket)} ${x.count}`).join(" | ");return `<tr><td>${escapeHtml(item.interpretation)}</td><td>${item.termCount}</td><td>${item.totalCount}</td><td>${escapeHtml(`${terms}${extra}`)}</td><td>${escapeHtml(status||"-")}</td></tr>`;}).join("");
  const retryRows=(Array.isArray(data.retryHotspots)?data.retryHotspots.slice(0,14):[]).map(item=>`<tr><td>${escapeHtml(item.term)}</td><td>${escapeHtml(item.query)}</td><td>${item.count}</td><td>${item.retries}</td></tr>`).join("");
  return `<div style="display:flex;flex-direction:column;gap:10px"><div class="artifact-meta">Diagnostics graph: term -> query -> chosen interpretation -> outcome status.</div><div class="tag-row">${statusTags}</div><div class="artifact-meta">Weighted edges use frequency; retries are repeat traversals of the same edge path.</div><div id="wa-graph-sankey-host" style="width:100%;height:380px;border:1px solid var(--border);border-radius:8px;background:var(--panel-alt)"></div><div class="matrix-wrap"><table class="matrix-table"><thead><tr><th>Term</th><th>Query</th><th>Chosen interpretation</th><th>Outcome</th><th>Count</th><th>Retries</th></tr></thead><tbody>${pathRows||"<tr><td colspan=\"6\">No paths captured.</td></tr>"}</tbody></table></div><div class="artifact-meta">Interpretation collision hotspots (same interpretation attracting multiple terms):</div><div class="matrix-wrap"><table class="matrix-table"><thead><tr><th>Interpretation</th><th>Term count</th><th>Path count</th><th>Top terms</th><th>Dominant outcomes</th></tr></thead><tbody>${collisionRows||"<tr><td colspan=\"5\">No multi-term interpretation collisions.</td></tr>"}</tbody></table></div><div class="artifact-meta">Retry hotspots (term/query pairs with repeat attempts):</div><div class="matrix-wrap"><table class="matrix-table"><thead><tr><th>Term</th><th>Query</th><th>Attempts</th><th>Retries</th></tr></thead><tbody>${retryRows||"<tr><td colspan=\"4\">No retries detected.</td></tr>"}</tbody></table></div></div>`;
}

export function buildWAGroundingGraphArtifact(){const data=buildWAGroundingGraphData(WOLFRAM_GROUNDING_DIAGNOSTICS);return {contentText:buildWAGroundingGraphText(data),contentHTML:buildWAGroundingGraphHTML(data),data};}

export function renderWAGroundingGraphSankey(data){
  const host=document.getElementById("wa-graph-sankey-host");
  if(!host) return;
  if(typeof Plotly==="undefined"){host.innerHTML="<div class=\"artifact-meta\" style=\"padding:12px\">Plotly unavailable; Sankey view skipped.</div>";return;}
  const links=Array.isArray(data?.links)?data.links:[];
  const nodes=Array.isArray(data?.nodes)?data.nodes:[];
  if(!links.length||!nodes.length){host.innerHTML="<div class=\"artifact-meta\" style=\"padding:12px\">No diagnostic graph links to render yet.</div>";return;}
  const maxLinks=Math.max(40,Math.min(280,links.length));
  const keptLinks=[...links].sort((a,b)=>Number(b.value)-Number(a.value)).slice(0,maxLinks);
  const requiredNodeIds=new Set();
  for(const link of keptLinks){requiredNodeIds.add(String(link.source));requiredNodeIds.add(String(link.target));}
  const keptNodes=nodes.filter(node=>requiredNodeIds.has(String(node.id)));
  const nodeIndex=new Map();
  keptNodes.forEach((node,idx)=>nodeIndex.set(String(node.id),idx));
  const sankeyLinks=keptLinks.filter(link=>nodeIndex.has(String(link.source))&&nodeIndex.has(String(link.target)));
  if(!sankeyLinks.length){host.innerHTML="<div class=\"artifact-meta\" style=\"padding:12px\">No diagnostic graph links to render yet.</div>";return;}
  const nodeColors=keptNodes.map(node=>{if(node.kind==="status") return waGraphStatusColor(node.statusBucket||"");if(node.kind==="interpretation") return "#0f766e";if(node.kind==="query") return "#475569";return "#334155";});
  const nodeLabels=keptNodes.map(node=>String(node.label||""));
  const nodeCustom=keptNodes.map(node=>`${node.kind} node | observations: ${Number(node.count)||0}`);
  const linkSources=sankeyLinks.map(link=>nodeIndex.get(String(link.source)));
  const linkTargets=sankeyLinks.map(link=>nodeIndex.get(String(link.target)));
  const linkValues=sankeyLinks.map(link=>Math.max(1,Number(link.value)||1));
  const linkColors=sankeyLinks.map(link=>{const bucket=String(link?.dominantStatusBucket||"");if(bucket) return hexToRgbaColor(waGraphStatusColor(bucket),link.kind==="interpretation_status"?0.62:0.34);return "rgba(100,116,139,0.3)";});
  const linkCustom=sankeyLinks.map(link=>{const src=keptNodes[nodeIndex.get(String(link.source))]?.label||link.source;const dst=keptNodes[nodeIndex.get(String(link.target))]?.label||link.target;const status=String(link?.dominantStatusBucket||"");const statusPart=status?` | dominant outcome: ${waGraphStatusLabel(status)}`:"";return `${src} -> ${dst}<br>weight: ${Number(link.value)||0} | retries: ${Number(link.retryCount)||0}${statusPart}`;});
  const trace={type:"sankey",orientation:"h",arrangement:"snap",node:{label:nodeLabels,color:nodeColors,pad:12,thickness:14,line:{color:"rgba(148,163,184,0.35)",width:0.6},customdata:nodeCustom,hovertemplate:"%{label}<br>%{customdata}<extra></extra>"},link:{source:linkSources,target:linkTargets,value:linkValues,color:linkColors,customdata:linkCustom,hovertemplate:"%{customdata}<extra></extra>"}};
  const layout={paper_bgcolor:"rgba(0,0,0,0)",plot_bgcolor:"rgba(0,0,0,0)",margin:{l:8,r:8,t:8,b:8},font:{family:"Courier New, monospace",size:11,color:"#e5e7eb"}};
  Plotly.react(host,[trace],layout,{displayModeBar:false,responsive:true,staticPlot:true});
}

export function buildWAGraphReadyNodeExport(graphData){
  const kindLayer={term:0,query:1,interpretation:2,status:3};
  const nodes=Array.isArray(graphData?.nodes)?graphData.nodes:[];
  return nodes.map(node=>{
    const kind=String(node?.kind||"unknown");
    const statusBucket=kind==="status"?String(node?.statusBucket||""):"";
    const hasLayer=Object.prototype.hasOwnProperty.call(kindLayer,kind);
    return {
      id:String(node?.id||""),
      label:String(node?.label||""),
      kind,
      layer:hasLayer?kindLayer[kind]:99,
      observations:Number(node?.count)||0,
      statusBucket,
      statusLabel:statusBucket?waGraphStatusLabel(statusBucket):"",
      color:statusBucket?waGraphStatusColor(statusBucket):""
    };
  }).filter(node=>node.id);
}

export function buildWAGraphReadyEdgeExport(graphData,nodes=[]){
  const links=Array.isArray(graphData?.links)?graphData.links:[];
  const nodeMap=new Map((Array.isArray(nodes)?nodes:[]).map(node=>[String(node.id),node]));
  return links.map(link=>{
    const source=String(link?.source||"");
    const target=String(link?.target||"");
    const dominantStatusBucket=String(link?.dominantStatusBucket||"");
    return {
      id:String(link?.id||`${source}|${target}`),
      kind:String(link?.kind||""),
      source,
      sourceLabel:nodeMap.get(source)?.label||source,
      sourceKind:nodeMap.get(source)?.kind||"",
      target,
      targetLabel:nodeMap.get(target)?.label||target,
      targetKind:nodeMap.get(target)?.kind||"",
      weight:Number(link?.value)||0,
      retryCount:Number(link?.retryCount)||0,
      dominantStatusBucket,
      dominantStatusLabel:dominantStatusBucket?waGraphStatusLabel(dominantStatusBucket):"",
      dominantStatusColor:dominantStatusBucket?waGraphStatusColor(dominantStatusBucket):"",
      statusBreakdown:Array.isArray(link?.statusBreakdown)?link.statusBreakdown.map(item=>({
        statusBucket:String(item?.statusBucket||""),
        label:String(item?.label||""),
        count:Number(item?.count)||0,
        color:String(item?.color||"")
      })):[]
    };
  }).filter(edge=>edge.source&&edge.target);
}

export function buildWAGraphReadyWLSource({nodesFilename="wa_graph_nodes.json",edgesFilename="wa_graph_edges.json"}={}){
  return [
    "(* WA grounding diagnostic graph artifact *)",
    "(* Expects wa_graph_nodes.json and wa_graph_edges.json in the current directory *)",
    `nodes = Import["${String(nodesFilename||"wa_graph_nodes.json")}", "RawJSON"];`,
    `edges = Import["${String(edgesFilename||"wa_graph_edges.json")}", "RawJSON"];`,
    "",
    "statusColors = <|",
    "  \"accepted\" -> RGBColor[0.086, 0.627, 0.306],",
    "  \"metadata_only\" -> RGBColor[0.855, 0.576, 0.106],",
    "  \"rejected_category_mismatch\" -> RGBColor[0.863, 0.078, 0.235],",
    "  \"rejected_low_confidence\" -> RGBColor[0.522, 0.447, 0.702],",
    "  \"no_plaintext\" -> RGBColor[0.278, 0.565, 0.761]",
    "|>;",
    "",
    "vertexLabels = Association @ Map[#[\"id\"] -> Row[{#[\"kind\"], \": \", #[\"label\"]}] &, nodes];",
    "vertexStyles = Association @ Map[",
    "  If[StringLength @ ToString @ Lookup[#, \"statusBucket\", \"\"] > 0,",
    "    #[\"id\"] -> Lookup[statusColors, Lookup[#, \"statusBucket\", \"\"], GrayLevel[0.45]],",
    "    Nothing",
    "  ] &,",
    "  nodes",
    "];",
    "",
    "edgeRules = Map[#[\"source\"] -> #[\"target\"] &, edges];",
    "edgeWeights = Map[Max[1, Lookup[#, \"weight\", 1]] &, edges];",
    "edgeStyles = Map[",
    "  (#[\"source\"] -> #[\"target\"]) -> Directive[",
    "    Lookup[statusColors, Lookup[#, \"dominantStatusBucket\", \"\"], GrayLevel[0.6]],",
    "    Opacity[0.55]",
    "  ] &,",
    "  edges",
    "];",
    "",
    "Graph[",
    "  edgeRules,",
    "  VertexLabels -> (v_ :> Lookup[vertexLabels, v, v]),",
    "  VertexStyle -> vertexStyles,",
    "  EdgeWeight -> edgeWeights,",
    "  EdgeStyle -> edgeStyles,",
    "  GraphLayout -> \"LayeredDigraphEmbedding\",",
    "  ImageSize -> Large",
    "]"
  ].join("\n");
}

export function buildWAGraphReadyExportData(diagnostics=WOLFRAM_GROUNDING_DIAGNOSTICS){
  const graphData=buildWAGroundingGraphData(diagnostics);
  const nodes=buildWAGraphReadyNodeExport(graphData);
  const edges=buildWAGraphReadyEdgeExport(graphData,nodes);
  const metadata={
    generatedAt:new Date().toISOString(),
    runId:CURRENT_RUN_ID||LAST_RUN?.runId||RUN_STATE?.runId||null,
    target:LAST_RUN?.target||RUN_STATE?.target||null,
    diagnosticsCount:Number(graphData?.diagnosticsCount)||0,
    pathCount:Number(graphData?.pathCount)||0
  };
  return {metadata,nodes,edges,wlSource:buildWAGraphReadyWLSource()};
}

export async function exportWAGraphReadyArtifacts({includeWL=true}={}){
  const exportData=buildWAGraphReadyExportData(WOLFRAM_GROUNDING_DIAGNOSTICS);
  downloadBlob("wa_graph_nodes.json",new Blob([JSON.stringify(exportData.nodes,null,2)],{type:"application/json"}));
  downloadBlob("wa_graph_edges.json",new Blob([JSON.stringify(exportData.edges,null,2)],{type:"application/json"}));
  downloadBlob("wa_graph_metadata.json",new Blob([JSON.stringify(exportData.metadata,null,2)],{type:"application/json"}));
  if(includeWL){
    downloadBlob("wa_graph.wl",new Blob([exportData.wlSource],{type:"text/plain;charset=utf-8"}));
  }
  if(!exportData.metadata.diagnosticsCount){
    showToast("Graph-ready export generated (no WA diagnostics captured yet).");
    return;
  }
  showToast(`Graph-ready export downloaded (${exportData.metadata.diagnosticsCount} diagnostics).`);
}
