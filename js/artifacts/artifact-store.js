import { ARTIFACT_BUSY, ARTIFACT_STORE, CA_PROBE_OUTPUT, CITATIONS, DISCS, LAST_RUN, RUN_STATE, TERMS, setArtifactStore, setArtifactBusy as _setArtifactBusy } from '../core/state.js';
import { escapeHtml, structuredCloneSafe } from '../core/utils.js';
import { showToast } from '../ui/notifications.js';
import { refreshArtifactList } from '../ui/artifact-drawer-ui.js';
import { applyDisplayDescriptionForTerm, defaultDescriptionLayers } from '../domain/terms.js';
import { sourceTypeLabel } from '../domain/citations.js';
import { getRunFingerprint } from '../domain/run-metadata.js';
import { renderCAPanel } from '../ca/render-ca-panel.js';
import { formatClaimsLedger } from './artifact-generators.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Module: js/artifacts/artifact-store.js

export const ARTIFACT_DEFS={
  raw_terms:{name:"Raw term list",desc:"All plotted nodes in raw form.",kind:"derived"},
  evidence:{name:"Evidence library",desc:"Captured sources and quality tags.",kind:"derived"},
  claims:{name:"Claims ledger",desc:"Structured claims with confidence and verification steps.",kind:"generated"},
  outline:{name:"Outline from map",desc:"Narrative structure from convergences, fault lines, and emergence.",kind:"generated"},
  deep_report:{name:"Deep report",desc:"Substantive synthesis memo from map artifacts.",kind:"generated"},
  red_team:{name:"Red team critique",desc:"Attacks weak joints, unsupported leaps, and evidence gaps.",kind:"generated"},
  replication:{name:"Replication results",desc:"Stability estimate via model reruns and overlap scores.",kind:"generated"},
  markdown:{name:"Markdown report",desc:"Substack-ready report export artifact.",kind:"generated"}
};

export function initArtifactStore(){setArtifactStore({});for(const key of Object.keys(ARTIFACT_DEFS)){ARTIFACT_STORE[key]={status:"not_generated",stale:false,generatedAt:"",fingerprint:"",contentText:"",contentHTML:"",data:null};}refreshArtifactList();updateArtifactProgress("Idle");}

export function updateArtifactProgress(text){const el=document.getElementById("artifact-progress-text");if(el) el.textContent=text||"Idle";}

export function artifactStatusBadge(status,stale){if(status==="not_generated") return `<span class="badge none">not generated</span>`;if(stale) return `<span class="badge stale">stale</span>`;return `<span class="badge ready">ready</span>`;}

export function markArtifactsStale(keys=[]){const list=keys.length?keys:Object.keys(ARTIFACT_STORE);for(const key of list){const item=ARTIFACT_STORE[key];if(!item) continue;if(item.status==="ready"){item.stale=true;}}refreshArtifactList();}

export function setArtifactReady(key,{contentText="",contentHTML="",data=null}={}){const item=ARTIFACT_STORE[key];if(!item) return;item.status="ready";item.stale=false;item.generatedAt=new Date().toISOString();item.fingerprint=getRunFingerprint();item.contentText=String(contentText||"");item.contentHTML=String(contentHTML||"");item.data=data;refreshArtifactList();}

export function updateDerivedArtifactsReady(){setArtifactReady("raw_terms",buildRawTermsArtifact());setArtifactReady("evidence",buildEvidenceArtifact());}

export function syncArtifactStoreFromRun(){if(!LAST_RUN){initArtifactStore();return;}if(LAST_RUN?.caProbe&&typeof LAST_RUN.caProbe==="object"){CA_PROBE_OUTPUT=LAST_RUN.caProbe;}updateDerivedArtifactsReady();if(Array.isArray(LAST_RUN.claimsLedger)&&LAST_RUN.claimsLedger.length){setArtifactReady("claims",{contentText:formatClaimsLedger(LAST_RUN.claimsLedger),data:LAST_RUN.claimsLedger});}if(LAST_RUN.outline){setArtifactReady("outline",{contentText:String(LAST_RUN.outline),data:{text:String(LAST_RUN.outline)}});}if(LAST_RUN.report){setArtifactReady("deep_report",{contentText:String(LAST_RUN.report),data:{text:String(LAST_RUN.report)}});}if(LAST_RUN.redTeamCritique){setArtifactReady("red_team",{contentText:String(LAST_RUN.redTeamCritique),data:{text:String(LAST_RUN.redTeamCritique)}});}if(Array.isArray(LAST_RUN.replication)&&LAST_RUN.replication.length){const txt=LAST_RUN.replication.map(r=>r.error?`- ${r.model}: ERROR ${r.error}`:`- ${r.model}: term overlap ${(r.termOverlap*100).toFixed(1)}% | contradiction overlap ${(r.contradictionOverlap*100).toFixed(1)}% | emergent overlap ${(r.emergentOverlap*100).toFixed(1)}%`).join("\n");setArtifactReady("replication",{contentText:txt,data:LAST_RUN.replication});}if(LAST_RUN.markdown){setArtifactReady("markdown",{contentText:String(LAST_RUN.markdown),data:{text:String(LAST_RUN.markdown)}});}renderCAPanel();refreshArtifactList();}

export function setArtifactBusy(busy,label=""){_setArtifactBusy(Boolean(busy));updateArtifactProgress(busy?label||"Working...":"Idle");const pill=document.getElementById("artifact-progress-text");if(pill) pill.classList.toggle("busy",Boolean(busy));const regenBtns=document.querySelectorAll("[data-art-regen]");for(const btn of regenBtns){btn.disabled=ARTIFACT_BUSY;}}

export async function withArtifactTask(label,fn){if(ARTIFACT_BUSY){showToast("Another artifact task is running.");return null;}setArtifactBusy(true,label);try{return await fn();}finally{setArtifactBusy(false);}}

export function buildRawTermsArtifact(){if(!TERMS.length) return {contentText:"No plotted nodes available yet.",data:[]};const lines=[];const data=[];for(const term of TERMS){applyDisplayDescriptionForTerm(term,{fallbackDescription:term.description,fallbackSource:term.description_source});const slices=term.slices.length?term.slices.map(i=>DISCS[i]?.name||`Probe ${i+1}`).join(" | "):"Synthesis-only";const pos=[Number(term.pos?.[0]||0),Number(term.pos?.[1]||0),Number(term.pos?.[2]||0)];const reason=String(term?.descriptions?.displayDescriptionReason||"");lines.push(`[${term.type.toUpperCase()}] ${term.label}\n  Probes: ${slices}\n  Pos: (${pos[0].toFixed(3)}, ${pos[1].toFixed(3)}, ${pos[2].toFixed(3)})\n  Desc: ${term.description||"-"}\n  Desc reason: ${reason||"-"}`);data.push({label:term.label,type:term.type,slices:[...term.slices],pos,description:term.description||"",descriptions:structuredCloneSafe(term.descriptions||defaultDescriptionLayers()),centrality:term.centrality});}return {contentText:lines.join("\n\n"),data};}

export function buildEvidenceArtifact(){
  if(!CITATIONS.length) return {contentText:"No citations captured yet.",contentHTML:"<div class=\"artifact-meta\">No citations captured yet.</div>",data:[]};
  const rows=CITATIONS.map(c=>{const mapBits=(Array.isArray(c.supporting_term_mappings)?c.supporting_term_mappings:[]).slice(0,4).map(m=>`${m.supporting_term} => ${m.mapped_term}`).join(" | ");const unmappedBits=(Array.isArray(c.unmapped_supporting_terms)?c.unmapped_supporting_terms:[]).slice(0,5).join(", ");return `<div class="evidence-card"><div class="evidence-top"><div class="evidence-title">${escapeHtml(c.title||c.publisher||c.url||"Untitled source")}</div><div class="evidence-meta">${escapeHtml([c.publisher,c.date].filter(Boolean).join(" | "))}</div></div><div class="tag-row"><span class="tag strong">${escapeHtml(sourceTypeLabel(c.source_type,c.publisher))}</span><span class="tag">${escapeHtml((c.supporting_terms||[]).slice(0,5).join(", ")||"no linked terms")}</span>${mapBits?`<span class="tag">${escapeHtml(`mapped: ${mapBits}`)}</span>`:""}${unmappedBits?`<span class="tag">${escapeHtml(`unmapped: ${unmappedBits}`)}</span>`:""}</div><div class="evidence-meta">${escapeHtml([c.quote_or_snippet||c.relevance||"No snippet provided.",mapBits?`alias map: ${mapBits}`:"",unmappedBits?`unmapped terms: ${unmappedBits}`:""].filter(Boolean).join("\n"))}</div></div>`;}).join("");
  const txt=CITATIONS.map((c,i)=>`${i+1}. ${c.title||c.publisher||"Source"} | ${c.date||"n.d."} | ${c.url||"-"} | ${c.source_type||"untyped"}\n   relevance: ${c.relevance||"-"}\n   supports (mapped): ${(c.supporting_terms||[]).join(", ")||"-"}\n   supports (raw): ${(c.supporting_terms_raw||[]).join(", ")||"-"}\n   alias mappings: ${((c.supporting_term_mappings||[]).map(m=>`${m.supporting_term}=>${m.mapped_term} (${m.strategy}${Number.isFinite(Number(m.confidence))?`,${Number(m.confidence).toFixed(2)}`:""})`).join(" | "))||"-"}\n   unmapped terms: ${(c.unmapped_supporting_terms||[]).join(", ")||"-"}`).join("\n\n");
  return {contentText:txt,contentHTML:`<div class="card-list">${rows}</div>`,data:CITATIONS.map(c=>({...c}))};
}
