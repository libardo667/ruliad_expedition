import { ARTIFACT_STORE, CITATIONS, LAST_RUN, RUN_STATE, TERMS, lastClaimsText, plotInited, setLastMarkdownText, setLastRun } from '../core/state.js';
import { showToast } from '../ui/notifications.js';
import { artifactCanOpenWithoutRegenerate, openArtifact } from '../ui/artifact-drawer-ui.js';
import { callLLM, getQualityProfile, readApiConfig, validateApiConfig } from '../api/llm.js';
import { buildRunSnapshot } from '../domain/run-metadata.js';
import { withArtifactTask } from './artifact-store.js';
import { resolvePromptBundleWithOverrides } from '../prompt/prompt-system.js';


// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Module: js/artifacts/exporters.js

export async function exportMarkdownReport(){if(!TERMS.length){showToast("No plotted data available yet.");return;}const cfg=readApiConfig();const cfgError=validateApiConfig(cfg);if(cfgError){showToast(cfgError);return;}const target=LAST_RUN?.target||document.getElementById("viz-target-label").textContent||"Topic";const defaultSystemPrompt="You are a research assistant producing Substack-ready Markdown with citations and methods. Return Markdown only.";const byType={convergent:TERMS.filter(t=>t.type==="convergent"),contradictory:TERMS.filter(t=>t.type==="contradictory"),emergent:TERMS.filter(t=>t.type==="emergent")};const citationLines=CITATIONS.map((c,i)=>`${i+1}. ${c.title||c.publisher||"Source"} (${c.date||"n.d."}) ${c.url}`).join("\n");const method=`Model: ${cfg.researchModel}\nEmbeddings: ${cfg.embeddingModel}\nQuality: ${cfg.qualityMode}\nWeb search: ${cfg.webSearch?"on":"off"}\nSource policy: ${cfg.sourcePolicy||"none"}`;const userPromptBase=`Topic: ${target}\n\nConvergent terms:\n${byType.convergent.map(t=>t.label).join(", ")}\n\nContradictory terms:\n${byType.contradictory.map(t=>t.label).join(", ")}\n\nEmergent terms:\n${byType.emergent.map(t=>t.label).join(", ")}\n\nClaims ledger:\n${lastClaimsText||"(not generated)"}\n\nCitations:\n${citationLines||"(none)"}\n\nMethods:\n${method}\n\nReturn Markdown with:\n- Title + hook\n- Thesis\n- Map summary (convergent / contradictory / emergent)\n- Claims ledger table (if available)\n- Footnoted citations list\n- Methods appendix`;const defaultUserPrompt=userPromptBase;const promptBundle=resolvePromptBundleWithOverrides("artifact_markdown",{target,cfg,quality:getQualityProfile(cfg.qualityMode),defaults:{systemPrompt:defaultSystemPrompt,userPrompt:defaultUserPrompt}});try{const text=await callLLM(promptBundle.systemPrompt,promptBundle.userPrompt,cfg);setLastMarkdownText(text);setLastRun({...(LAST_RUN||{}),markdown:text});downloadTextFile(`parallax-${target.toLowerCase().replace(/[^a-z0-9]+/g,"-")||"report"}.md`,text);showToast("Markdown exported.");}catch(err){console.error("Markdown export failed:",err);showToast(`Markdown export failed: ${err.message||err}`);}}

export async function exportFigure(){if(!plotInited){showToast("No plot available.");return;}try{const dataUrl=await Plotly.toImage("plot",{format:"png",width:1600,height:1000});const a=document.createElement("a");a.href=dataUrl;a.download=`parallax-figure-${(LAST_RUN?.target||"plot").toLowerCase().replace(/[^a-z0-9]+/g,"-")}.png`;document.body.appendChild(a);a.click();a.remove();showToast("Figure exported.");}catch(err){console.error("Figure export failed:",err);showToast("Figure export failed.");}}

export function downloadTextFile(filename,text){const blob=new Blob([text],{type:"text/plain"});const url=URL.createObjectURL(blob);const a=document.createElement("a");a.href=url;a.download=filename;document.body.appendChild(a);a.click();a.remove();setTimeout(()=>URL.revokeObjectURL(url),250);}

export function exportRunToFile(){if(!LAST_RUN||!Array.isArray(TERMS)||!TERMS.length){showToast("No run to export yet.");return;}const cfg=RUN_STATE?.config||readApiConfig();const payload={...buildRunSnapshot(LAST_RUN.target||RUN_STATE?.target||"run",RUN_STATE?.probeResults||LAST_RUN.probeResults||[],RUN_STATE?.synthResult||LAST_RUN.synthResult||{convergent:[],contradictory:[],emergent:[]},cfg),exportedAt:new Date().toISOString()};const safeTarget=(payload.target||"run").toLowerCase().replace(/[^a-z0-9]+/g,"-").replace(/^-+|-+$/g,"")||"run";const stamp=new Date().toISOString().replace(/[:.]/g,"-");const blob=new Blob([JSON.stringify(payload,null,2)],{type:"application/json"});const url=URL.createObjectURL(blob);const a=document.createElement("a");a.href=url;a.download=`parallax-run-${safeTarget}-${stamp}.json`;document.body.appendChild(a);a.click();a.remove();setTimeout(()=>URL.revokeObjectURL(url),250);}

export function downloadBlob(filename,blob){const url=URL.createObjectURL(blob);const a=document.createElement("a");a.href=url;a.download=filename;document.body.appendChild(a);a.click();a.remove();setTimeout(()=>URL.revokeObjectURL(url),250);}

export async function exportArtifactBundle(){
  if(!TERMS.length){showToast("No plotted data available yet.");return;}
  if(typeof JSZip==="undefined"){showToast("Bundle export unavailable: JSZip not loaded.");return;}
  await withArtifactTask("Building artifact bundle...",async()=>{
    for(const key of ["raw_terms","evidence","claims","outline","deep_report","red_team","replication","markdown"]){
      if(key==="claims"||key==="outline"||key==="deep_report"||key==="red_team"||key==="replication"||key==="markdown"){
        if(!artifactCanOpenWithoutRegenerate(key)) await openArtifact(key,{regenerate:false,openAfter:false});
      }else{
        await openArtifact(key,{regenerate:false,openAfter:false});
      }
    }
    const zip=new JSZip();
    const cfg=RUN_STATE?.config||readApiConfig();
    const runPayload=buildRunSnapshot(LAST_RUN?.target||RUN_STATE?.target||"run",RUN_STATE?.probeResults||LAST_RUN?.probeResults||[],RUN_STATE?.synthResult||LAST_RUN?.synthResult||{convergent:[],contradictory:[],emergent:[]},cfg);
    zip.file("run.json",JSON.stringify(runPayload,null,2));
    zip.file("raw_nodes.json",JSON.stringify((ARTIFACT_STORE.raw_terms?.data)||[],null,2));
    zip.file("evidence.json",JSON.stringify((ARTIFACT_STORE.evidence?.data)||[],null,2));
    zip.file("claims.json",JSON.stringify((ARTIFACT_STORE.claims?.data)||[],null,2));
    zip.file("claims.md",ARTIFACT_STORE.claims?.contentText||"");
    zip.file("outline.json",JSON.stringify((ARTIFACT_STORE.outline?.data)||{},null,2));
    zip.file("outline.md",ARTIFACT_STORE.outline?.contentText||"");
    zip.file("deep_report.md",ARTIFACT_STORE.deep_report?.contentText||"");
    zip.file("critique.md",ARTIFACT_STORE.red_team?.contentText||"");
    zip.file("replication.md",ARTIFACT_STORE.replication?.contentText||"");
    zip.file("report.md",ARTIFACT_STORE.markdown?.contentText||"");
    if(plotInited){
      try{
        const dataUrl=await Plotly.toImage("plot",{format:"png",width:1600,height:1000});
        const b64=dataUrl.split(",")[1]||"";
        zip.file("figure.png",b64,{base64:true});
      }catch(err){console.warn("Could not export figure for bundle:",err);}
    }
    const blob=await zip.generateAsync({type:"blob"});
    const base=(LAST_RUN?.target||RUN_STATE?.target||"run").toLowerCase().replace(/[^a-z0-9]+/g,"-").replace(/^-+|-+$/g,"")||"run";
    downloadBlob(`parallax-bundle-${base}.zip`,blob);
    showToast("Artifact bundle exported.");
  });
}
