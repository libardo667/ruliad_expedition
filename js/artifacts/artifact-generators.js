import { ACTIVE_ARTIFACT_KEY, ARTIFACT_STORE, CITATIONS, DISCS, LAST_RUN, RUN_STATE, TERMS, lastClaimsText, lastCritiqueText, lastMarkdownText, lastOutlineText, lastReportText } from '../core/state.js';
import { clampInt } from '../core/utils.js';
import { showToast } from '../ui/notifications.js';
import { openModal } from '../ui/modals.js';
import { artifactCanOpenWithoutRegenerate, openArtifact } from '../ui/artifact-drawer-ui.js';
import { getProbeResultWithRecovery } from '../pipeline/probes.js';
import { getSynthesisResultWithRecovery } from '../pipeline/synthesis.js';
import { callLLM, callLLMJSON, getQualityProfile, readApiConfig, validateApiConfig, withArtifactTokenBudget } from '../api/llm.js';
import { extractJSON } from '../api/json-recovery.js';
import { groundProbeTermsWithWolfram, normalizeSourceType } from '../grounding/wolfram-grounding.js';
import { applyDisplayDescriptionForTerm, buildTermsForReplicationRun } from '../domain/terms.js';
import { deriveReplicationCAFingerprint, formatReplicationCAFingerprintSection, formatWolframClassForReplication } from '../ca/derive-ca.js';
import { renderCAPanel } from '../ca/render-ca-panel.js';
import { ARTIFACT_DEFS } from './artifact-store.js';
import { downloadBlob } from './exporters.js';
import { resolvePromptBundleWithOverrides } from '../prompt/prompt-system.js';
import { appendPromptMadLibBlock, buildProbeSystemPrompt, buildProbeUserPrompt, buildRedTeamPrompt } from '../prompt/prompt-builders.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Source: ruliad_expedition_v1.1.html
// Module: js/artifacts/artifact-generators.js

export function showRawNodeList(){if(!TERMS.length){showToast("No plotted nodes available yet.");return;}const lines=[];for(const term of TERMS){applyDisplayDescriptionForTerm(term,{fallbackDescription:term.description,fallbackSource:term.description_source});const slices=term.slices.length?term.slices.map(i=>DISCS[i]?.name||`Probe ${i+1}`).join(" | "):"Synthesis-only";const pos=`(${(term.pos?.[0]||0).toFixed(3)}, ${(term.pos?.[1]||0).toFixed(3)}, ${(term.pos?.[2]||0).toFixed(3)})`;const reason=String(term?.descriptions?.displayDescriptionReason||"");lines.push(`[${term.type.toUpperCase()}] ${term.label}\n  Probes: ${slices}\n  Pos: ${pos}\n  Desc: ${term.description||"-"}\n  Desc reason: ${reason||"-"}`);}document.getElementById("raw-modal-content").textContent=lines.join("\n\n");openModal("raw-modal");}

export async function generateDeepReport(){if(!TERMS.length){showToast("No plotted data available yet.");return;}const cfg=readApiConfig();const cfgError=validateApiConfig(cfg);if(cfgError){showToast(cfgError);return;}const target=LAST_RUN?.target||document.getElementById("viz-target-label").textContent||"Topic";const reportEl=document.getElementById("report-modal-content");reportEl.textContent="Generating report...";openModal("report-modal");const byType={unique:TERMS.filter(t=>t.type==="unique"),convergent:TERMS.filter(t=>t.type==="convergent"),contradictory:TERMS.filter(t=>t.type==="contradictory"),emergent:TERMS.filter(t=>t.type==="emergent")};const partySummaries=DISCS.map(d=>{const terms=TERMS.filter(t=>t.slices.includes(d.id)).map(t=>t.label);return `${d.name}: ${terms.slice(0,18).join(", ")}`;}).join("\n");const contras=byType.contradictory.map(t=>`${t.label} :: ${(t.slices||[]).map(i=>DISCS[i]?.name||`Probe ${i+1}`).join(" vs ")}`).join("\n");const emers=byType.emergent.map(t=>t.label).join(", ");const converg=byType.convergent.map(t=>`${t.label} (${t.slices.length} probes)`).join(", ");const citationLines=CITATIONS.map(c=>`- ${c.title||c.publisher||"Source"} (${c.date||"n.d."}) ${c.url} :: ${c.relevance||"supporting evidence"} [${c.source_type||"untyped"}]`).join("\n");const defaultSystemPrompt="You are a policy analyst writing a deep-research memo from structured multi-perspective evidence.";const userPromptBase=`Topic: ${target}\n\nSource policy: ${cfg.sourcePolicy||"none specified"}\n\nProbe specifications:\n${DISCS.map((d,i)=>`${i+1}. ${d.name}`).join("\n")}\n\nPer-probe key terms:\n${partySummaries}\n\nConvergent terms:\n${converg}\n\nContradictory terms:\n${contras}\n\nEmergent terms:\n${emers}\n\nEvidence sources:\n${citationLines||"- none captured"}\n\nWrite a concise but substantive report with sections:\n1) Executive Summary\n2) Major Alignments\n3) Major Fault Lines\n4) Integrative Policy Options\n5) Key Unknowns and Research Priorities\n6) Caveats\n\nUse clear, non-inflammatory language and cite terms from the map explicitly.`;const defaultUserPrompt=appendPromptMadLibBlock(userPromptBase,cfg,{includeArtifact:true});const promptBundle=resolvePromptBundleWithOverrides("artifact_deep_report",{target,cfg,quality:getQualityProfile(cfg.qualityMode),defaults:{systemPrompt:defaultSystemPrompt,userPrompt:defaultUserPrompt}});try{const text=await callLLM(promptBundle.systemPrompt,promptBundle.userPrompt,cfg);lastReportText=text;LAST_RUN={...(LAST_RUN||{}),report:text};reportEl.textContent=text;}catch(err){console.error("Report generation failed:",err);reportEl.textContent=`Report generation failed:\n${err.message||err}`;}}

export async function copyReportText(){if(!lastReportText){showToast("No report text to copy.");return;}try{await navigator.clipboard.writeText(lastReportText);showToast("Report copied to clipboard.");}catch{showToast("Clipboard copy failed.");}}

export async function generateClaimsLedger(){if(!TERMS.length){showToast("No plotted data available yet.");return;}const cfg=readApiConfig();const cfgError=validateApiConfig(cfg);if(cfgError){showToast(cfgError);return;}const target=LAST_RUN?.target||document.getElementById("viz-target-label").textContent||"Topic";const el=document.getElementById("claims-modal-content");el.textContent="Generating claims ledger...";openModal("claims-modal");const emergent=TERMS.filter(t=>t.type==="emergent").map(t=>t.label);const contradictory=TERMS.filter(t=>t.type==="contradictory").map(t=>t.label);const reportText=lastReportText||"";const defaultSystemPrompt="You are an analyst creating a claims ledger. Return strict JSON only.";const userPromptBase=`Topic: ${target}\n\nEmergent terms:\n${emergent.join(", ")||"-"}\n\nContradictory terms:\n${contradictory.join(", ")||"-"}\n\nReport excerpt:\n${reportText.slice(0,2000)||"(no report yet)"}\n\nReturn JSON only:\n{\n  "claims":[\n    {\n      "claim":"",\n      "confidence":"low|medium|high",\n      "claim_type":"empirical|normative|methodological|forecast",\n      "scope":"where it applies and does not apply",\n      "linked_nodes":["term label"],\n      "evidence_status":"unverified|partial|verified",\n      "counterclaim":"best opposing formulation",\n      "what_would_change_mind":"",\n      "evidence_needed":"what kind of source would count",\n      "next_action":"one concrete verification step"\n    }\n  ]\n}\n\nRules:\n- Use concise, non-inflammatory language\n- If confidence is high, you must provide a falsifiable what_would_change_mind; otherwise set confidence to medium\n- Link claims to emergent or contradictory terms when possible`;const defaultUserPrompt=appendPromptMadLibBlock(userPromptBase,cfg,{includeArtifact:true});const promptBundle=resolvePromptBundleWithOverrides("artifact_claims",{target,cfg,quality:getQualityProfile(cfg.qualityMode),defaults:{systemPrompt:defaultSystemPrompt,userPrompt:defaultUserPrompt}});try{const raw=await callLLMJSON(promptBundle.systemPrompt,promptBundle.userPrompt,cfg);const parsed=extractJSON(raw);const claims=Array.isArray(parsed.claims)?parsed.claims:[];for(const c of claims){const conf=String(c.confidence||"").toLowerCase();const wcm=String(c.what_would_change_mind||"").trim();if(conf==="high"&&!wcm){c.confidence="medium";c.what_would_change_mind="Not specified; requires falsifiability.";}if(!c.evidence_status) c.evidence_status="unverified";}lastClaimsText=formatClaimsLedger(claims);LAST_RUN={...(LAST_RUN||{}),claimsLedger:claims};el.textContent=lastClaimsText||"No claims returned.";}catch(err){console.error("Claims ledger failed:",err);el.textContent=`Claims ledger failed:\n${err.message||err}`;}}

export function formatClaimsLedger(claims){if(!Array.isArray(claims)||!claims.length) return "";return claims.map((c,i)=>`#${i+1} ${c.claim||""}\n- Confidence: ${c.confidence||""}\n- Type: ${c.claim_type||""}\n- Scope: ${c.scope||""}\n- Linked nodes: ${(c.linked_nodes||[]).join(", ")||"-"}\n- Evidence status: ${c.evidence_status||""}\n- Counterclaim: ${c.counterclaim||""}\n- What would change mind: ${c.what_would_change_mind||""}\n- Evidence needed: ${c.evidence_needed||""}\n- Next action: ${c.next_action||""}`).join("\n\n");}

export async function copyClaimsText(){if(!lastClaimsText){showToast("No claims text to copy.");return;}try{await navigator.clipboard.writeText(lastClaimsText);showToast("Claims copied to clipboard.");}catch{showToast("Clipboard copy failed.");}}

export async function generateOutlineFromMap(){if(!TERMS.length){showToast("No plotted data available yet.");return;}const cfg=readApiConfig();const cfgError=validateApiConfig(cfg);if(cfgError){showToast(cfgError);return;}const target=LAST_RUN?.target||document.getElementById("viz-target-label").textContent||"Topic";const el=document.getElementById("outline-modal-content");el.textContent="Generating outline...";openModal("outline-modal");const converg=TERMS.filter(t=>t.type==="convergent").map(t=>t.label);const contras=TERMS.filter(t=>t.type==="contradictory").map(t=>t.label);const emergent=TERMS.filter(t=>t.type==="emergent").map(t=>t.label);const defaultSystemPrompt="You are an editor creating a structured outline from a research map.";const userPromptBase=`Topic: ${target}\n\nPick exactly 3 convergences, 2 fault lines (contradictions), and 1 emergent idea to anchor the outline.\nConvergences: ${converg.join(", ")}\nFault lines: ${contras.join(", ")}\nEmergent: ${emergent.join(", ")}\n\nReturn a structured outline with headings and bullet points, explicitly referencing the chosen nodes.`;const defaultUserPrompt=appendPromptMadLibBlock(userPromptBase,cfg,{includeArtifact:true});const promptBundle=resolvePromptBundleWithOverrides("artifact_outline",{target,cfg,quality:getQualityProfile(cfg.qualityMode),defaults:{systemPrompt:defaultSystemPrompt,userPrompt:defaultUserPrompt}});try{const text=await callLLM(promptBundle.systemPrompt,promptBundle.userPrompt,cfg);lastOutlineText=text;el.textContent=text;LAST_RUN={...(LAST_RUN||{}),outline:text};}catch(err){console.error("Outline generation failed:",err);el.textContent=`Outline generation failed:\n${err.message||err}`;}}

export async function copyOutlineText(){if(!lastOutlineText){showToast("No outline text to copy.");return;}try{await navigator.clipboard.writeText(lastOutlineText);showToast("Outline copied to clipboard.");}catch{showToast("Clipboard copy failed.");}}

export async function runRedTeamPass(silent=false){if(!TERMS.length){if(!silent) showToast("No plotted data available yet.");return;}const cfg=readApiConfig();const cfgError=validateApiConfig(cfg);if(cfgError){if(!silent) showToast(cfgError);return;}const target=LAST_RUN?.target||document.getElementById("viz-target-label").textContent||"Topic";const el=document.getElementById("critique-modal-content");if(!silent){el.textContent="Generating critique...";openModal("critique-modal");}const defaults={systemPrompt:"You are a skeptical reviewer.",userPrompt:buildRedTeamPrompt(target,RUN_STATE?.probeResults||[],RUN_STATE?.synthResult||{convergent:[],contradictory:[],emergent:[]},cfg)};const promptBundle=resolvePromptBundleWithOverrides("artifact_red_team",{target,cfg,quality:getQualityProfile(cfg.qualityMode),defaults});try{const text=await callLLM(promptBundle.systemPrompt,promptBundle.userPrompt,cfg);lastCritiqueText=text;LAST_RUN={...(LAST_RUN||{}),redTeamCritique:text};if(!silent){el.textContent=text;}}catch(err){console.error("Red-team pass failed:",err);if(!silent){el.textContent=`Red-team pass failed:\n${err.message||err}`;}}}

export async function runReplication(){
  const cfg=readApiConfig();
  const cfgError=validateApiConfig(cfg);
  if(cfgError){showToast(cfgError);return;}
  const models=(cfg.replicationModels||"").split(",").map(s=>s.trim()).filter(Boolean);
  if(!models.length){showToast("Add replication models (comma-separated) first.");return;}
  if(!RUN_STATE?.probeResults?.length){showToast("Run a baseline expedition first.");return;}
  const el=document.getElementById("replication-modal-content");
  el.textContent="Running replication...";
  openModal("replication-modal");
  try{
    const target=RUN_STATE?.target||LAST_RUN?.target||document.getElementById("viz-target-label").textContent||"Topic";
    const out=await generateReplicationArtifact(target,cfg);
    el.textContent=String(out?.contentText||"Replication finished.");
    LAST_RUN={...(LAST_RUN||{}),replication:Array.isArray(out?.data)?out.data:[]};
  }catch(err){
    console.error("Replication failed:",err);
    el.textContent=`Replication failed:\n${err.message||err}`;
  }
  renderCAPanel();
}

export async function copyCritiqueText(){if(!lastCritiqueText){showToast("No critique text to copy.");return;}try{await navigator.clipboard.writeText(lastCritiqueText);showToast("Critique copied to clipboard.");}catch{showToast("Clipboard copy failed.");}}

export function artifactToCopyText(key){const item=ARTIFACT_STORE[key];if(!item) return "";if(item.contentText) return item.contentText;return JSON.stringify(item.data||{},null,2);}

export async function copyArtifact(key){if(!ARTIFACT_DEFS[key]) return;const isDerived=ARTIFACT_DEFS[key].kind==="derived";if(isDerived||!artifactCanOpenWithoutRegenerate(key)){await openArtifact(key,{regenerate:false,openAfter:false});}const text=artifactToCopyText(key);if(!text){showToast("No artifact text to copy.");return;}try{await navigator.clipboard.writeText(text);showToast(`${ARTIFACT_DEFS[key].name} copied.`);}catch{showToast("Clipboard copy failed.");}}

export function artifactFilenameBase(key){const target=(LAST_RUN?.target||RUN_STATE?.target||"run").toLowerCase().replace(/[^a-z0-9]+/g,"-").replace(/^-+|-+$/g,"")||"run";return `ruliad-${target}-${key}`;}

export async function downloadArtifact(key){if(!ARTIFACT_DEFS[key]) return;const isDerived=ARTIFACT_DEFS[key].kind==="derived";if(isDerived||!artifactCanOpenWithoutRegenerate(key)){await openArtifact(key,{regenerate:false,openAfter:false});}const item=ARTIFACT_STORE[key];if(!item||item.status!=="ready"){showToast("Artifact not available yet.");return;}const base=artifactFilenameBase(key);const text=artifactToCopyText(key);if(text){downloadBlob(`${base}.md`,new Blob([text],{type:"text/markdown"}));}if(item.data!==null&&item.data!==undefined){downloadBlob(`${base}.json`,new Blob([JSON.stringify(item.data,null,2)],{type:"application/json"}));}showToast(`${ARTIFACT_DEFS[key].name} downloaded.`);}

export async function copyActiveArtifact(){if(!ACTIVE_ARTIFACT_KEY) return;await copyArtifact(ACTIVE_ARTIFACT_KEY);}

export async function downloadActiveArtifact(){if(!ACTIVE_ARTIFACT_KEY) return;await downloadArtifact(ACTIVE_ARTIFACT_KEY);}

export async function generateDeepReportArtifact(target,cfg){const byType={unique:TERMS.filter(t=>t.type==="unique"),convergent:TERMS.filter(t=>t.type==="convergent"),contradictory:TERMS.filter(t=>t.type==="contradictory"),emergent:TERMS.filter(t=>t.type==="emergent")};const partySummaries=DISCS.map(d=>{const terms=TERMS.filter(t=>t.slices.includes(d.id)).map(t=>t.label);return `${d.name}: ${terms.slice(0,18).join(", ")}`;}).join("\n");const contras=byType.contradictory.map(t=>`${t.label} :: ${(t.slices||[]).map(i=>DISCS[i]?.name||`Probe ${i+1}`).join(" vs ")}`).join("\n");const emers=byType.emergent.map(t=>t.label).join(", ");const converg=byType.convergent.map(t=>`${t.label} (${t.slices.length} probes)`).join(", ");const citationLines=CITATIONS.map(c=>`- ${c.title||c.publisher||"Source"} (${c.date||"n.d."}) ${c.url} :: ${c.relevance||"supporting evidence"} [${c.source_type||"untyped"}]`).join("\n");const defaultSystemPrompt="You are a policy analyst writing a deep-research memo from structured multi-perspective evidence.";const userPromptBase=`Topic: ${target}\n\nSource policy: ${cfg.sourcePolicy||"none specified"}\n\nProbe specifications:\n${DISCS.map((d,i)=>`${i+1}. ${d.name}`).join("\n")}\n\nPer-probe key terms:\n${partySummaries}\n\nConvergent terms:\n${converg}\n\nContradictory terms:\n${contras}\n\nEmergent terms:\n${emers}\n\nEvidence sources:\n${citationLines||"- none captured"}\n\nWrite a concise but substantive report with sections:\n1) Executive Summary\n2) Major Alignments\n3) Major Fault Lines\n4) Integrative Policy Options\n5) Key Unknowns and Research Priorities\n6) Caveats\n\nUse clear, non-inflammatory language and cite terms from the map explicitly.`;const defaultUserPrompt=appendPromptMadLibBlock(userPromptBase,cfg,{includeArtifact:true});const promptBundle=resolvePromptBundleWithOverrides("artifact_deep_report",{target,cfg,quality:getQualityProfile(cfg.qualityMode),defaults:{systemPrompt:defaultSystemPrompt,userPrompt:defaultUserPrompt}});const cfgBudget=withArtifactTokenBudget(cfg,{minTokens:3200,multiplier:2.4,maxTokens:12000});const text=await callLLM(promptBundle.systemPrompt,promptBundle.userPrompt,cfgBudget);lastReportText=text;return {contentText:text,data:{text}};}

export async function generateClaimsArtifact(target,cfg){const emergent=TERMS.filter(t=>t.type==="emergent").map(t=>t.label);const contradictory=TERMS.filter(t=>t.type==="contradictory").map(t=>t.label);const reportText=lastReportText||LAST_RUN?.report||"";const defaultSystemPrompt="You are an analyst creating a claims ledger. Return strict JSON only.";const userPromptBase=`Topic: ${target}\n\nEmergent terms:\n${emergent.join(", ")||"-"}\n\nContradictory terms:\n${contradictory.join(", ")||"-"}\n\nReport excerpt:\n${reportText.slice(0,2000)||"(no report yet)"}\n\nReturn JSON only:\n{\n  "claims":[\n    {\n      "claim":"",\n      "confidence":"low|medium|high",\n      "claim_type":"empirical|normative|methodological|forecast",\n      "scope":"where it applies and does not apply",\n      "linked_nodes":["term label"],\n      "linked_evidence_ids":[0],\n      "evidence_status":"unverified|partial|verified",\n      "counterclaim":"best opposing formulation",\n      "what_would_change_mind":"",\n      "evidence_needed":"what kind of source would count",\n      "next_action":"one concrete verification step"\n    }\n  ]\n}\n\nRules:\n- Use concise, non-inflammatory language\n- If confidence is high, you must provide a falsifiable what_would_change_mind; otherwise set confidence to medium\n- Link claims to emergent or contradictory terms when possible`;const defaultUserPrompt=appendPromptMadLibBlock(userPromptBase,cfg,{includeArtifact:true});const promptBundle=resolvePromptBundleWithOverrides("artifact_claims",{target,cfg,quality:getQualityProfile(cfg.qualityMode),defaults:{systemPrompt:defaultSystemPrompt,userPrompt:defaultUserPrompt}});const cfgBudget=withArtifactTokenBudget(cfg,{minTokens:2200,multiplier:1.8,maxTokens:9000});const raw=await callLLMJSON(promptBundle.systemPrompt,promptBundle.userPrompt,cfgBudget);const parsed=extractJSON(raw);const claims=Array.isArray(parsed.claims)?parsed.claims:[];for(const c of claims){const conf=String(c.confidence||"").toLowerCase();const wcm=String(c.what_would_change_mind||"").trim();if(conf==="high"&&!wcm){c.confidence="medium";c.what_would_change_mind="Not specified; requires falsifiability.";}if(!c.evidence_status) c.evidence_status="unverified";if(!Array.isArray(c.linked_evidence_ids)) c.linked_evidence_ids=[];}const text=formatClaimsLedger(claims);lastClaimsText=text;return {contentText:text,data:claims};}

export async function generateOutlineArtifact(target,cfg){const converg=TERMS.filter(t=>t.type==="convergent").map(t=>t.label);const contras=TERMS.filter(t=>t.type==="contradictory").map(t=>t.label);const emergent=TERMS.filter(t=>t.type==="emergent").map(t=>t.label);const defaultSystemPrompt="You are an editor creating a structured outline from a research map.";const userPromptBase=`Topic: ${target}\n\nPick exactly 3 convergences, 2 fault lines (contradictions), and 1 emergent idea to anchor the outline.\nConvergences: ${converg.join(", ")}\nFault lines: ${contras.join(", ")}\nEmergent: ${emergent.join(", ")}\n\nReturn a structured outline with headings and bullet points, explicitly referencing the chosen nodes.`;const defaultUserPrompt=appendPromptMadLibBlock(userPromptBase,cfg,{includeArtifact:true});const promptBundle=resolvePromptBundleWithOverrides("artifact_outline",{target,cfg,quality:getQualityProfile(cfg.qualityMode),defaults:{systemPrompt:defaultSystemPrompt,userPrompt:defaultUserPrompt}});const cfgBudget=withArtifactTokenBudget(cfg,{minTokens:2200,multiplier:1.9,maxTokens:9000});const text=await callLLM(promptBundle.systemPrompt,promptBundle.userPrompt,cfgBudget);lastOutlineText=text;return {contentText:text,data:{text}};}

export async function generateRedTeamArtifact(target,cfg){const defaults={systemPrompt:"You are a skeptical reviewer.",userPrompt:buildRedTeamPrompt(target,RUN_STATE?.probeResults||[],RUN_STATE?.synthResult||{convergent:[],contradictory:[],emergent:[]},cfg)};const promptBundle=resolvePromptBundleWithOverrides("artifact_red_team",{target,cfg,quality:getQualityProfile(cfg.qualityMode),defaults});const cfgBudget=withArtifactTokenBudget(cfg,{minTokens:2400,multiplier:2.0,maxTokens:10000});const text=await callLLM(promptBundle.systemPrompt,promptBundle.userPrompt,cfgBudget);lastCritiqueText=text;return {contentText:text,data:{text}};}

export function buildReplicationCitationsFromProbeResults(probeResults){
  const out=[];
  let nextId=0;
  for(const probe of (Array.isArray(probeResults)?probeResults:[])){
    const discId=Number.isInteger(Number(probe?.discId))?Number(probe.discId):null;
    for(const cite of (Array.isArray(probe?.citations)?probe.citations:[])){
      const supporting=Array.isArray(cite?.supporting_terms)?cite.supporting_terms.map(t=>String(t||"").trim()).filter(Boolean):[];
      out.push({
        id:nextId++,
        source_type:normalizeSourceType(cite?.source_type,cite?.publisher),
        url:String(cite?.url||""),
        title:String(cite?.title||""),
        publisher:String(cite?.publisher||""),
        date:String(cite?.date||""),
        quote_or_snippet:String(cite?.quote_or_snippet||""),
        relevance:String(cite?.relevance||""),
        supporting_terms:supporting,
        supporting_terms_raw:supporting,
        supporting_term_mappings:[],
        unmapped_supporting_terms:[],
        probeId:discId
      });
    }
  }
  return out;
}

export async function generateReplicationArtifact(target,cfg){
  const models=(cfg.replicationModels||"").split(",").map(s=>s.trim()).filter(Boolean);
  if(!models.length) throw new Error("Add replication models (comma-separated) first.");
  if(!RUN_STATE?.probeResults?.length) throw new Error("Run a baseline expedition first.");
  const runCount=clampInt(cfg.replicationRuns||1,1,5);
  const strategy=cfg.replicationStrategy||"fixed";
  const quality=getQualityProfile(cfg.qualityMode);
  const activeDiscs=DISCS.filter(d=>d?.kind!=="ca");
  const baseTerms=RUN_STATE.probeResults.flatMap(r=>(r.terms||[]).map(t=>String(t.label||"").trim()).filter(Boolean));
  const baseTermSet=new Set(baseTerms);
  const baseContras=new Set((RUN_STATE.synthResult?.contradictory||[]).map(t=>String(t.label||"").trim()).filter(Boolean));
  const baseEmerg=new Set((RUN_STATE.synthResult?.emergent||[]).map(t=>String(t.label||"").trim()).filter(Boolean));
  const overlap=(a,b)=>{const union=new Set([...a,...b]);if(!union.size) return 0;let inter=0;for(const v of a){if(b.has(v)) inter++;}return inter/union.size;};
  const termMissCounts=new Map();
  const results=[];
  for(const model of models){
    for(let runNo=1;runNo<=runCount;runNo++){
      try{
        const cfg2={...cfg,researchModel:model};
        if(strategy==="jitter"){
          const q=getQualityProfile(cfg.qualityMode);
          const jitter=((runNo%2===0)?0.04:-0.04);
          cfg2.qualityMode="balanced";
          cfg2.__tempOverride=Math.max(0,Math.min(1,q.temperature+jitter));
        }
        const probeSystemDefault=buildProbeSystemPrompt(cfg2);
        const probeSystemBundle=resolvePromptBundleWithOverrides("probe_system",{target,cfg:cfg2,quality,defaults:{systemPrompt:probeSystemDefault,userPrompt:""}});
        const probeResults=await Promise.all(activeDiscs.map(async(d)=>{
          const probeDefaults={systemPrompt:probeSystemBundle.systemPrompt||probeSystemDefault,userPrompt:buildProbeUserPrompt(target,d.name,quality,cfg2)};
          const probeBundle=resolvePromptBundleWithOverrides("probe_user",{discName:d.name,target,cfg:cfg2,quality,defaults:probeDefaults});
          let norm=await getProbeResultWithRecovery({target,discName:d.name,probeSystem:probeBundle.systemPrompt||probeSystemBundle.systemPrompt||probeSystemDefault,userMsg:probeBundle.userPrompt,cfg:cfg2});
          norm=await groundProbeTermsWithWolfram(norm,target,d.name,cfg2);
          return {discId:d.id,summary:norm.summary,terms:Array.isArray(norm.terms)?norm.terms:[],citations:Array.isArray(norm.citations)?norm.citations:[]};
        }));
        const synthResult=await getSynthesisResultWithRecovery(target,probeResults,quality,cfg2,{contextLabel:`replication_artifact_${model}_run_${runNo}`});
        const termSet=new Set(probeResults.flatMap(r=>(r.terms||[]).map(t=>String(t.label||"").trim()).filter(Boolean)));
        const contraSet=new Set((synthResult.contradictory||[]).map(t=>String(t.label||"").trim()).filter(Boolean));
        const emergSet=new Set((synthResult.emergent||[]).map(t=>String(t.label||"").trim()).filter(Boolean));
        for(const base of baseTermSet){if(!termSet.has(base)){termMissCounts.set(base,(termMissCounts.get(base)||0)+1);}}
        const replicationTerms=buildTermsForReplicationRun(probeResults,synthResult);
        const replicationCitations=buildReplicationCitationsFromProbeResults(probeResults);
        let caFingerprint=null;
        let caError="";
        if(cfg2.enableComputationalIrreducibility){
          try{
            caFingerprint=await deriveReplicationCAFingerprint(target,cfg2,probeResults,synthResult,replicationTerms,replicationCitations);
          }catch(err){
            caError=String(err?.message||err);
          }
        }
        results.push({
          model,
          run:runNo,
          termOverlap:overlap(baseTermSet,termSet),
          contradictionOverlap:overlap(baseContras,contraSet),
          emergentOverlap:overlap(baseEmerg,emergSet),
          synthCounts:{convergent:(synthResult.convergent||[]).length,contradictory:(synthResult.contradictory||[]).length,emergent:(synthResult.emergent||[]).length},
          caFingerprint,
          caError
        });
      }catch(err){
        results.push({model,run:runNo,error:err.message||String(err)});
      }
    }
  }
  const ok=results.filter(r=>!r.error);
  const stability=ok.length?ok.reduce((s,r)=>s+((r.termOverlap+r.contradictionOverlap+r.emergentOverlap)/3),0)/ok.length:0;
  const unstable=[...termMissCounts.entries()].filter(([,c])=>c>=Math.ceil((models.length*runCount)/2)).sort((a,b)=>b[1]-a[1]).slice(0,12).map(([term,count])=>`${term} (${count}/${models.length*runCount} misses)`);
  const lines=results.map(r=>{
    if(r.error) return `- ${r.model} [run ${r.run}]: ERROR ${r.error}`;
    const baseLine=`- ${r.model} [run ${r.run}]: term overlap ${(r.termOverlap*100).toFixed(1)}% | contradiction overlap ${(r.contradictionOverlap*100).toFixed(1)}% | emergent overlap ${(r.emergentOverlap*100).toFixed(1)}% | synth C/C/E ${r.synthCounts?.convergent||0}/${r.synthCounts?.contradictory||0}/${r.synthCounts?.emergent||0}`;
    if(r.caFingerprint&&typeof r.caFingerprint==="object"){
      const classLabel=formatWolframClassForReplication(r.caFingerprint.wolframClass,r.caFingerprint.wolframClassLabel);
      return `${baseLine} | CA Rule ${clampInt(Number(r.caFingerprint.rule)||0,0,255)} (${classLabel}) | vol trend ${String(r.caFingerprint.volatilityTrend||"stable")}`;
    }
    if(r.caError) return `${baseLine} | CA fingerprint error: ${r.caError}`;
    return baseLine;
  }).join("\n");
  const caSection=cfg.enableComputationalIrreducibility?formatReplicationCAFingerprintSection(results,models):"CA fingerprint stability:\n- disabled";
  const text=`Replication summary for ${target}:\n\nStrategy: ${strategy} | Runs/model: ${runCount}\nStability score: ${(stability*100).toFixed(1)}%\n\n${lines}\n\n${caSection}\n\nUnstable terms:\n${unstable.length?unstable.map(x=>`- ${x}`).join("\n"):"- none flagged"}`;
  return {contentText:text,data:results};
}

export async function generateMarkdownArtifact(target,cfg){const byType={convergent:TERMS.filter(t=>t.type==="convergent"),contradictory:TERMS.filter(t=>t.type==="contradictory"),emergent:TERMS.filter(t=>t.type==="emergent")};const citationLines=CITATIONS.map((c,i)=>`${i+1}. ${c.title||c.publisher||"Source"} (${c.date||"n.d."}) ${c.url}`).join("\n");const method=`Model: ${cfg.researchModel}\nEmbeddings: ${cfg.embeddingModel}\nQuality: ${cfg.qualityMode}\nWeb search: ${cfg.webSearch?"on":"off"}\nSource policy: ${cfg.sourcePolicy||"none"}`;const defaultSystemPrompt="You are a research assistant producing Substack-ready Markdown with citations and methods. Return Markdown only.";const userPromptBase=`Topic: ${target}\n\nConvergent terms:\n${byType.convergent.map(t=>t.label).join(", ")}\n\nContradictory terms:\n${byType.contradictory.map(t=>t.label).join(", ")}\n\nEmergent terms:\n${byType.emergent.map(t=>t.label).join(", ")}\n\nClaims ledger:\n${lastClaimsText||"(not generated)"}\n\nCitations:\n${citationLines||"(none)"}\n\nMethods:\n${method}\n\nReturn Markdown with:\n- Title + hook\n- Thesis\n- Map summary (convergent / contradictory / emergent)\n- Claims ledger table (if available)\n- Footnoted citations list\n- Methods appendix`;const defaultUserPrompt=appendPromptMadLibBlock(userPromptBase,cfg,{includeArtifact:true});const promptBundle=resolvePromptBundleWithOverrides("artifact_markdown",{target,cfg,quality:getQualityProfile(cfg.qualityMode),defaults:{systemPrompt:defaultSystemPrompt,userPrompt:defaultUserPrompt}});const cfgBudget=withArtifactTokenBudget(cfg,{minTokens:3000,multiplier:2.3,maxTokens:12000});const text=await callLLM(promptBundle.systemPrompt,promptBundle.userPrompt,cfgBudget);lastMarkdownText=text;return {contentText:text,data:{text}};}
