import { PROMPT_TEMPLATE_OVERRIDES, RUN_STATE, TERMS, lastReportText } from '../core/state.js';
import { clampInt } from '../core/utils.js';
import { getPromptPreviewDisciplineNames } from '../ui/prompt-preview.js';
import { getQualityProfile } from '../api/llm.js';
import { buildProbeSystemPrompt, buildProbeUserPrompt, buildRedTeamPrompt, buildSynthesisPrompt } from './prompt-builders.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Module: js/prompt/prompt-system.js

export const PROMPT_OVERRIDE_KINDS=["probe_system","probe_user","synthesis","lens_generation","artifact_deep_report","artifact_claims","artifact_outline","artifact_red_team","artifact_replication","artifact_markdown"];

export const PROMPT_KIND_META={
  probe_system:{label:"Probe system prompt",usage:"Prepended for every probe call as global system instruction.",scope:"global"},
  probe_user:{label:"Probe user prompt",usage:"Sent once per probe lens during probe generation.",scope:"lens"},
  synthesis:{label:"Synthesis prompt",usage:"Used once after probe results to produce convergent/contradictory/emergent terms.",scope:"global"},
  lens_generation:{label:"Lens-generation prompt",usage:"Used only when generating orthogonal probe lenses from the focus concept.",scope:"global"},
  artifact_deep_report:{label:"Artifact deep report prompt",usage:"Used when generating the deep report artifact.",scope:"global"},
  artifact_claims:{label:"Artifact claims prompt",usage:"Used when generating the claims ledger artifact.",scope:"global"},
  artifact_outline:{label:"Artifact outline prompt",usage:"Used when generating the outline artifact.",scope:"global"},
  artifact_red_team:{label:"Artifact red-team prompt",usage:"Used when running the red-team critique artifact.",scope:"global"},
  artifact_replication:{label:"Artifact replication prompt",usage:"Used when running replication artifact generation.",scope:"global"},
  artifact_markdown:{label:"Artifact markdown prompt",usage:"Used when generating markdown report artifact output.",scope:"global"}
};

export function getPromptKindMeta(kind){
  const normalized=normalizePromptOverrideKind(kind);
  return PROMPT_KIND_META[normalized]||{label:normalized,usage:"Custom prompt template.",scope:"global"};
}

export function normalizePromptOverrideKind(kind){const raw=String(kind||"").trim();return PROMPT_OVERRIDE_KINDS.includes(raw)?raw:"probe_user";}

export function normalizePromptOverrideDisciplineKey(discName){return String(discName||"").trim().toLowerCase().replace(/\s+/g," ");}

export function buildPromptOverrideKey(kind,discName=""){const normalizedKind=normalizePromptOverrideKind(kind);if(normalizedKind!=="probe_user") return `${normalizedKind}::global`;const normalizedDisc=normalizePromptOverrideDisciplineKey(discName);return normalizedDisc?`${normalizedKind}::disc:${normalizedDisc}`:`${normalizedKind}::global`;}

export function getPromptOverride(kind,discName=""){const normalizedKind=normalizePromptOverrideKind(kind);if(normalizedKind==="probe_user"){const scopedKey=buildPromptOverrideKey(normalizedKind,discName);if(PROMPT_TEMPLATE_OVERRIDES[scopedKey]) return {entry:PROMPT_TEMPLATE_OVERRIDES[scopedKey],key:scopedKey,scoped:true};const globalKey=buildPromptOverrideKey(normalizedKind,"");if(PROMPT_TEMPLATE_OVERRIDES[globalKey]) return {entry:PROMPT_TEMPLATE_OVERRIDES[globalKey],key:globalKey,scoped:false};return null;}const key=buildPromptOverrideKey(normalizedKind,"");if(!PROMPT_TEMPLATE_OVERRIDES[key]) return null;return {entry:PROMPT_TEMPLATE_OVERRIDES[key],key,scoped:false};}

export function setPromptOverride(kind,discName,systemPrompt,userPrompt){const normalizedKind=normalizePromptOverrideKind(kind);const key=buildPromptOverrideKey(normalizedKind,discName);PROMPT_TEMPLATE_OVERRIDES[key]={kind:normalizedKind,discName:normalizedKind==="probe_user"?String(discName||"").trim():"",systemPrompt:String(systemPrompt||""),userPrompt:String(userPrompt||""),updatedAt:new Date().toISOString()};}

export function clearPromptOverride(kind,discName){const key=buildPromptOverrideKey(kind,discName);delete PROMPT_TEMPLATE_OVERRIDES[key];}

export function getPromptTemplateVars({target="",discName="",quality=null,cfg={},kind=""}={}){const q=quality||getQualityProfile(cfg?.qualityMode);return {target:String(target||""),discipline:String(discName||""),quality_mode:String(q?.id||cfg?.qualityMode||"balanced"),probe_term_min:String(q?.probeTermMin??""),probe_term_max:String(q?.probeTermMax??""),synth_convergent:String(q?.synthConvergent??""),synth_contradictory:String(q?.synthContradictory??""),synth_emergent:String(q?.synthEmergent??""),source_policy:String(cfg?.sourcePolicy||""),kind:String(kind||"")};}

export function interpolatePromptTemplate(text,vars){const src=String(text||"");return src.replace(/\{\{\s*([a-z0-9_]+)\s*\}\}/gi,(_,key)=>Object.prototype.hasOwnProperty.call(vars,key)?String(vars[key]??""):"");}

export function resolvePromptBundleWithOverrides(kind,{discName="",target="",quality=null,cfg={},defaults={systemPrompt:"",userPrompt:""}}={}){const normalizedKind=normalizePromptOverrideKind(kind);const vars=getPromptTemplateVars({target,discName,quality,cfg,kind:normalizedKind});let systemPrompt=String(defaults.systemPrompt||"");let userPrompt=String(defaults.userPrompt||"");let status="Using default prompt template";const scoped=getPromptOverride(normalizedKind,discName);if(scoped&&scoped.entry){systemPrompt=interpolatePromptTemplate(String(scoped.entry.systemPrompt||systemPrompt),vars);userPrompt=interpolatePromptTemplate(String(scoped.entry.userPrompt||userPrompt),vars);status=`Using custom override (${scoped.key})`;return {systemPrompt,userPrompt,status,isOverride:true};}if(normalizedKind==="probe_user"){const probeSystemOverride=getPromptOverride("probe_system","");if(probeSystemOverride?.entry){systemPrompt=interpolatePromptTemplate(String(probeSystemOverride.entry.systemPrompt||systemPrompt),vars);status="Using probe_system custom override";return {systemPrompt,userPrompt,status,isOverride:true};}}return {systemPrompt,userPrompt,status,isOverride:false};}

export function buildDefaultPromptBundle(kind,{target,cfg,quality,discName}={}){let systemPrompt="";let userPrompt="";if(kind==="probe_system"){systemPrompt=buildProbeSystemPrompt(cfg);userPrompt="(No user prompt for this view.)";}else if(kind==="probe_user"){systemPrompt=buildProbeSystemPrompt(cfg);userPrompt=buildProbeUserPrompt(target,discName,quality,cfg);}else if(kind==="synthesis"){systemPrompt=buildProbeSystemPrompt(cfg);const previewRows=getPromptPreviewDisciplineNames().map((name,idx)=>({discId:idx,summary:`Preview summary for ${name}.`,terms:[{label:`${name} mechanism`,description:`${name} view on ${target}.`}],claims_or_findings:[`Preview claim from ${name}.`]}));userPrompt=buildSynthesisPrompt(target,previewRows,quality,cfg);}else if(kind==="lens_generation"){const built=buildLensGenerationPrompt(target,clampInt(document.getElementById("lens-count-input")?.value,2,12),cfg);systemPrompt=built.systemPrompt;userPrompt=built.userPrompt;}else{const built=buildPromptPreviewArtifactPrompts(kind,target,cfg);systemPrompt=built.systemPrompt;userPrompt=built.userPrompt;}return {systemPrompt,userPrompt};}

export function getEffectivePromptBundle(kind,{target,cfg,quality,discName}={}){const defaults=buildDefaultPromptBundle(kind,{target,cfg,quality,discName});return resolvePromptBundleWithOverrides(kind,{discName,target,quality,cfg,defaults});}

export function buildLensGenerationPrompt(target,count,cfg={}){const userPrompt=`Target concept: "${target}"\n\nGenerate exactly ${count} disciplines/lenses that are maximally orthogonal to each other while all still useful for studying the target.\n\nRules:\n- Prioritize conceptual distance between lenses\n- Avoid synonyms or near-duplicates\n- Include diverse levels: formal, empirical, social, normative, computational, historical, systems, etc. where useful\n- Keep each lens name concise (2-5 words)\n\nReturn JSON only:\n{\n  "disciplines": ["Lens 1", "Lens 2"]\n}`;return {systemPrompt:"You design research lens sets. Return only strict JSON.",userPrompt};}

export function buildPromptPreviewArtifactPrompts(kind,target,cfg){const byType={convergent:TERMS.filter(t=>t.type==="convergent").map(t=>t.label),contradictory:TERMS.filter(t=>t.type==="contradictory").map(t=>t.label),emergent:TERMS.filter(t=>t.type==="emergent").map(t=>t.label)};if(kind==="artifact_deep_report"){return {systemPrompt:"You are a policy analyst writing a deep-research memo from structured multi-perspective evidence.",userPrompt:`Topic: ${target}\nConvergent terms: ${byType.convergent.join(", ")||"-"}\nContradictory terms: ${byType.contradictory.join(", ")||"-"}\nEmergent terms: ${byType.emergent.join(", ")||"-"}\nSource policy: ${cfg.sourcePolicy||"none specified"}\nWrite sections: executive summary, alignments, fault lines, policy options, unknowns, caveats.`};}if(kind==="artifact_claims"){return {systemPrompt:"You are an analyst creating a claims ledger. Return strict JSON only.",userPrompt:`Topic: ${target}\nEmergent terms: ${byType.emergent.join(", ")||"-"}\nContradictory terms: ${byType.contradictory.join(", ")||"-"}\nReport excerpt: ${(lastReportText||"(no report yet)").slice(0,400)}\nReturn claims JSON with confidence, counterclaim, falsifiability, evidence-needed, next-action.`};}if(kind==="artifact_outline"){return {systemPrompt:"You are an editor creating a structured outline from a research map.",userPrompt:`Topic: ${target}\nPick exactly 3 convergences, 2 contradictions, and 1 emergent idea.\nReturn a structured outline with headings and bullets.`};}if(kind==="artifact_red_team"){return {systemPrompt:"You are a skeptical reviewer.",userPrompt:buildRedTeamPrompt(target,RUN_STATE?.probeResults||[],RUN_STATE?.synthResult||{convergent:[],contradictory:[],emergent:[]},cfg)};}if(kind==="artifact_replication"){return {systemPrompt:"You are a replication orchestrator for multi-model synthesis.",userPrompt:`Topic: ${target}\nReplication models: ${cfg.replicationModels||"(none set)"}\nRuns/model: ${clampInt(cfg.replicationRuns||1,1,5)}\nStrategy: ${cfg.replicationStrategy||"fixed"}\nCompute overlap of term, contradiction, emergent sets vs baseline.`};}return {systemPrompt:"You are a research assistant producing Substack-ready Markdown with citations and methods. Return Markdown only.",userPrompt:`Topic: ${target}\nConvergent: ${byType.convergent.join(", ")||"-"}\nContradictory: ${byType.contradictory.join(", ")||"-"}\nEmergent: ${byType.emergent.join(", ")||"-"}\nMethods include model, embedding model, quality, source policy.\nReturn markdown report with thesis, map summary, claims table, citations, methods appendix.`};}
