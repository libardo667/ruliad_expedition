import { DISCS, TERMS } from '../core/state.js';
import { toCanonicalKey } from './aliases.js';
import { getLinkedCitationsForTerm } from './citations.js';
import { clamp01 } from '../plot/plot-overlays.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Module: js/domain/grounding-status.js

export const KNOWN_RULE_CLASSES={
  0:{class:1,label:"fixed point"},
  4:{class:2,label:"periodic"},
  8:{class:2,label:"periodic"},
  18:{class:3,label:"chaotic"},
  22:{class:3,label:"chaotic"},
  30:{class:3,label:"chaotic"},
  32:{class:2,label:"periodic"},
  40:{class:2,label:"periodic"},
  41:{class:4,label:"complex"},
  45:{class:3,label:"chaotic"},
  54:{class:4,label:"complex"},
  60:{class:3,label:"chaotic"},
  72:{class:2,label:"periodic"},
  90:{class:3,label:"chaotic"},
  94:{class:4,label:"complex"},
  105:{class:3,label:"chaotic"},
  106:{class:4,label:"complex"},
  108:{class:2,label:"periodic"},
  110:{class:4,label:"complex"},
  126:{class:3,label:"chaotic"},
  128:{class:2,label:"periodic"},
  136:{class:2,label:"periodic"},
  146:{class:3,label:"chaotic"},
  150:{class:3,label:"chaotic"},
  160:{class:2,label:"periodic"},
  168:{class:2,label:"periodic"},
  170:{class:2,label:"periodic"},
  184:{class:2,label:"periodic"},
  200:{class:2,label:"periodic"},
  204:{class:2,label:"periodic"},
  240:{class:2,label:"periodic"},
  255:{class:1,label:"fixed point"}
};

export function isLocalDefinedTerm(term){
  const slices=Array.isArray(term?.slices)?term.slices.filter(i=>Number.isInteger(i)):[];
  if(!slices.length) return false;
  return slices.every(i=>String(DISCS?.[i]?.kind||"llm")==="ca");
}

export function getLLMProbeCount(){
  const llmCount=DISCS.filter(d=>String(d?.kind||"llm")!=="ca").length;
  return Math.max(1,llmCount||DISCS.length||1);
}

export function computeTermRelevanceScore(term){
  const centrality=clamp01(Number(term?.centrality??0.5));
  const sliceCount=Array.isArray(term?.slices)?term.slices.length:0;
  const probeCount=getLLMProbeCount();
  const probeCoverage=term?.type==="emergent"&&sliceCount===0?0.65:clamp01(sliceCount/probeCount);
  const recurrence=clamp01(sliceCount<=1?0:(sliceCount-1)/Math.max(1,probeCount-1));
  const typeSignal=term?.type==="contradictory"?0.98:term?.type==="convergent"?0.95:term?.type==="emergent"?0.86:0.56;
  return Number(clamp01((centrality*0.46)+(probeCoverage*0.24)+(recurrence*0.14)+(typeSignal*0.16)).toFixed(3));
}

export function computeTermEvidenceSupportScore(term){
  const citations=getLinkedCitationsForTerm(term);
  const count=citations.length;
  const researchSignal=count?Math.min(1,count/3):0;
  const sourceDiversityCount=new Set(citations.map(c=>String(c?.source_type||"").trim().toLowerCase()||"untyped")).size;
  const sourceDiversity=count?Math.min(1,sourceDiversityCount/Math.min(3,count)):0;
  const sliceCount=Array.isArray(term?.slices)?term.slices.length:0;
  const probeCoverage=clamp01(sliceCount/getLLMProbeCount());
  const structureSignal=term?.type==="convergent"||term?.type==="contradictory"?Math.max(probeCoverage,0.72):term?.type==="emergent"?0.58:probeCoverage;
  return Number(clamp01((researchSignal*0.68)+(sourceDiversity*0.12)+(structureSignal*0.2)).toFixed(3));
}

export function termScoreBand(score){
  const val=Number(score);
  if(!Number.isFinite(val)) return "low";
  if(val>=0.72) return "high";
  if(val>=0.48) return "medium";
  return "low";
}

export function getTermSignalModel(term){
  const relevanceScore=computeTermRelevanceScore(term);
  const evidenceSupportScore=computeTermEvidenceSupportScore(term);
  const relevanceBand=termScoreBand(relevanceScore);
  const evidenceBand=termScoreBand(evidenceSupportScore);
  const citationCount=getLinkedCitationsForTerm(term).length;
  const probeMentions=Array.isArray(term?.slices)?term.slices.length:0;
  const displayDescriptionSource=String(term?.description_source||"").trim().toLowerCase()||"unknown";
  return {relevanceScore,evidenceSupportScore,relevanceBand,evidenceBand,citationCount,probeMentions,displayDescriptionSource};
}

export function refreshTermSignalFields(terms=TERMS){
  for(const term of (Array.isArray(terms)?terms:[])){
    if(!term||typeof term!=="object") continue;
    const signal=getTermSignalModel(term);
    term.relevance_score=signal.relevanceScore;
    term.evidence_support_score=signal.evidenceSupportScore;
    term.display_description_source=signal.displayDescriptionSource;
  }
}
