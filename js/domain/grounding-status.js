import { DISCS, TERMS, WOLFRAM_GROUNDING_DIAGNOSTICS } from '../core/state.js';
import { normalizeGroundingEligibility, normalizeSourceType, waTermStatusLabel } from '../grounding/wolfram-grounding.js';
import { normalizeWolframDisplayMode } from './terms.js';
import { toCanonicalKey } from './aliases.js';
import { dedupeCasefold, getLinkedCitationsForTerm } from './citations.js';
import { clamp01, hasWolframGrounding } from '../plot/plot-overlays.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Source: ruliad_expedition_v1.1.html
// Module: js/domain/grounding-status.js

export const WA_GRAPH_STATUS_META={
  accepted:{label:"accepted",color:"#16a34a"},
  metadata_only:{label:"metadata-only",color:"#d97706"},
  rejected_category_mismatch:{label:"rejected_category_mismatch",color:"#dc2626"},
  rejected_low_confidence:{label:"rejected_low_confidence",color:"#ef4444"},
  no_plaintext:{label:"no_plaintext",color:"#64748b"}
};

export const WA_ACCEPTED_GROUNDING_STATUSES=new Set(["accepted","accepted_metadata_only","accepted_annotation_only"]);

export const TERM_GROUNDING_OUTCOME_META={
  grounded:{label:"WA grounded (applied)",color:"#16a34a"},
  metadata_only:{label:"WA grounded (metadata-only)",color:"#d97706"},
  rejected:{label:"WA unresolved",color:"#dc2626"},
  not_attempted:{label:"WA not attempted",color:"#64748b"},
  local_defined:{label:"Locally defined construct",color:"#0ea5e9"}
};

export const WA_TERM_STATUS_META={
  wa_grounded_applied:{label:"WA grounded (applied)",color:"#16a34a"},
  wa_grounded_metadata_only:{label:"WA grounded (metadata-only)",color:"#d97706"},
  wa_unresolved_mismatch:{label:"WA mismatch",color:"#dc2626"},
  wa_unresolved_low_confidence:{label:"WA low-confidence",color:"#ef4444"},
  wa_unresolved_no_plaintext:{label:"WA no plaintext",color:"#64748b"},
  wa_not_attempted:{label:"WA not attempted",color:"#64748b"},
  wa_not_suitable:{label:"WA not suitable for term type",color:"#0ea5e9"}
};

export const KNOWN_RULE_CLASSES={
  0:{class:1,label:"fixed point"},
  4:{class:2,label:"periodic"},
  8:{class:2,label:"periodic"},
  18:{class:3,label:"chaotic"},
  22:{class:3,label:"chaotic"},
  30:{class:3,label:"chaotic"},
  32:{class:2,label:"periodic"},
  40:{class:2,label:"periodic"},
  41:{class:4,label:"complex"},
  45:{class:3,label:"chaotic"},
  54:{class:4,label:"complex"},
  60:{class:3,label:"chaotic"},
  72:{class:2,label:"periodic"},
  90:{class:3,label:"chaotic"},
  94:{class:4,label:"complex"},
  105:{class:3,label:"chaotic"},
  106:{class:4,label:"complex"},
  108:{class:2,label:"periodic"},
  110:{class:4,label:"complex"},
  126:{class:3,label:"chaotic"},
  128:{class:2,label:"periodic"},
  136:{class:2,label:"periodic"},
  146:{class:3,label:"chaotic"},
  150:{class:3,label:"chaotic"},
  160:{class:2,label:"periodic"},
  168:{class:2,label:"periodic"},
  170:{class:2,label:"periodic"},
  184:{class:2,label:"periodic"},
  200:{class:2,label:"periodic"},
  204:{class:2,label:"periodic"},
  240:{class:2,label:"periodic"},
  255:{class:1,label:"fixed point"}
};

export function getNodeGroundingStatus(term){return String(term?.grounding?.groundingStatus||"not_attempted");}

export function termGroundingOutcomeLabel(outcome){return TERM_GROUNDING_OUTCOME_META[outcome]?.label||String(outcome||"not attempted");}

export function termGroundingOutcomeColor(outcome){return TERM_GROUNDING_OUTCOME_META[outcome]?.color||"#64748b";}

export function isLocalDefinedTerm(term){
  if(String(term?.grounding?.termOutcome||"").trim().toLowerCase()==="local_defined") return true;
  if(normalizeGroundingEligibility(term?.grounding?.groundingEligibility||"eligible")==="synthetic_local") return true;
  const slices=Array.isArray(term?.slices)?term.slices.filter(i=>Number.isInteger(i)):[];
  if(!slices.length) return false;
  return slices.every(i=>String(DISCS?.[i]?.kind||"llm")==="ca");
}

export function isWolframGroundingCitation(cite){
  if(!cite||typeof cite!=="object") return false;
  const isWolframSource=normalizeSourceType(cite?.source_type,cite?.publisher)==="wolfram"||/wolfram/i.test(String(cite?.publisher||""));
  if(!isWolframSource) return false;
  const status=String(cite?.grounding_status||"").trim();
  const confidence=String(cite?.grounding_confidence||"").trim();
  const score=Number(cite?.grounding_score);
  const reasons=Array.isArray(cite?.grounding_reasons)?cite.grounding_reasons:[];
  const interp=String(cite?.wolfram_input_interpretation||"").trim();
  const definition=String(cite?.wolfram_best_definition||"").trim();
  return Boolean(status||confidence||(Number.isFinite(score)&&score>0)||reasons.length||interp||definition);
}

export function getWolframCitationsForTerm(term){
  const linked=getLinkedCitationsForTerm(term);
  return linked.filter(cite=>isWolframGroundingCitation(cite));
}

export function getResearchCitationsForTerm(term){
  const linked=getLinkedCitationsForTerm(term);
  return linked.filter(cite=>normalizeSourceType(cite?.source_type,cite?.publisher)!=="wolfram");
}

export function getLLMProbeCount(){
  const llmCount=DISCS.filter(d=>String(d?.kind||"llm")!=="ca").length;
  return Math.max(1,llmCount||DISCS.length||1);
}

export function computeTermRelevanceScore(term){
  const centrality=clamp01(Number(term?.centrality??0.5));
  const sliceCount=Array.isArray(term?.slices)?term.slices.length:0;
  const probeCount=getLLMProbeCount();
  const probeCoverage=term?.type==="emergent"&&sliceCount===0?0.65:clamp01(sliceCount/probeCount);
  const recurrence=clamp01(sliceCount<=1?0:(sliceCount-1)/Math.max(1,probeCount-1));
  const typeSignal=term?.type==="contradictory"?0.98:term?.type==="convergent"?0.95:term?.type==="emergent"?0.86:0.56;
  return Number(clamp01((centrality*0.46)+(probeCoverage*0.24)+(recurrence*0.14)+(typeSignal*0.16)).toFixed(3));
}

export function computeTermEvidenceSupportScore(term){
  const researchCitations=getResearchCitationsForTerm(term);
  const researchCount=researchCitations.length;
  const researchSignal=researchCount?Math.min(1,researchCount/3):0;
  const sourceDiversityCount=new Set(researchCitations.map(c=>normalizeSourceType(c?.source_type,c?.publisher)||"untyped")).size;
  const sourceDiversity=researchCount?Math.min(1,sourceDiversityCount/Math.min(3,researchCount)):0;
  const sliceCount=Array.isArray(term?.slices)?term.slices.length:0;
  const probeCoverage=clamp01(sliceCount/getLLMProbeCount());
  const structureSignal=term?.type==="convergent"||term?.type==="contradictory"?Math.max(probeCoverage,0.72):term?.type==="emergent"?0.58:probeCoverage;
  return Number(clamp01((researchSignal*0.68)+(sourceDiversity*0.12)+(structureSignal*0.2)).toFixed(3));
}

export function termScoreBand(score){
  const val=Number(score);
  if(!Number.isFinite(val)) return "low";
  if(val>=0.72) return "high";
  if(val>=0.48) return "medium";
  return "low";
}

export function getTermGroundingReasonHints(term){
  const key=toCanonicalKey(term?.label||"");
  if(!key) return [];
  const reasons=[];
  for(const diag of (WOLFRAM_GROUNDING_DIAGNOSTICS||[])){
    if(toCanonicalKey(diag?.termLabel||"")!==key) continue;
    reasons.push(String(diag?.status||""));
    for(const reason of (Array.isArray(diag?.reasons)?diag.reasons:[])){reasons.push(String(reason||""));}
  }
  for(const cite of getWolframCitationsForTerm(term)){
    reasons.push(String(cite?.grounding_status||""));
    for(const reason of (Array.isArray(cite?.grounding_reasons)?cite.grounding_reasons:[])){reasons.push(String(reason||""));}
  }
  return dedupeCasefold(reasons.map(x=>String(x||"").trim().toLowerCase()).filter(Boolean),160);
}

export function deriveWaGroundingStatusKey(term,outcome=getTermGroundingOutcome(term)){
  const eligibility=normalizeGroundingEligibility(term?.grounding?.groundingEligibility||"eligible");
  if(outcome==="local_defined"||eligibility==="synthetic_local"||eligibility==="ca_bypassed") return "wa_not_suitable";
  if(outcome==="not_attempted") return "wa_not_attempted";
  if(outcome==="grounded") return "wa_grounded_applied";
  if(outcome==="metadata_only") return "wa_grounded_metadata_only";
  if(outcome!=="rejected") return "wa_not_attempted";
  const resolution=String(term?.grounding?.wolframResolution||"").trim().toLowerCase();
  const reasons=getTermGroundingReasonHints(term);
  const hasNoPlaintext=resolution.includes("no plaintext")||resolution.includes("no match")||reasons.some(r=>r.includes("no_plaintext")||r==="empty"||r.includes("parser_selection_exhausted"));
  if(hasNoPlaintext) return "wa_unresolved_no_plaintext";
  const hasMismatch=resolution.includes("category mismatch")||reasons.some(r=>r.startsWith("category_mismatch_")||r.includes("mismatch"));
  if(hasMismatch) return "wa_unresolved_mismatch";
  return "wa_unresolved_low_confidence";
}

export function deriveTermStateBadge(signal){
  if(!signal||typeof signal!=="object") return "Relevant | WA status pending";
  if(signal.waGroundingStatus==="wa_not_suitable") return "Relevant | Probe-local construct | No WA expectation";
  if(signal.researchSupported&&signal.waGroundingStatus.startsWith("wa_unresolved")) return "Relevant | Research-supported | WA unresolved";
  if(signal.waGroundingStatus==="wa_grounded_metadata_only") return "Relevant | WA metadata-only";
  if(signal.waGroundingStatus==="wa_grounded_applied") return "Relevant | WA grounded";
  if(signal.waGroundingStatus==="wa_not_attempted") return "Relevant | WA not attempted";
  return "Relevant | WA unresolved";
}

export function getTermSignalModel(term){
  const relevanceScore=computeTermRelevanceScore(term);
  const evidenceSupportScore=computeTermEvidenceSupportScore(term);
  const relevanceBand=termScoreBand(relevanceScore);
  const evidenceBand=termScoreBand(evidenceSupportScore);
  const outcome=getTermGroundingOutcome(term);
  const waGroundingStatus=deriveWaGroundingStatusKey(term,outcome);
  const waEligibility=normalizeGroundingEligibility(term?.grounding?.groundingEligibility||"eligible");
  const researchCitationCount=getResearchCitationsForTerm(term).length;
  const sourceCitationCount=getLinkedCitationsForTerm(term).length;
  const probeMentions=Array.isArray(term?.slices)?term.slices.length:0;
  const displayDescriptionSource=String(term?.description_source||"").trim().toLowerCase()||"unknown";
  const primarySupportSummary=researchCitationCount>0?`${researchCitationCount} non-WA citation(s)`:"none linked";
  const secondarySupportSummary=`${probeMentions} probe mention(s); type ${String(term?.type||"unknown")}`;
  const tertiarySupportSummary=waTermStatusLabel(waGroundingStatus);
  const researchSupported=researchCitationCount>0;
  const stateBadge=deriveTermStateBadge({relevanceScore,evidenceSupportScore,waGroundingStatus,researchSupported});
  return {relevanceScore,evidenceSupportScore,relevanceBand,evidenceBand,waGroundingStatus,waEligibility,displayDescriptionSource,researchCitationCount,sourceCitationCount,probeMentions,primarySupportSummary,secondarySupportSummary,tertiarySupportSummary,researchSupported,stateBadge,outcome};
}

export function refreshTermSignalFields(terms=TERMS){
  for(const term of (Array.isArray(terms)?terms:[])){
    if(!term||typeof term!=="object") continue;
    const signal=getTermSignalModel(term);
    term.relevance_score=signal.relevanceScore;
    term.evidence_support_score=signal.evidenceSupportScore;
    term.wa_eligibility=signal.waEligibility;
    term.wa_grounding_status=signal.waGroundingStatus;
    term.display_description_source=signal.displayDescriptionSource;
  }
}

export function getTermGroundingOutcome(term,{termDiags=null,termWolframCitations=null}={}){
  if(!term||typeof term!=="object") return "not_attempted";
  const status=getNodeGroundingStatus(term);
  const eligibility=normalizeGroundingEligibility(term?.grounding?.groundingEligibility||"eligible");
  const displayMode=normalizeWolframDisplayMode(term?.descriptions?.wolframDisplayMode||"auto");
  const termKey=toCanonicalKey(term?.label||"");
  const diagnostics=Array.isArray(termDiags)?termDiags:(termKey?(WOLFRAM_GROUNDING_DIAGNOSTICS||[]).filter(diag=>toCanonicalKey(diag?.termLabel||"")===termKey):[]);
  const wolframCitations=Array.isArray(termWolframCitations)?termWolframCitations:getWolframCitationsForTerm(term);
  const hasAcceptedDiag=diagnostics.some(diag=>Boolean(diag?.accepted)||WA_ACCEPTED_GROUNDING_STATUSES.has(String(diag?.status||"").trim().toLowerCase()));
  const hasAcceptedCite=wolframCitations.some(cite=>WA_ACCEPTED_GROUNDING_STATUSES.has(String(cite?.grounding_status||"").trim().toLowerCase()));
  const hasAccepted=status==="grounded"||hasAcceptedDiag||hasAcceptedCite;
  const localDefinedByEligibility=eligibility==="synthetic_local"||eligibility==="ca_bypassed";
  const hasWolframTrace=Boolean(status==="failed"||hasWolframGrounding(term)||wolframCitations.length||diagnostics.length||String(term?.descriptions?.wolframGrounding||"").trim());
  if(status==="grounded"||(hasAccepted&&displayMode==="append")) return "grounded";
  if(status==="partial") return "metadata_only";
  if(hasAccepted) return "metadata_only";
  if(localDefinedByEligibility) return "local_defined";
  if(hasWolframTrace||status==="partial") return "rejected";
  if(isLocalDefinedTerm(term)) return "local_defined";
  return "not_attempted";
}

export function getNodeGroundingConfidenceScore(term){const level=String(term?.grounding?.wolframConfidence?.level||"none").toLowerCase();const base=level==="high"?3:level==="medium"?2:level==="low"?1:0;const numeric=Number.isFinite(Number(term?.grounding?.wolframConfidence?.score))?Number(term.grounding.wolframConfidence.score):null;return numeric!==null?base+numeric:base;}
