import { RUN_STATE, TERMS } from '../core/state.js';
import { normalizeLabel } from './terms.js';
import { dedupeCasefold } from './citations.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Module: js/domain/aliases.js

export function toCanonicalKey(label){let key=normalizeLabel(label);key=key.replace(/\b(the|a|an)\b/g," ").replace(/\s+/g," ").trim();if(key.endsWith("s")&&key.length>4) key=key.slice(0,-1);return key;}

export function tokenSet(label){const parts=toCanonicalKey(label).split(" ").filter(Boolean);return new Set(parts);}

export function jaccardSimilarity(a,b){if(!a.size||!b.size) return 0;let common=0;for(const term of a){if(b.has(term)) common++;}return common/(a.size+b.size-common);}

export function aliasSimilarityScore(left,right){
  const a=toCanonicalKey(left);
  const b=toCanonicalKey(right);
  if(!a||!b) return 0;
  if(a===b) return 1;
  const aTokens=tokenSet(a);
  const bTokens=tokenSet(b);
  let score=jaccardSimilarity(aTokens,bTokens);
  if(a.includes(b)||b.includes(a)){
    const ratio=Math.min(a.length,b.length)/Math.max(a.length,b.length,1);
    score=Math.max(score,0.72+(0.22*ratio));
  }
  return Math.max(0,Math.min(0.99,score));
}

export function matchTermFromAliasCandidate(label,terms){
  const canon=toCanonicalKey(label);
  if(!canon||!Array.isArray(terms)||!terms.length) return null;
  const exact=terms.find(term=>toCanonicalKey(term.label)===canon);
  if(exact) return {term:exact,score:1,strategy:"exact"};
  let best=null;
  let second=null;
  for(const term of terms){
    const score=aliasSimilarityScore(label,term.label);
    if(!best||score>best.score){second=best;best={term,score};}
    else if(!second||score>second.score){second={term,score};}
  }
  if(!best) return null;
  const shortSingleWord=canon.split(" ").length===1&&canon.length<5;
  if(shortSingleWord&&best.score<0.9) return null;
  if(best.score>=0.84&&(!second||best.score-second.score>=0.05)) return {term:best.term,score:best.score,strategy:"fuzzy"};
  return null;
}

export function buildTermAliasIndex(){
  const aliasByTerm=new Map();
  const terms=Array.isArray(TERMS)?TERMS:[];
  const addAlias=(term,alias,source)=>{
    if(!term) return;
    const text=String(alias||"").trim();
    const canon=toCanonicalKey(text);
    if(!text||!canon) return;
    let bucket=aliasByTerm.get(term.label);
    if(!bucket){
      bucket={termLabel:term.label,termRef:term,aliases:new Map()};
      aliasByTerm.set(term.label,bucket);
    }
    const existing=bucket.aliases.get(canon);
    if(existing){
      existing.sources=[...new Set([...(existing.sources||[]),source])];
      if(text.length>String(existing.alias||"").length) existing.alias=text;
      return;
    }
    bucket.aliases.set(canon,{alias:text,sources:[source]});
  };
  for(const term of terms){
    addAlias(term,term.label,"merged_label");
    const interpretations=Array.isArray(term?.grounding?.wolframInterpretations)?term.grounding.wolframInterpretations:[];
    for(const interpretation of interpretations){addAlias(term,interpretation,"wolfram_interpretation");}
    if(term?.grounding?.wolframChosenInterpretation){addAlias(term,term.grounding.wolframChosenInterpretation,"wolfram_chosen");}
  }
  for(const probe of (RUN_STATE?.probeResults||[])){
    for(const probeTerm of (probe?.terms||[])){
      const label=String(probeTerm?.label||"").trim();
      if(!label) continue;
      const matched=matchTermFromAliasCandidate(label,terms);
      if(matched?.term) addAlias(matched.term,label,"probe_label");
    }
  }
  for(const key of ["convergent","contradictory","emergent"]){
    for(const item of (RUN_STATE?.synthResult?.[key]||[])){
      const label=String(item?.label||"").trim();
      if(!label) continue;
      const matched=matchTermFromAliasCandidate(label,terms);
      if(matched?.term) addAlias(matched.term,label,"synthesis_label");
    }
  }
  const entries=[];
  const byCanonical=new Map();
  for(const bucket of aliasByTerm.values()){
    const aliasList=[...bucket.aliases.values()].map(item=>String(item.alias||"").trim()).filter(Boolean);
    if(bucket.termRef){bucket.termRef.aliases=dedupeCasefold(aliasList,120);}
    for(const [canon,aliasMeta] of bucket.aliases.entries()){
      const entry={termLabel:bucket.termLabel,canonical:canon,alias:aliasMeta.alias,sources:[...(aliasMeta.sources||[])]};
      entries.push(entry);
      if(!byCanonical.has(canon)) byCanonical.set(canon,[]);
      byCanonical.get(canon).push(entry);
    }
  }
  return {entries,byCanonical};
}

export function mapSupportingTermsWithAliases(supportingTermsRaw,aliasIndex){
  const mappedTerms=new Set();
  const mappings=[];
  const unmapped=[];
  const rawTerms=Array.isArray(supportingTermsRaw)?supportingTermsRaw:[];
  const byCanonical=aliasIndex?.byCanonical instanceof Map?aliasIndex.byCanonical:new Map();
  const entries=Array.isArray(aliasIndex?.entries)?aliasIndex.entries:[];
  for(const rawTerm of rawTerms){
    const text=String(rawTerm||"").trim();
    const canon=toCanonicalKey(text);
    if(!text||!canon) continue;
    const exactHits=byCanonical.get(canon)||[];
    if(exactHits.length===1){
      const hit=exactHits[0];
      mappedTerms.add(hit.termLabel);
      mappings.push({supporting_term:text,mapped_term:hit.termLabel,via_alias:hit.alias,strategy:"exact",confidence:1});
      continue;
    }
    if(exactHits.length>1){
      const ranked=[...exactHits].sort((a,b)=>String(b.alias||"").length-String(a.alias||"").length);
      const hit=ranked[0];
      mappedTerms.add(hit.termLabel);
      mappings.push({supporting_term:text,mapped_term:hit.termLabel,via_alias:hit.alias,strategy:"exact_ambiguous",confidence:0.94});
      continue;
    }
    let best=null;
    let second=null;
    for(const entry of entries){
      const score=aliasSimilarityScore(text,entry.alias);
      if(!best||score>best.score){second=best;best={entry,score};}
      else if(!second||score>second.score){second={entry,score};}
    }
    const margin=best&&second?best.score-second.score:best?best.score:0;
    const threshold=canon.split(" ").length<=1?0.9:0.79;
    if(best&&best.score>=threshold&&margin>=0.03){
      mappedTerms.add(best.entry.termLabel);
      mappings.push({supporting_term:text,mapped_term:best.entry.termLabel,via_alias:best.entry.alias,strategy:"fuzzy",confidence:Number(best.score.toFixed(3))});
    }else{
      unmapped.push(text);
    }
  }
  return {mappedTerms:[...mappedTerms],mappings,unmapped:dedupeCasefold(unmapped,120)};
}
