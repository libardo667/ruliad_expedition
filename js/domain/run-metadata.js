import { ARTIFACT_STORE, CALL_LOGS, CA_PROBE_OUTPUT, CITATIONS, CURRENT_RUN_ID, DISCS, DISC_SIM_MATRIX, LAST_RUN, PROJECTION_STABILITY, PROMPT_TEMPLATE_OVERRIDES, RUN_STATE, TERMS } from '../core/state.js';
import { clampInt, hashString, structuredCloneSafe } from '../core/utils.js';
import { callLLMJSON } from '../api/llm.js';
import { extractJSON } from '../api/json-recovery.js';
import { defaultDescriptionLayers } from './terms.js';
import { toCanonicalKey } from './aliases.js';
import { getTermSignalModel, refreshTermSignalFields } from './grounding-status.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Source: ruliad_expedition_v1.1.html
// Module: js/domain/run-metadata.js

export function getRunFingerprint(){const target=RUN_STATE?.target||document.getElementById("target-input")?.value.trim()||"";const probes=(DISCS||[]).map(d=>d.name);const synth=RUN_STATE?.synthResult||LAST_RUN?.synthResult||{convergent:[],contradictory:[],emergent:[]};const synthLabels=[...(synth.convergent||[]).map(x=>x.label||""),...(synth.contradictory||[]).map(x=>x.label||""),...(synth.emergent||[]).map(x=>x.label||"")].filter(Boolean);return hashString(JSON.stringify({target,probes,synthLabels,citationCount:CITATIONS.length,termCount:TERMS.length}));}

export function safeConfigForRun(cfg){return {
  mode:cfg.mode,
  researchModel:cfg.researchModel,
  embeddingModel:cfg.embeddingModel,
  qualityMode:cfg.qualityMode,
  webSearch:Boolean(cfg.webSearch),
  sourcePolicy:cfg.sourcePolicy||"",
  redTeam:Boolean(cfg.redTeam),
  replicationModels:cfg.replicationModels||"",
  replicationRuns:clampInt(cfg.replicationRuns||1,1,5),
  replicationStrategy:cfg.replicationStrategy||"fixed",
  enableComputationalIrreducibility:Boolean(cfg.enableComputationalIrreducibility),
  caMode:Boolean(cfg.enableComputationalIrreducibility)?"run_derived":"disabled",
  caRuleOverride:Number.isFinite(Number(cfg?.caRuleOverride))?clampInt(Number(cfg.caRuleOverride),0,255):Number.isFinite(Number(cfg?.caRule))?clampInt(Number(cfg.caRule),0,255):null,
  caStepsOverride:Number.isFinite(Number(cfg?.caStepsOverride))?clampInt(Number(cfg.caStepsOverride),16,240):Number.isFinite(Number(cfg?.caSteps))?clampInt(Number(cfg.caSteps),16,240):null,
  caWidthOverride:Number.isFinite(Number(cfg?.caWidthOverride))?clampInt(Number(cfg.caWidthOverride),31,401):Number.isFinite(Number(cfg?.caWidth))?clampInt(Number(cfg.caWidth),31,401):null,
  caRule:Number.isFinite(Number(cfg?.caRuleOverride))?clampInt(Number(cfg.caRuleOverride),0,255):Number.isFinite(Number(cfg?.caRule))?clampInt(Number(cfg.caRule),0,255):null,
  caSteps:Number.isFinite(Number(cfg?.caStepsOverride))?clampInt(Number(cfg.caStepsOverride),16,240):Number.isFinite(Number(cfg?.caSteps))?clampInt(Number(cfg.caSteps),16,240):null,
  caWidth:Number.isFinite(Number(cfg?.caWidthOverride))?clampInt(Number(cfg.caWidthOverride),31,401):Number.isFinite(Number(cfg?.caWidth))?clampInt(Number(cfg.caWidth),31,401):null,
  promptTemplateOverrides:structuredCloneSafe(PROMPT_TEMPLATE_OVERRIDES),
  sourceUrls:Array.isArray(cfg.sourceUrls)?cfg.sourceUrls:[],
  sourceByDiscKeys:cfg.sourceByDisc?Object.keys(cfg.sourceByDisc):[]
};}

export function computeRunId(payload){return `run_${hashString(JSON.stringify(payload))}`;}

export function serializeTermForRun(term){
  const signal=getTermSignalModel(term);
  return {
    label:term.label,
    description:term.description,
    descriptions:structuredCloneSafe(term.descriptions||defaultDescriptionLayers()),
    centrality:term.centrality,
    slices:[...term.slices],
    type:term.type,
    pos:[...(term.pos||[0,0,0])],
    citations:[...(term.citations||[])],
    aliases:Array.isArray(term.aliases)?[...term.aliases]:[],
    description_source:term.description_source||"",
    description_provenance:structuredCloneSafe(term.description_provenance||[]),
    relevance_score:signal.relevanceScore,
    evidence_support_score:signal.evidenceSupportScore,
    display_description_source:signal.displayDescriptionSource
  };
}

export function buildRunSnapshot(target,probeResults,synthResult,cfg){
  refreshTermSignalFields(TERMS);
  return {
    schemaVersion:6,
    runId:CURRENT_RUN_ID||null,
    target,
    probeResults,
    synthResult,
    generatedAt:new Date().toISOString(),
    config:safeConfigForRun(cfg),
    sourcePolicy:cfg.sourcePolicy||"",
    discs:DISCS.map(d=>({id:d.id,name:d.name,abbr:d.abbr,col:d.col,kind:d.kind||"llm"})),
    terms:TERMS.map(serializeTermForRun),
    citations:[...CITATIONS],
    auditTrail:[...CALL_LOGS],
    embeddingDiagnostics:{similarityMatrix:structuredCloneSafe(DISC_SIM_MATRIX),projectionStability:structuredCloneSafe(PROJECTION_STABILITY)},
    artifacts:structuredCloneSafe(ARTIFACT_STORE),
    report:LAST_RUN?.report||"",
    claimsLedger:LAST_RUN?.claimsLedger||[],
    redTeamCritique:LAST_RUN?.redTeamCritique||"",
    replication:LAST_RUN?.replication||[],
    outline:LAST_RUN?.outline||"",
    markdown:LAST_RUN?.markdown||"",
    caProbe:structuredCloneSafe(CA_PROBE_OUTPUT)
  };
}

export function applyRenameMapToResults(probeResults,synthResult,renameMap){const normMap=new Map();for(const pair of (renameMap||[])){const from=String(pair.from||"").trim();const to=String(pair.to||"").trim();if(!from||!to) continue;normMap.set(toCanonicalKey(from),to);}if(!normMap.size) return;const rename=(label)=>normMap.get(toCanonicalKey(label))||label;for(const probe of probeResults){for(const term of (probe.terms||[])){term.label=rename(term.label);}}for(const key of ["convergent","contradictory","emergent"]){for(const item of (synthResult[key]||[])){item.label=rename(item.label);}}}

export async function applySecondPassCleanup(target,probeResults,synthResult,cfg){const pool=[];for(const r of probeResults){for(const t of (r.terms||[])){if(t?.label) pool.push(String(t.label));}}for(const k of ["convergent","contradictory","emergent"]){for(const t of (synthResult[k]||[])){if(t?.label) pool.push(String(t.label));}}const uniq=[...new Set(pool.map(s=>s.trim()).filter(Boolean))];if(uniq.length<2) return;const prompt=`Target concept: "${target}"\n\nTerms:\n${uniq.map((t,i)=>`${i+1}. ${t}`).join("\n")}\n\nReturn JSON only:\n{\n  "rename_map":[{"from":"Variant wording","to":"Canonical wording"}]\n}\n\nRules:\n- Only include entries when two terms are near duplicates of the same concept\n- Keep "to" concise and neutral\n- Do not merge genuinely different concepts`;const raw=await callLLMJSON("You normalize research term lists. Return strict JSON.",prompt,cfg);const parsed=extractJSON(raw);applyRenameMapToResults(probeResults,synthResult,Array.isArray(parsed.rename_map)?parsed.rename_map:[]);}
