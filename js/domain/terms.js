import { TYPE_PRIORITY } from '../core/constants.js';
import { DISCS, TERMS, setTerms } from '../core/state.js';
import { jaccardSimilarity, toCanonicalKey, tokenSet } from './aliases.js';
import { mergeDescriptionProvenance, mergeDescriptionSource } from './citations.js';
import { clamp01 } from '../plot/plot-overlays.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Source: ruliad_expedition_v1.1.html
// Module: js/domain/terms.js

export function buildTermsForReplicationRun(probeResults,synthResult){
  const raw=[];
  const safeProbes=Array.isArray(probeResults)?probeResults:[];
  const safeSynth=synthResult&&typeof synthResult==="object"?synthResult:{convergent:[],contradictory:[],emergent:[]};
  for(const probe of safeProbes){
    const discId=Number(probe?.discId);
    const disc=DISCS[discId];
    if(!disc) continue;
    for(const term of (Array.isArray(probe?.terms)?probe.terms:[])){
      const source=String(term?.description_source||"").trim().toLowerCase()||"llm";
      const provenance=mergeDescriptionProvenance(term?.description_provenance,[{source,stage:"probe",discId,discName:disc.name,note:"Probe model description"}]);
      addRawTerm(raw,{label:term?.label,description:term?.description,descriptions:term?.descriptions,centrality:term?.centrality,slices:[discId],type:"unique",description_source:source,description_provenance:provenance});
    }
  }
  for(const item of (Array.isArray(safeSynth?.convergent)?safeSynth.convergent:[])){
    const ids=(Array.isArray(item?.disciplines)?item.disciplines:[]).filter(i=>Number.isInteger(i)&&i>=0&&i<DISCS.length);
    if(!ids.length) continue;
    addRawTerm(raw,{label:item?.label,description:item?.description,descriptions:{synthesisSummary:String(item?.description||"")},centrality:0.6,slices:ids,type:"convergent",description_source:"synthesis",description_provenance:[{source:"synthesis",stage:"synthesis",note:"Cross-probe convergence"}]});
  }
  for(const item of (Array.isArray(safeSynth?.contradictory)?safeSynth.contradictory:[])){
    const ids=(Array.isArray(item?.disciplines)?item.disciplines:[]).filter(i=>Number.isInteger(i)&&i>=0&&i<DISCS.length);
    if(!ids.length) continue;
    addRawTerm(raw,{label:item?.label,description:item?.description,descriptions:{synthesisSummary:String(item?.description||"")},centrality:0.5,slices:ids,type:"contradictory",description_source:"synthesis",description_provenance:[{source:"synthesis",stage:"synthesis",note:"Cross-probe contradiction"}]});
  }
  for(const item of (Array.isArray(safeSynth?.emergent)?safeSynth.emergent:[])){
    addRawTerm(raw,{label:item?.label,description:item?.description,descriptions:{synthesisSummary:String(item?.description||"")},centrality:0.5,slices:[],type:"emergent",description_source:"synthesis",description_provenance:[{source:"synthesis",stage:"synthesis",note:"Emergent synthesis insight"}]});
  }
  return mergeRawTerms(raw);
}

export function makeAbbr(name){const words=name.split(/[\s/]+/).filter(Boolean);if(words.length>=2) return (words[0][0]+words[1][0]).toUpperCase();return name.substring(0,2).toUpperCase();}

export function normalizeLabel(label){return String(label||"").toLowerCase().normalize("NFKD").replace(/[^\w\s]|_/g," ").replace(/\s+/g," ").trim();}

export function mergeType(a,b){return (TYPE_PRIORITY[b]||0)>(TYPE_PRIORITY[a]||0)?b:a;}

export function pickBetterLabel(current,next){if(!current) return next;if(!next) return current;return next.length>current.length?next:current;}

export function mergeDescription(a,b){const chunks=[String(a||"").trim(),String(b||"").trim()].filter(Boolean);if(!chunks.length) return "";if(chunks.length===1) return chunks[0];if(chunks[0].toLowerCase()===chunks[1].toLowerCase()) return chunks[0];return `${chunks[0]} ${chunks[1]}`.trim();}

export function defaultDescriptionLayers(){return {probeSummary:"",synthesisSummary:"",displayDescription:"",displayDescriptionReason:""};}

export function inferDescriptionSourceFromLayers(descriptions,fallbackSource){
  const reason=String(descriptions?.displayDescriptionReason||"").toLowerCase();
  if(reason.includes("synthesissummary")) return "synthesis";
  if(reason.includes("probesummary")) return "llm";
  return String(fallbackSource||"").trim().toLowerCase()||"llm";
}

export function computeDisplayDescriptionFromLayers(descriptions){
  const probeSummary=String(descriptions?.probeSummary||"").trim();
  const synthesisSummary=String(descriptions?.synthesisSummary||"").trim();
  const display=synthesisSummary||probeSummary||"";
  const reason=synthesisSummary?"synthesisSummary":probeSummary?"probeSummary":"none";
  return {displayDescription:display,displayDescriptionReason:reason};
}

export function normalizeTermDescriptions(raw,{fallbackDescription="",fallbackSource="",label=""}={}){
  const base=defaultDescriptionLayers();
  const src=raw&&typeof raw==="object"?raw:{};
  base.probeSummary=String(src.probeSummary||"").trim();
  base.synthesisSummary=String(src.synthesisSummary||"").trim();
  const fallback=String(fallbackDescription||"").trim();
  const source=String(fallbackSource||"").trim().toLowerCase();
  if(fallback){
    if(source==="synthesis") base.synthesisSummary=mergeDescription(base.synthesisSummary,fallback);
    else base.probeSummary=mergeDescription(base.probeSummary,fallback);
  }
  const selected=computeDisplayDescriptionFromLayers(base);
  base.displayDescription=selected.displayDescription||String(src.displayDescription||"").trim();
  base.displayDescriptionReason=selected.displayDescriptionReason||String(src.displayDescriptionReason||"").trim();
  return base;
}

export function mergeTermDescriptions(left,right,label){
  const a=normalizeTermDescriptions(left||{},{label});
  const b=normalizeTermDescriptions(right||{},{label});
  return normalizeTermDescriptions({
    probeSummary:mergeDescription(a.probeSummary,b.probeSummary),
    synthesisSummary:mergeDescription(a.synthesisSummary,b.synthesisSummary)
  },{label});
}

export function applyDisplayDescriptionForTerm(term,{fallbackDescription="",fallbackSource=""}={}){
  if(!term||typeof term!=="object") return term;
  term.descriptions=normalizeTermDescriptions(term.descriptions,{fallbackDescription,fallbackSource,label:term.label||""});
  term.description=String(term.descriptions.displayDescription||fallbackDescription||term.description||"").trim();
  term.description_source=inferDescriptionSourceFromLayers(term.descriptions,term.description_source||fallbackSource||"llm");
  return term;
}

export function addRawTerm(raw,node){
  const label=String(node.label||"").trim();
  if(!label) return;
  const slices=Array.isArray(node.slices)?node.slices.filter(i=>Number.isInteger(i)&&i>=0&&i<DISCS.length):[];
  const source=String(node.description_source||"").trim().toLowerCase()||(node.type==="emergent"||node.description_source==="synthesis"?"synthesis":"llm");
  const provenance=mergeDescriptionProvenance(node.description_provenance,[]);
  const descriptions=normalizeTermDescriptions(node.descriptions,{fallbackDescription:String(node.description||"").trim(),fallbackSource:source,label});
  raw.push({label,descriptions,description:String(descriptions.displayDescription||node.description||"").trim(),centrality:clamp01(Number(node.centrality||0.5)),slices:[...new Set(slices)],type:node.type||"unique",pos:[0,0,0],description_source:inferDescriptionSourceFromLayers(descriptions,source),description_provenance:provenance});
}

export function mergeRawTerms(rawTerms){
  const merged=[];
  for(const node of rawTerms){
    const key=toCanonicalKey(node.label);
    const tokens=tokenSet(node.label);
    let match=merged.find(m=>m.key===key);
    if(!match){
      match=merged.find(m=>jaccardSimilarity(m.tokens,tokens)>=0.86&&Math.abs(m.label.length-node.label.length)<=14&&m.type===node.type);
    }
    if(!match){
      const descriptions=normalizeTermDescriptions(node.descriptions,{fallbackDescription:node.description,fallbackSource:node.description_source,label:node.label});
      merged.push({key,tokens,label:node.label,descriptions,description:descriptions.displayDescription||node.description,centrality:node.centrality,slices:[...node.slices],type:node.type,pos:[0,0,0],description_source:inferDescriptionSourceFromLayers(descriptions,node.description_source||""),description_provenance:mergeDescriptionProvenance(node.description_provenance,[])});
      continue;
    }
    match.label=pickBetterLabel(match.label,node.label);
    match.descriptions=mergeTermDescriptions(match.descriptions,node.descriptions,match.label);
    match.description=String(match.descriptions.displayDescription||mergeDescription(match.description,node.description)).trim();
    match.centrality=Math.max(match.centrality,node.centrality);
    match.slices=[...new Set([...match.slices,...node.slices])];
    match.type=mergeType(match.type,node.type);
    match.description_source=inferDescriptionSourceFromLayers(match.descriptions,mergeDescriptionSource(match.description_source,node.description_source));
    match.description_provenance=mergeDescriptionProvenance(match.description_provenance,node.description_provenance);
    match.key=toCanonicalKey(match.label);
    match.tokens=tokenSet(match.label);
  }
  for(const term of merged){
    if(term.type==="unique"&&term.slices.length>1) term.type="convergent";
    if(!term.description_source) term.description_source=term.type==="emergent"?"synthesis":"llm";
    applyDisplayDescriptionForTerm(term,{fallbackDescription:term.description,fallbackSource:term.description_source});
  }
  return merged.map(({tokens,key,...rest})=>rest);
}

export function buildTerms(probeResults,synthResult){
  const raw=[];
  for(const r of probeResults){
    const d=DISCS[r.discId];
    if(!d) continue;
    for(const term of (r.terms||[])){
      const source=String(term.description_source||"").trim().toLowerCase()||"llm";
      const provenance=mergeDescriptionProvenance(term.description_provenance,[{source,stage:"probe",discId:r.discId,discName:d.name,note:"Probe model description"}]);
      addRawTerm(raw,{label:term.label,description:term.description,descriptions:term.descriptions,centrality:term.centrality,slices:[r.discId],type:"unique",description_source:source,description_provenance:provenance});
    }
  }
  for(const item of (synthResult.convergent||[])){
    const ids=(item.disciplines||[]).filter(i=>Number.isInteger(i)&&i>=0&&i<DISCS.length);
    if(!ids.length) continue;
    addRawTerm(raw,{label:item.label,description:item.description,descriptions:{synthesisSummary:String(item.description||"")},centrality:0.6,slices:ids,type:"convergent",description_source:"synthesis",description_provenance:[{source:"synthesis",stage:"synthesis",note:"Cross-probe convergence"}]});
  }
  for(const item of (synthResult.contradictory||[])){
    const ids=(item.disciplines||[]).filter(i=>Number.isInteger(i)&&i>=0&&i<DISCS.length);
    if(!ids.length) continue;
    addRawTerm(raw,{label:item.label,description:item.description,descriptions:{synthesisSummary:String(item.description||"")},centrality:0.5,slices:ids,type:"contradictory",description_source:"synthesis",description_provenance:[{source:"synthesis",stage:"synthesis",note:"Cross-probe contradiction"}]});
  }
  for(const item of (synthResult.emergent||[])){
    addRawTerm(raw,{label:item.label,description:item.description,descriptions:{synthesisSummary:String(item.description||"")},centrality:0.5,slices:[],type:"emergent",description_source:"synthesis",description_provenance:[{source:"synthesis",stage:"synthesis",note:"Emergent synthesis insight"}]});
  }
  setTerms(mergeRawTerms(raw));
}
