import { SOURCE_TYPE_LABELS } from '../core/constants.js';
import { CITATIONS, RUN_STATE, TERMS, setCitations, setCitationUnmappedSupportingTerms } from '../core/state.js';
import { buildTermAliasIndex, mapSupportingTermsWithAliases, toCanonicalKey } from './aliases.js';
import { refreshTermSignalFields } from './grounding-status.js';
import { markArtifactsStale } from '../artifacts/artifact-store.js';

// Auto-generated by tools/decompose.mjs â€” edit freely after generation
// Source: ruliad_expedition_v1.1.html
// Module: js/domain/citations.js

export function normalizeSourceType(type){
  const known=new Set(Object.keys(SOURCE_TYPE_LABELS));
  const t=String(type||"").trim().toLowerCase();
  if(known.has(t)) return t;
  return "";
}

export function upsertCitationEntry(cite){if(!cite||typeof cite!=="object") return null;const norm=normalizeCitation(cite);const key=(norm?.url||`${norm?.title}|${norm?.publisher}|${norm?.date}`).toLowerCase();if(!key) return null;const existing=CITATIONS.find(row=>(row?.url||`${row?.title}|${row?.publisher}|${row?.date}`).toLowerCase()===key);if(existing) return existing.id;const nextId=CITATIONS.reduce((max,row)=>Math.max(max,Number(row?.id)||-1),-1)+1;const entry={id:nextId,...norm};CITATIONS.push(entry);return nextId;}

export function sourceTypeLabel(sourceType,publisher){
  const key=normalizeSourceType(sourceType,publisher)||"untyped";
  return SOURCE_TYPE_LABELS[key]||SOURCE_TYPE_LABELS.reference;
}

export function normalizeAliasMappingEntry(item){if(!item||typeof item!=="object") return null;const supportingTerm=String(item.supporting_term||item.from||"").trim();const mappedTerm=String(item.mapped_term||item.to||"").trim();const viaAlias=String(item.via_alias||item.alias||"").trim();const strategy=String(item.strategy||"").trim()||"unknown";const confidence=Number(item.confidence);if(!supportingTerm||!mappedTerm) return null;return {supporting_term:supportingTerm,mapped_term:mappedTerm,via_alias:viaAlias||mappedTerm,strategy,confidence:Number.isFinite(confidence)?Math.max(0,Math.min(1,confidence)):null};}

export function normalizeCitation(item){
  const publisher=String(item?.publisher||"").trim();
  const supportingTerms=Array.isArray(item?.supporting_terms)?item.supporting_terms.map(t=>String(t||"").trim()).filter(Boolean):[];
  const supportingTermsRaw=Array.isArray(item?.supporting_terms_raw)?item.supporting_terms_raw.map(t=>String(t||"").trim()).filter(Boolean):supportingTerms.slice();
  const mappings=Array.isArray(item?.supporting_term_mappings)?item.supporting_term_mappings.map(normalizeAliasMappingEntry).filter(Boolean):[];
  const unmapped=Array.isArray(item?.unmapped_supporting_terms)?item.unmapped_supporting_terms.map(t=>String(t||"").trim()).filter(Boolean):[];
  return {
    url:String(item?.url||"").trim(),
    title:String(item?.title||"").trim(),
    publisher,
    date:String(item?.date||"").trim(),
    quote_or_snippet:String(item?.quote_or_snippet||"").trim(),
    relevance:String(item?.relevance||"").trim(),
    source_type:normalizeSourceType(item?.source_type,publisher),
    supporting_terms:supportingTerms,
    supporting_terms_raw:supportingTermsRaw,
    supporting_term_mappings:mappings,
    unmapped_supporting_terms:unmapped
  };
}

export function dedupeCasefold(values,maxItems=40){const out=[];const seen=new Set();for(const raw of (values||[])){const value=String(raw||"").trim();if(!value) continue;const key=value.toLowerCase();if(seen.has(key)) continue;seen.add(key);out.push(value);if(out.length>=maxItems) break;}return out;}

export function confidenceRank(level){const v=String(level||"").trim().toLowerCase();if(v==="high") return 3;if(v==="medium") return 2;if(v==="low") return 1;return 0;}

export function normalizeConfidenceLevel(level){const v=String(level||"").trim().toLowerCase();if(v==="high"||v==="medium"||v==="low") return v;return "none";}

export function betterConfidence(a,b){const left=normalizeConfidenceLevel(a);const right=normalizeConfidenceLevel(b);return confidenceRank(right)>confidenceRank(left)?right:left;}

export function normalizeProvenanceEntry(entry){if(!entry||typeof entry!=="object") return null;const source=String(entry.source||"").trim().toLowerCase();const stage=String(entry.stage||"").trim().toLowerCase();const note=String(entry.note||"").trim();const query=String(entry.query||"").trim();const impact=String(entry.impact||"").trim();const status=String(entry.status||"").trim();const discName=String(entry.discName||"").trim();const discId=Number.isInteger(entry.discId)?entry.discId:null;if(!source&&!stage&&!note&&!query&&!impact&&!status&&discId===null&&!discName) return null;return {source:source||"unknown",stage:stage||"unspecified",discId,discName,status,impact,query,note};}

export function mergeDescriptionProvenance(left,right){const out=[];const seen=new Set();for(const item of [...(left||[]),...(right||[])]){const norm=normalizeProvenanceEntry(item);if(!norm) continue;const key=JSON.stringify(norm);if(seen.has(key)) continue;seen.add(key);out.push(norm);}return out;}

export function mergeDescriptionSource(left,right){const a=String(left||"").trim().toLowerCase();const b=String(right||"").trim().toLowerCase();if(!a) return b||"";if(!b) return a;if(a===b) return a;return "mixed";}

export function collectCitations(){
  const prevCount=CITATIONS.length;
  setCitations([]);
  const map=new Map();
  const keyFor=(c)=>{
    if(c.url) return c.url.trim().toLowerCase();
    return `${c.title}|${c.publisher}|${c.date}`.toLowerCase();
  };
  for(const probe of (RUN_STATE?.probeResults||[])){
    for(const cite of (probe.citations||[])){
      const key=keyFor(cite);
      if(!key.trim()) continue;
      let entry=map.get(key);
      const incomingTerms=Array.isArray(cite.supporting_terms_raw)?cite.supporting_terms_raw:(Array.isArray(cite.supporting_terms)?cite.supporting_terms:[]);
      if(!entry){
        entry={
          id:CITATIONS.length,
          source_type:normalizeSourceType(cite.source_type,cite.publisher),
          url:cite.url||"",
          title:cite.title||"",
          publisher:cite.publisher||"",
          date:cite.date||"",
          quote_or_snippet:cite.quote_or_snippet||"",
          relevance:cite.relevance||"",
          supporting_terms:[...new Set(incomingTerms)],
          supporting_terms_raw:[...new Set(incomingTerms)],
          supporting_term_mappings:[],
          unmapped_supporting_terms:[],
          probeId:probe.discId
        };
        map.set(key,entry);
        CITATIONS.push(entry);
      }else{
        if(!entry.source_type&&cite.source_type) entry.source_type=normalizeSourceType(cite.source_type,cite.publisher);
        entry.supporting_terms_raw=[...new Set([...(entry.supporting_terms_raw||[]),...incomingTerms])];
        entry.supporting_terms=[...new Set([...(entry.supporting_terms||[]),...incomingTerms])];
      }
    }
  }
  const termMap=new Map();
  for(const term of TERMS){
    term.citations=[];
    termMap.set(toCanonicalKey(term.label),term);
  }
  const aliasIndex=buildTermAliasIndex();
  const unmappedGlobal=new Set();
  for(const cite of CITATIONS){
    const rawTerms=dedupeCasefold([...(cite.supporting_terms_raw||cite.supporting_terms||[])],160);
    const resolved=mapSupportingTermsWithAliases(rawTerms,aliasIndex);
    cite.supporting_terms_raw=rawTerms;
    cite.supporting_terms=dedupeCasefold(resolved.mappedTerms,120);
    cite.supporting_term_mappings=resolved.mappings;
    cite.unmapped_supporting_terms=resolved.unmapped;
    for(const raw of (resolved.unmapped||[])){unmappedGlobal.add(raw);}
    for(const t of (cite.supporting_terms||[])){
      const key=toCanonicalKey(t);
      const term=termMap.get(key);
      if(term&&!term.citations.includes(cite.id)) term.citations.push(cite.id);
    }
  }
  setCitationUnmappedSupportingTerms([...unmappedGlobal]);
  refreshTermSignalFields(TERMS);
  if(prevCount!==CITATIONS.length){
    markArtifactsStale(["claims","outline","deep_report","red_team","replication","markdown"]);
  }
}

export function getLinkedCitationsForTerm(term){const ids=Array.isArray(term?.citations)?term.citations:[];const out=[];for(const id of ids){const cite=CITATIONS.find(c=>c.id===id);if(cite) out.push(cite);}return out;}
