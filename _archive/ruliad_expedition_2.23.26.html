<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Ruliad Expedition Tool</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.27.0/plotly.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<style>
*{box-sizing:border-box;margin:0;padding:0}
:root{
  --bg:#f4f7ff;--panel:#ffffff;--panel-soft:#eef2ff;--panel-alt:#f8fafc;
  --border:#cfd8ee;--muted:#3a4764;--text:#0f172a;--accent:#1d4ed8;--accent-fg:#ffffff;
  --control-border:#94a3b8;--danger-bg:#7f1d1d;--danger-border:#ef4444;--danger-text:#ffffff;
  --sidebar-width:320px;--generation-left-width:1fr;
}
html[data-theme="dark"]{
  --bg:#0b1020;--panel:#111827;--panel-soft:#1e293b;--panel-alt:#0f172a;
  --border:#334155;--muted:#cbd5e1;--text:#f8fafc;--accent:#60a5fa;--accent-fg:#0b1020;
  --control-border:#64748b;--danger-bg:#7f1d1d;--danger-border:#f87171;--danger-text:#ffffff;
}
html[data-theme="contrast"]{
  --bg:#000000;--panel:#000000;--panel-soft:#000000;--panel-alt:#000000;
  --border:#ffffff;--muted:#ffffff;--text:#ffffff;--accent:#00ffff;--accent-fg:#000000;
  --control-border:#ffffff;--danger-bg:#000000;--danger-border:#ffff00;--danger-text:#ffff00;
}
body{background:var(--bg);color:var(--text);font-family:'Courier New',monospace;min-height:100vh;line-height:1.4}
a{color:var(--accent)}
#main-tabs{position:sticky;top:0;z-index:1000;display:flex;justify-content:space-between;align-items:center;gap:12px;padding:10px 14px;background:var(--panel);border-bottom:1px solid var(--border)}
.tabs-left{display:flex;gap:8px;align-items:center}
.tab-btn{background:var(--panel-soft);border:1px solid var(--control-border);color:var(--text);font-family:'Courier New',monospace;font-size:12px;letter-spacing:.5px;padding:8px 12px;border-radius:6px;cursor:pointer}
.tab-btn.active{border-color:var(--accent);color:var(--accent);box-shadow:0 0 0 2px #60a5fa55}
.tabs-right{display:flex;gap:8px;align-items:center}
.tabs-right select{width:170px;font-size:13px;padding:8px 10px}
#setup{width:100%;max-width:none;margin:0;padding:24px;display:flex;flex-direction:column;gap:20px}
.setup-section-stack{display:flex;flex-direction:column;gap:12px}
.setup-section{border:1px solid var(--border);border-radius:8px;background:var(--panel-alt);overflow:hidden}
.setup-section>summary{list-style:none;display:flex;justify-content:space-between;align-items:center;gap:8px;padding:12px 14px;cursor:pointer;font-size:12px;letter-spacing:.8px;color:var(--muted);background:var(--panel-soft)}
.setup-section>summary::-webkit-details-marker{display:none}
.setup-section[open]>summary{color:var(--accent);border-bottom:1px solid var(--border)}
.setup-section-body{display:flex;flex-direction:column;gap:12px;padding:14px}
.setup-help{display:inline-flex;align-items:center;justify-content:center;width:16px;height:16px;border:1px solid var(--control-border);border-radius:999px;font-size:11px;color:var(--muted);cursor:help}
.logo{font-size:11px;letter-spacing:3px;color:var(--muted);margin-bottom:4px}
h1{font-size:30px;color:var(--accent);letter-spacing:1px;line-height:1.2}
.sub{font-size:14px;color:var(--muted);letter-spacing:1px;margin-top:6px}
.workflow-card{border:1px solid var(--border);border-radius:8px;background:var(--panel);padding:12px;display:flex;flex-direction:column;gap:8px}
.workflow-title{font-size:12px;letter-spacing:.8px;color:var(--accent)}
.workflow-list{margin:0;padding-left:18px;display:flex;flex-direction:column;gap:6px}
.workflow-list li{font-size:12px;line-height:1.45;color:var(--muted)}
.workflow-note{font-size:12px;color:var(--muted);line-height:1.5}
.field-group{display:flex;flex-direction:column;gap:8px}
label{font-size:12px;letter-spacing:1px;color:var(--muted)}
input[type=text],input[type=password],input[type=number],select,textarea{background:var(--panel);border:1px solid var(--border);color:var(--text);font-family:'Courier New',monospace;font-size:16px;padding:12px 14px;border-radius:6px;width:100%;outline:none;transition:border-color .2s}
input[type=text]:focus,input[type=password]:focus,input[type=number]:focus,select:focus,textarea:focus{border-color:var(--accent)}
.api-row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
.prefs-row{display:grid;grid-template-columns:1fr 220px;gap:8px;align-items:center}
.prefs-row-single{grid-template-columns:1fr}
.prefs-row-wide{display:grid;grid-template-columns:1fr 1fr;gap:8px;align-items:center}
.mini-grid{display:grid;grid-template-columns:120px 1fr;gap:8px;align-items:center}
.lens-gen-row{display:grid;grid-template-columns:130px 1fr;gap:8px;align-items:center}
.api-key-row{display:flex;gap:8px}.api-key-row input{flex:1}
.mini-btn{background:var(--panel-soft);border:1px solid var(--control-border);color:var(--text);font-family:'Courier New',monospace;font-size:12px;letter-spacing:.5px;padding:0 12px;border-radius:6px;cursor:pointer;white-space:nowrap}
.mini-btn:hover{border-color:var(--accent);color:var(--accent)}
.tiny-note{font-size:12px;color:var(--muted);line-height:1.5}
.toggle-wrap{display:flex;align-items:center;gap:10px;padding:10px 12px;background:var(--panel);border:1px solid var(--border);border-radius:6px;color:var(--text)}
.toggle-wrap input[type=checkbox]{width:18px;height:18px;accent-color:var(--accent)}
.toggle-wrap label{margin:0;font-size:13px;letter-spacing:.4px;color:var(--muted)}
.disc-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
.disc-row{display:flex;align-items:center;gap:8px}
.disc-num{font-size:12px;color:var(--muted);width:18px;flex-shrink:0}
.disc-color{width:8px;height:8px;border-radius:2px;flex-shrink:0}
input.disc-input{flex:1;font-size:15px;padding:10px 12px}
.probe-del-btn{height:40px;padding:0 10px}
.probe-actions{display:flex;gap:8px;margin-top:6px}
.launch-btn{background:var(--accent);border:1px solid var(--accent);color:var(--accent-fg);font-family:'Courier New',monospace;font-size:14px;letter-spacing:1px;padding:14px 28px;cursor:pointer;border-radius:6px;transition:all .2s;align-self:flex-start}
.launch-btn:hover{filter:brightness(.92)}
.note{font-size:14px;color:var(--muted);line-height:1.7}
.prompt-workbench{display:grid;grid-template-columns:minmax(320px,var(--generation-left-width)) 10px minmax(320px,1fr);gap:10px;align-items:stretch}
.prompt-pane{border:1px solid var(--border);border-radius:8px;background:var(--panel-alt);padding:10px;display:flex;flex-direction:column;gap:8px;min-height:260px}
.prompt-workbench > .prompt-pane:not(#workbench-controls-pane){order:3}
#workbench-controls-pane{order:1}
.prompt-pane-title{font-size:11px;letter-spacing:.7px;color:var(--accent)}
.prompt-preview-controls{display:grid;grid-template-columns:1fr 1fr auto;gap:8px;align-items:end}
.compact-field{gap:4px}
.compact-field label{font-size:10px;letter-spacing:.7px}
.prompt-kind-help{font-size:12px;line-height:1.45;color:var(--muted);background:var(--panel);border:1px solid var(--border);border-radius:6px;padding:8px 10px}
.prompt-preview-disc-wrap-disabled{opacity:.68}
.prompt-readonly{min-height:180px;resize:vertical;font-size:12px;line-height:1.45}
.prompt-params{min-height:120px;resize:vertical;font-size:12px;line-height:1.45}
.prompt-editable{min-height:160px;resize:vertical;font-size:12px;line-height:1.45}
.prompt-status{font-size:12px;padding:8px 10px}
.prompt-override-summary{font-size:12px;line-height:1.45;color:var(--muted);border:1px dashed var(--border);border-radius:6px;padding:8px 10px;background:var(--panel)}
.prompt-override-chips{display:flex;flex-wrap:wrap;gap:6px;margin-top:6px}
.prompt-override-chip{font-size:10px;letter-spacing:.4px;border:1px solid var(--control-border);border-radius:999px;padding:2px 8px;color:var(--muted);background:var(--panel-soft)}
.madlibs-grid{display:grid;grid-template-columns:1fr;gap:8px}
.madlibs-grid textarea{min-height:72px;resize:vertical}
.prompt-workbench.resizing{user-select:none;cursor:col-resize}
#workbench-resizer{width:10px;cursor:col-resize;position:relative;background:transparent}
#workbench-resizer{order:2}
#workbench-resizer::before{content:"";position:absolute;left:4px;top:0;bottom:0;width:2px;background:var(--border)}
#workbench-resizer:hover::before,.prompt-workbench.resizing #workbench-resizer::before{background:var(--accent)}
#workbench-resizer:focus-visible{outline:none;box-shadow:inset 0 0 0 2px #60a5fa66}
.controls-pane{max-height:680px;overflow:auto;scrollbar-gutter:stable both-edges;padding-bottom:2px}
.workbench-sticky-nav{position:sticky;top:-1px;z-index:4;background:var(--panel-alt);border:1px solid var(--border);border-radius:8px;padding:6px;display:flex;flex-wrap:wrap;gap:6px}
.workbench-control-stack{display:flex;flex-direction:column;gap:10px}
.workbench-section{border:1px solid var(--border);border-radius:8px;background:var(--panel);padding:10px;display:flex;flex-direction:column;gap:8px}
fieldset.workbench-section{min-width:0}
.workbench-section-title{font-size:11px;letter-spacing:.7px;color:var(--accent)}
legend.workbench-section-title{padding:0 4px}
.workbench-advanced{padding:0}
.workbench-advanced > summary{list-style:none;cursor:pointer;padding:10px}
.workbench-advanced > summary::-webkit-details-marker{display:none}
.workbench-advanced-body{display:flex;flex-direction:column;gap:8px;padding:0 10px 10px}
.readiness-list{display:flex;flex-direction:column;gap:6px;padding-left:18px}
.readiness-list li{font-size:12px;line-height:1.45;color:var(--muted)}
.readiness-list li.ready{color:#16a34a}
.readiness-list li.warn{color:#d97706}
.readiness-list li.blocked{color:#dc2626}
.run-readiness-status{font-size:12px;letter-spacing:.4px;padding:8px 10px;border-radius:6px;border:1px solid var(--border);background:var(--panel-soft);color:var(--muted)}
.run-readiness-status.ready{border-color:#16a34a;color:#166534;background:#16a34a1c}
.run-readiness-status.blocked{border-color:#dc2626;color:#991b1b;background:#dc26261a}
.run-action-strip{position:sticky;bottom:-10px;z-index:3;background:linear-gradient(180deg,rgba(0,0,0,0) 0%,var(--panel) 20%);padding:10px 0 0;border-top:1px solid var(--border);margin-top:4px}
.workbench-jump-highlight{box-shadow:0 0 0 2px #60a5fa66}
#progress{display:none;max-width:760px;margin:0 auto;padding:48px 24px;flex-direction:column;gap:20px}
.prog-title{font-size:20px;color:var(--accent);letter-spacing:1px}
.prog-target{font-size:15px;color:var(--muted);letter-spacing:.5px;margin-top:6px}
.probe-list{display:flex;flex-direction:column;gap:8px}
.probe-item{display:flex;align-items:center;gap:12px;background:var(--panel);border:1px solid var(--border);padding:12px 14px;border-radius:6px;transition:border-color .3s}
.probe-item.running{border-color:#7cb9ff44}.probe-item.done{border-color:#00ff9f44}.probe-item.error{border-color:#ff444444}
.probe-dot{width:8px;height:8px;border-radius:50%;flex-shrink:0;transition:background .3s}
.probe-dot.idle{background:#222}.probe-dot.running{background:#7cb9ff;animation:pulse 1s infinite}.probe-dot.done{background:#00ff9f}.probe-dot.error{background:#ff4444}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.3}}
.probe-name{font-size:14px;flex:1}.probe-status{font-size:12px;color:var(--muted);letter-spacing:.5px}
.probe-item.running .probe-status{color:#7cb9ff}.probe-item.done .probe-status{color:#00ff9f}.probe-item.error .probe-status{color:#ff4444}
.synth-bar{background:var(--panel);border:1px solid var(--border);padding:12px 14px;border-radius:6px;font-size:14px;color:var(--muted);letter-spacing:.5px;transition:border-color .3s,color .3s}
.synth-bar.running{border-color:#ffd70044;color:#ffd700}.synth-bar.done{border-color:#ffd70088;color:#ffd700}.synth-bar.error{border-color:#ff444488;color:#ff8888}
#viz{display:none;height:100vh;flex-direction:column}
#viz-topbar{padding:12px 18px;border-bottom:1px solid var(--border);background:var(--panel);display:flex;justify-content:space-between;align-items:center;flex-shrink:0}
#viz-topbar-left{font-size:14px;color:var(--accent);letter-spacing:1px}
#viz-topbar-right{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.reset-btn{background:var(--panel);border:1px solid var(--control-border);color:var(--text);font-family:'Courier New',monospace;font-size:12px;letter-spacing:.5px;padding:6px 12px;cursor:pointer;border-radius:6px}
#viz-body{flex:1;display:flex;min-height:0}
#sidebar{width:var(--sidebar-width);flex-shrink:0;background:var(--panel);border-right:1px solid var(--border);padding:16px 14px;overflow-y:auto;display:flex;flex-direction:column;gap:18px}
#sidebar-resizer{width:10px;cursor:col-resize;flex-shrink:0;position:relative;background:transparent}
#sidebar-resizer::before{content:"";position:absolute;left:4px;top:0;bottom:0;width:2px;background:var(--border)}
#sidebar-resizer:hover::before,#viz-body.resizing #sidebar-resizer::before{background:var(--accent)}
#sidebar-resizer:focus-visible{outline:none;box-shadow:inset 0 0 0 2px #60a5fa66}
#viz-body.resizing{user-select:none;cursor:col-resize}
.sec-label{font-size:11px;letter-spacing:.5px;color:var(--muted);margin-bottom:8px}
.disc-btn{cursor:pointer;display:flex;align-items:center;gap:8px;padding:4px;border-radius:3px;transition:opacity .2s;user-select:none}.disc-btn.off{opacity:.2}
.disc-btn-dot{width:10px;height:10px;border-radius:2px;flex-shrink:0}.disc-btn-abbr{font-size:13px;font-weight:bold}
.disc-btn-name{font-size:13px;color:var(--muted);flex:1;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}
.type-btn{cursor:pointer;display:flex;gap:8px;padding:4px;border-radius:3px;transition:opacity .2s;user-select:none}.type-btn.off{opacity:.2}
#detail{background:var(--panel-alt);border-radius:6px;padding:12px;border:1px solid var(--border);display:none;font-size:14px}
#detail h3{font-size:16px;color:var(--text);margin-bottom:8px;line-height:1.35}
.detail-type{font-size:12px;letter-spacing:.5px;margin-bottom:6px}.detail-desc{font-size:13px;color:var(--muted);line-height:1.6;margin-bottom:10px}
.dtags{display:flex;flex-wrap:wrap;gap:6px}.dtag{padding:3px 8px;border-radius:4px;font-size:12px}
#stats{margin-top:auto;border-top:1px solid var(--border);padding-top:10px}.stat-row{display:flex;justify-content:space-between;padding:3px 0;font-size:12px}
#plot-wrap{flex:1;min-width:0;display:flex;flex-direction:column}#plot{flex:1;min-height:0;width:100%;height:100%}
#footer{padding:10px 18px;border-top:1px solid var(--border);background:var(--panel);display:flex;gap:20px;align-items:center;flex-wrap:wrap;font-size:12px;color:var(--muted);flex-shrink:0}
.leg{display:flex;gap:6px;align-items:center}.leg-sym{font-size:13px}
#toast{display:none;position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:var(--danger-bg);border:1px solid var(--danger-border);color:var(--danger-text);padding:12px 20px;border-radius:6px;font-size:13px;letter-spacing:.3px;z-index:999}
.modal{display:none;position:fixed;inset:0;background:#0008;z-index:1200;align-items:center;justify-content:center;padding:24px}
.modal-card{width:min(900px,95vw);max-height:85vh;overflow:auto;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:14px}
.modal-top{display:flex;justify-content:space-between;align-items:center;gap:8px;margin-bottom:10px}
.modal-title{font-size:14px;color:var(--accent);letter-spacing:.5px}
.mono-block{white-space:pre-wrap;font-size:13px;line-height:1.6;color:var(--text);background:var(--panel-alt);border:1px solid var(--border);padding:10px;border-radius:6px}
.card-list{display:flex;flex-direction:column;gap:10px}
.evidence-card{background:var(--panel-alt);border:1px solid var(--border);border-radius:8px;padding:10px;display:flex;flex-direction:column;gap:6px}
.evidence-card.compact{padding:8px;gap:5px}
.evidence-top{display:flex;justify-content:space-between;gap:10px;align-items:flex-start}
.evidence-title{font-size:13px;color:var(--text);font-weight:bold}
.evidence-card.compact .evidence-title{font-size:12px}
.evidence-meta{font-size:11px;color:var(--muted)}
.evidence-card.compact .evidence-meta{font-size:10px}
.tag-row{display:flex;flex-wrap:wrap;gap:6px}
.tag{font-size:11px;border:1px solid var(--border);padding:2px 6px;border-radius:10px;color:var(--muted)}
.tag.strong{border-color:var(--accent);color:var(--accent)}
.evidence-supporting{display:flex;flex-wrap:wrap;gap:6px}
.evidence-term-match{border-color:var(--accent)!important;color:var(--accent)!important;background:var(--panel-soft)}
#d-citations .evidence-card{margin-top:2px}
.small-btn{background:var(--panel);border:1px solid var(--control-border);color:var(--text);font-family:'Courier New',monospace;font-size:11px;letter-spacing:.4px;padding:4px 8px;border-radius:6px;cursor:pointer}
.legacy-actions{display:none}
.viz-actions{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
.progress-pill{font-size:11px;color:var(--muted);padding:5px 8px;border:1px dashed var(--border);border-radius:999px;min-width:160px;text-align:center}
.projection-tip{font-size:11px;color:var(--muted);padding:4px 8px;border:1px solid var(--border);border-radius:999px;cursor:help}
.menu-wrap{position:relative}
.menu-pop{display:none;position:absolute;right:0;top:34px;z-index:1300;background:var(--panel);border:1px solid var(--border);border-radius:8px;min-width:210px;padding:6px}
.menu-pop.open{display:block}
.menu-item{width:100%;text-align:left;background:transparent;border:1px solid transparent;color:var(--text);font-family:'Courier New',monospace;font-size:12px;padding:8px;border-radius:6px;cursor:pointer}
.menu-item:hover{border-color:var(--accent);color:var(--accent)}
#artifact-drawer{position:fixed;top:56px;right:12px;z-index:1250;width:min(560px,94vw);max-height:78vh;overflow:auto;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:12px;display:none;box-shadow:0 12px 28px #00000022}
#artifact-drawer.open{display:block}
.artifact-head{display:flex;justify-content:space-between;align-items:center;gap:8px;margin-bottom:10px}
.artifact-row{display:grid;grid-template-columns:1.4fr auto;gap:10px;padding:10px;border:1px solid var(--border);border-radius:8px;background:var(--panel-alt);margin-bottom:8px}
.artifact-main{display:flex;flex-direction:column;gap:4px}
.artifact-name{font-size:13px;color:var(--text)}
.artifact-meta{font-size:11px;color:var(--muted)}
.artifact-actions{display:flex;gap:6px;flex-wrap:wrap;justify-content:flex-end}
.badge{font-size:10px;padding:2px 6px;border-radius:999px;border:1px solid var(--border);color:var(--muted)}
.badge.ready{border-color:#16a34a;color:#16a34a}
.badge.stale{border-color:#d97706;color:#d97706}
.badge.none{border-color:#6b7280;color:#6b7280}
.artifact-modal-body{max-height:60vh;overflow:auto}
.artifact-html{font-size:13px;line-height:1.6}
.matrix-wrap{overflow:auto;border:1px solid var(--border);border-radius:6px;background:var(--panel-alt)}
.matrix-table{width:100%;border-collapse:collapse;font-size:11px}
.matrix-table th,.matrix-table td{border:1px solid var(--border);padding:4px 6px;text-align:center}
.matrix-table th{background:var(--panel-soft);color:var(--muted);position:sticky;top:0}
.matrix-note{font-size:11px;color:var(--muted);line-height:1.5}
#embedding-diagnostics{display:flex;flex-direction:column;gap:8px}
#wa-hotspot-audit{display:flex;flex-direction:column;gap:8px}
#disc-sim-matrix:empty{display:none}
.filter-grid{display:grid;grid-template-columns:1fr 1fr;gap:6px}
.filter-grid input,.filter-grid select{font-size:12px;padding:8px 10px}
#node-filter-results{display:flex;flex-direction:column;gap:6px;max-height:180px;overflow:auto}
.node-hit{font-size:12px;background:var(--panel-alt);border:1px solid var(--border);border-radius:6px;padding:6px 8px;cursor:pointer}
.node-hit:hover{border-color:var(--accent);color:var(--accent)}
.node-hit-meta{font-size:11px;color:var(--muted);margin-top:2px}
.ca-card{display:none;flex-direction:column;gap:8px;border:1px solid var(--border);border-radius:6px;background:var(--panel-alt);padding:10px}
.ca-card img{width:100%;border:1px solid var(--border);border-radius:4px;background:var(--panel)}
.ca-meta{font-size:11px;color:var(--muted);line-height:1.45}
.ca-title{font-size:12px;color:var(--accent);letter-spacing:.4px}
@media (max-width:900px){#viz-body{flex-direction:column}#sidebar{width:100%;border-right:none;border-bottom:1px solid var(--border)}#sidebar-resizer{display:none}}
@media (max-width:700px){.api-row{grid-template-columns:1fr}.prefs-row{grid-template-columns:1fr}.prefs-row-wide{grid-template-columns:1fr}.mini-grid{grid-template-columns:1fr}.lens-gen-row{grid-template-columns:1fr}.disc-grid{grid-template-columns:1fr}.prompt-workbench{grid-template-columns:1fr}.prompt-preview-controls{grid-template-columns:1fr}.controls-pane{max-height:none}.workbench-sticky-nav{position:static}.run-action-strip{position:static;background:none;border-top:none;padding-top:0}#workbench-resizer{display:none}}
</style>
</head>
<body>
<div id="main-tabs">
  <div class="tabs-left" role="tablist" aria-label="Workspace Views">
    <button class="tab-btn active" id="tab-generator-btn" type="button" role="tab" aria-selected="true" aria-controls="setup" tabindex="0">GENERATION PANEL</button>
    <button class="tab-btn" id="tab-plot-btn" type="button" role="tab" aria-selected="false" aria-controls="plot-panel" tabindex="-1">PLOT VIEW</button>
  </div>
  <div class="tabs-right">
    <button class="mini-btn" id="import-run-btn" type="button">IMPORT RUN</button>
    <button class="mini-btn" id="export-run-btn" type="button">EXPORT RUN</button>
    <select id="theme-select-global">
      <option value="light">Light Theme</option>
      <option value="dark">Dark Theme</option>
      <option value="contrast">High Contrast</option>
    </select>
    <input type="file" id="run-file-input" accept="application/json,.json" style="display:none"/>
  </div>
</div>
<div id="setup" role="tabpanel" aria-labelledby="tab-generator-btn" tabindex="-1">
  <div>
    <div class="logo">RULIAD EXPEDITION TOOL v1.0</div>
    <h1>Map the Shape of an Idea</h1>
    <div class="sub">bring your own key | open-model probes | embedding-native topology</div>
  </div>
  <div class="workflow-card">
    <div class="workflow-title">GENERATION PANEL WORKFLOW</div>
    <ol class="workflow-list">
      <li><b>Focus Concept</b>: set the core topic you want mapped.</li>
      <li><b>Probe Lenses</b>: edit/customize lenses, then optionally auto-generate alternatives.</li>
      <li><b>Model + Runtime</b>: choose API mode, research model, embedding model, and quality profile.</li>
      <li><b>Grounding + Source Policy</b>: tune web/Wolfram behavior, source policy, and acceptance thresholds.</li>
      <li><b>Prompt Editor</b>: choose prompt kind, inspect defaults, edit templates, and click <b>APPLY OVERRIDE</b>.</li>
      <li><b>Advanced Experiments</b> (optional): CA probe, red-team critique, and replication settings.</li>
      <li><b>Run + Readiness Summary</b>: resolve blocking checks, then run.</li>
      <li><b>Long-panel ergonomics</b>: use section shortcuts, sticky readiness strip, and horizontal resizer for comfort.</li>
    </ol>
    <div class="workflow-note">Relevance and grounding are separate axes. WA status affects grounding display and diagnostics, not term relevance.</div>
  </div>
  <div class="field-group">
    <label>GENERATION WORKBENCH</label>
    <div class="prompt-workbench" id="generation-workbench">
      <div class="prompt-pane">
        <div class="prompt-pane-title">5. PROMPT EDITOR (KIND -> EDIT -> APPLY)</div>
        <div class="prompt-preview-controls">
          <div class="field-group compact-field">
            <label for="prompt-preview-kind-select">Prompt kind</label>
            <select id="prompt-preview-kind-select" title="Preview prompt type">
              <option value="probe_user">Probe user prompt</option>
              <option value="probe_system">Probe system prompt</option>
              <option value="synthesis">Synthesis prompt</option>
              <option value="lens_generation">Lens-generation prompt</option>
              <option value="artifact_deep_report">Artifact prompt: Deep report</option>
              <option value="artifact_claims">Artifact prompt: Claims</option>
              <option value="artifact_outline">Artifact prompt: Outline</option>
              <option value="artifact_red_team">Artifact prompt: Red-team</option>
              <option value="artifact_replication">Artifact prompt: Replication</option>
              <option value="artifact_markdown">Artifact prompt: Markdown</option>
            </select>
          </div>
          <div class="field-group compact-field" id="prompt-preview-disc-wrap">
            <label for="prompt-preview-disc-select">Probe lens (for probe user prompt)</label>
            <select id="prompt-preview-disc-select" title="Preview discipline"></select>
          </div>
          <button class="small-btn" id="prompt-preview-refresh-btn" type="button">REFRESH</button>
        </div>
        <div class="prompt-kind-help" id="prompt-preview-kind-help" aria-live="polite"></div>
        <textarea id="prompt-preview-params" class="prompt-params" readonly aria-label="Prompt parameter narrative"></textarea>
        <input type="text" id="prompt-preview-status" class="prompt-status" readonly aria-live="polite" value="Using default prompt template"/>
        <div class="prompt-override-summary" id="prompt-override-summary" aria-live="polite"></div>
        <label for="prompt-preview-system">SYSTEM PROMPT TEMPLATE (editable)</label>
        <textarea id="prompt-preview-system" class="prompt-editable" spellcheck="false"></textarea>
        <label for="prompt-preview-user">USER PROMPT TEMPLATE (editable)</label>
        <textarea id="prompt-preview-user" class="prompt-editable" spellcheck="false"></textarea>
        <div class="probe-actions">
          <button class="mini-btn" id="prompt-preview-apply-btn" type="button">APPLY OVERRIDE</button>
          <button class="mini-btn" id="prompt-preview-reset-btn" type="button">RESET TO DEFAULT</button>
          <button class="mini-btn" id="prompt-preview-discard-btn" type="button">DISCARD EDITS</button>
        </div>
        <div class="tiny-note">Defaults are always visible. Edits affect runtime only after <b>APPLY OVERRIDE</b>.</div>
      </div>
      <div id="workbench-resizer" role="separator" aria-orientation="vertical" aria-label="Resize generation workbench panels" tabindex="0"></div>
      <div class="prompt-pane controls-pane" id="workbench-controls-pane">
        <div class="prompt-pane-title">RUN CONTROLS + READINESS</div>
        <div class="workbench-sticky-nav" aria-label="Generation section shortcuts">
          <button class="mini-btn" type="button" data-workbench-jump="focus-concept-anchor">1. FOCUS</button>
          <button class="mini-btn" type="button" data-workbench-jump="workbench-section-lenses">2. LENSES</button>
          <button class="mini-btn" type="button" data-workbench-jump="workbench-section-model">3. MODEL</button>
          <button class="mini-btn" type="button" data-workbench-jump="workbench-section-grounding">4. GROUNDING</button>
          <button class="mini-btn" type="button" data-workbench-jump="workbench-section-readiness">7. READINESS</button>
        </div>
        <div class="workbench-control-stack">
          <fieldset class="workbench-section" id="focus-concept-anchor">
            <legend class="workbench-section-title">1. Focus Concept</legend>
            <div class="field-group">
              <label for="target-input">FOCUS CONCEPT</label>
              <input type="text" id="target-input" placeholder="e.g. consciousness, money, entropy, love, justice..." value=""/>
            </div>
          </fieldset>
          <fieldset class="workbench-section" id="workbench-section-lenses">
            <legend class="workbench-section-title">2. Probe Lenses</legend>
            <div class="field-group">
              <label>PROBE LENSES (CLICK TO CUSTOMIZE)</label>
              <div class="disc-grid" id="disc-inputs"></div>
              <div class="probe-actions">
                <button class="mini-btn" id="add-probe-btn" type="button">ADD LENS</button>
              </div>
            </div>
            <div class="field-group">
              <label for="lens-count-input">AUTO-GENERATE LENSES</label>
              <div class="lens-gen-row">
                <input type="number" id="lens-count-input" min="2" max="12" value="7"/>
                <button class="mini-btn" id="gen-lenses-btn" type="button">GENERATE</button>
              </div>
              <div class="tiny-note">Creates mutually distinct lenses while staying relevant to your focus concept.</div>
            </div>
          </fieldset>
          <fieldset class="workbench-section" id="workbench-section-model">
            <legend class="workbench-section-title">3. Model + Runtime</legend>
            <div class="api-row">
              <div class="field-group compact-field">
                <label for="api-mode">API MODE</label>
                <select id="api-mode"><option value="direct">Direct mode (browser)</option><option value="proxy">Proxy mode (localhost)</option></select>
              </div>
              <div class="field-group compact-field">
                <label for="research-model-input">RESEARCH MODEL</label>
                <select id="research-model-input" title="Reasoning model">
                  <option value="deepseek/deepseek-r1" selected>deepseek/deepseek-r1</option>
                  <option value="qwen/qwen-2.5-72b-instruct">qwen/qwen-2.5-72b-instruct</option>
                  <option value="openai/gpt-oss-120b">openai/gpt-oss-120b</option>
                  <option value="qwen/qwen3-coder">qwen/qwen3-coder</option>
                  <option value="anthropic/claude-sonnet-4.6">anthropic/claude-sonnet-4.6</option>
                  <option value="google/gemini-3.1-pro-preview">google/gemini-3.1-pro-preview</option>
                  <option value="moonshotai/kimi-k2.5">moonshotai/kimi-k2.5</option>
                  <option value="z-ai/glm-5">z-ai/glm-5</option>
                </select>
              </div>
            </div>
            <div class="api-key-row">
              <input type="password" id="api-key-input" autocomplete="off" spellcheck="false" placeholder="OpenRouter key (required in direct mode)"/>
              <button class="mini-btn" id="toggle-key-btn" type="button">SHOW</button>
              <button class="mini-btn" id="clear-key-btn" type="button">CLEAR</button>
            </div>
            <div class="field-group compact-field">
              <label for="embedding-model-input">EMBEDDING MODEL</label>
              <select id="embedding-model-input" title="Embedding model">
                <option value="qwen/qwen3-embedding-8b" selected>qwen/qwen3-embedding-8b</option>
                <option value="baai/bge-large-en-v1.5">baai/bge-large-en-v1.5</option>
                <option value="intfloat/e5-large-v2">intfloat/e5-large-v2</option>
                <option value="thenlper/gte-large">thenlper/gte-large</option>
                <option value="openai/text-embedding-3-large">openai/text-embedding-3-large</option>
                <option value="openai/text-embedding-3-small">openai/text-embedding-3-small</option>
                <option value="google/gemini-embedding-001">google/gemini-embedding-001</option>
                <option value="mistralai/mistral-embed-2312">mistralai/mistral-embed-2312</option>
              </select>
            </div>
            <div class="field-group">
              <label for="quality-mode-select">QUALITY PROFILE</label>
              <select id="quality-mode-select">
                <option value="fast">Fast (speed-first)</option>
                <option value="balanced" selected>Balanced</option>
                <option value="rigor">Rigor (deeper, slower)</option>
              </select>
              <div class="tiny-note">Controls term count, synthesis depth, temperature, embedding batch size, and optional cleanup pass.</div>
            </div>
            <div class="tiny-note" id="api-mode-note">Direct mode sends requests from this page to the model API. The key is only held in memory for this tab and never written to localStorage.</div>
          </fieldset>
          <fieldset class="workbench-section" id="workbench-section-grounding">
            <legend class="workbench-section-title">4. Grounding + Source Policy</legend>
            <div class="prefs-row prefs-row-single">
              <div class="toggle-wrap">
                <input type="checkbox" id="web-search-check" checked/>
                <label for="web-search-check">Enable web search grounding</label>
              </div>
            </div>
            <div class="field-group">
              <label for="source-policy-input">SOURCE POLICY</label>
              <input type="text" id="source-policy-input" placeholder="e.g. prioritize peer-reviewed + government data; allow journalism; avoid blogs"/>
            </div>
            <div class="prefs-row-wide">
              <div class="toggle-wrap">
                <input type="checkbox" id="wolfram-grounding-check"/>
                <label for="wolfram-grounding-check">Enable Wolfram entity grounding</label>
              </div>
              <div class="toggle-wrap">
                <input type="checkbox" id="grounding-annotate-only-check"/>
                <label for="grounding-annotate-only-check">Never overwrite descriptions, only annotate</label>
              </div>
            </div>
            <div class="field-group">
              <label for="wolfram-appid-input">WOLFRAM APPID</label>
              <input type="password" id="wolfram-appid-input" autocomplete="off" spellcheck="false" placeholder="required for Wolfram grounding and live CA lookup"/>
              <div class="tiny-note">Used only for live Wolfram calls. Without it, local CA fallback metrics still run.</div>
            </div>
            <div class="field-group">
              <label for="grounding-mode-select">GROUNDING POLICY</label>
              <div class="mini-grid">
                <select id="grounding-mode-select" title="Grounding mode">
                  <option value="conservative">Conservative</option>
                  <option value="balanced" selected>Balanced</option>
                  <option value="aggressive">Aggressive</option>
                </select>
                <input type="number" id="grounding-min-score-input" min="0" max="1" step="0.01" placeholder="q_min: min snippet quality (auto)"/>
              </div>
              <input type="number" id="grounding-min-alignment-score-input" min="0" max="1" step="0.01" placeholder="a_min: min semantic alignment (auto)"/>
              <div class="toggle-wrap">
                <input type="checkbox" id="grounding-allow-category-mismatch-check"/>
                <label for="grounding-allow-category-mismatch-check">Allow category-mismatch grounding (explicit override)</label>
              </div>
              <div class="tiny-note">Acceptance requires both quality and semantic alignment. Conservative is safest; aggressive appends more Wolfram text.</div>
            </div>
          </fieldset>
          <details class="workbench-section workbench-advanced" id="workbench-section-advanced">
            <summary class="workbench-section-title">6. Advanced Experiments (optional)</summary>
            <div class="workbench-advanced-body">
              <div class="prefs-row-wide">
                <div class="toggle-wrap">
                  <input type="checkbox" id="ca-probe-check"/>
                  <label for="ca-probe-check">Add computational irreducibility probe</label>
                </div>
                <div class="toggle-wrap">
                  <input type="checkbox" id="redteam-check"/>
                  <label for="redteam-check">Enable red-team critique</label>
                </div>
              </div>
              <div class="mini-grid">
                <div class="field-group compact-field">
                  <label for="ca-rule-input">CA RULE</label>
                  <input type="number" id="ca-rule-input" min="0" max="255" value="30" title="elementary cellular automaton rule"/>
                </div>
                <div class="field-group compact-field">
                  <label for="ca-steps-input">CA STEPS</label>
                  <input type="number" id="ca-steps-input" min="16" max="240" value="96" title="simulation steps"/>
                </div>
              </div>
              <div class="field-group">
                <label for="ca-width-input">CA WIDTH (CELLS)</label>
                <input type="number" id="ca-width-input" min="31" max="401" value="151" title="odd width recommended"/>
              </div>
              <div class="field-group">
                <label for="replication-models-input">REPLICATION MODELS (COMMA-SEPARATED)</label>
                <input type="text" id="replication-models-input" placeholder="replication models (comma-separated)"/>
              </div>
              <div class="mini-grid">
                <div class="field-group compact-field">
                  <label for="replication-runs-input">RUNS PER MODEL</label>
                  <input type="number" id="replication-runs-input" min="1" max="5" value="1" title="number of reruns per model"/>
                </div>
                <div class="field-group compact-field">
                  <label for="replication-strategy-select">REPLICATION STRATEGY</label>
                  <select id="replication-strategy-select" title="temperature/seed strategy">
                    <option value="fixed">Fixed params</option>
                    <option value="jitter">Temperature jitter</option>
                  </select>
                </div>
              </div>
              <div class="tiny-note">Left box is runs per model. Right selector controls fixed parameters vs temperature jitter.</div>
            </div>
          </details>
          <fieldset class="workbench-section" id="workbench-section-readiness">
            <legend class="workbench-section-title">7. Run + Readiness Summary</legend>
            <div class="run-readiness-status" id="run-readiness-status" aria-live="polite">Checking run readiness...</div>
            <ul class="readiness-list" id="run-readiness-list"></ul>
            <div class="run-action-strip">
              <button class="launch-btn" id="launch-btn" type="button">RUN EXPEDITION</button>
            </div>
          </fieldset>
          <div class="tiny-note">8. Long-panel ergonomics: shortcuts are sticky at the top, readiness action strip is sticky at the bottom, and the center divider is draggable.</div>
        </div>
      </div>
    </div>
  </div>
  <div class="note">Each lens runs an independent model query. Synthesis then links overlaps, tensions, and emergent terms. Final nodes are embedded and projected into 3D where distance reflects semantic similarity. Typical run: ~10-16 API calls, depending on term count and embedding batches.</div>
</div>
<div id="plot-panel" role="tabpanel" aria-labelledby="tab-plot-btn" tabindex="-1" hidden>
<div id="progress">
  <div><div class="prog-title">EXPEDITION IN PROGRESS</div><div class="prog-target" id="prog-target-label"></div></div>
  <div class="probe-list" id="probe-list"></div>
  <div class="synth-bar" id="synth-bar">SYNTHESIS - waiting for probes...</div>
</div>
<div id="viz">
  <div id="viz-topbar">
    <div id="viz-topbar-left">RULIAD SCAN - <span id="viz-target-label"></span></div>
    <div id="viz-topbar-right">
      <div class="viz-actions">
        <span style="font-size:12px;color:var(--muted);letter-spacing:.5px"><span id="vis-count">0</span> TERMS</span>
        <span class="projection-tip" title="Distances are suggestive; global direction/opposites are not invariant under projection.">PROJECTION NOTE</span>
        <span class="progress-pill" id="artifact-progress-text">Idle</span>
        <button class="reset-btn" id="artifacts-btn" title="Open run artifacts and their status">ARTIFACTS</button>
        <div class="menu-wrap">
          <button class="reset-btn" id="export-menu-btn" title="Open export options">EXPORT</button>
          <div class="menu-pop" id="export-menu">
            <button class="menu-item" id="export-menu-figure" type="button">Download Figure (PNG)</button>
            <button class="menu-item" id="export-menu-markdown" type="button">Download Report (MD)</button>
            <button class="menu-item" id="export-menu-wa-graph" type="button">Export WA Graph Data</button>
            <button class="menu-item" id="export-menu-bundle" type="button">Export Bundle (.zip)</button>
          </div>
        </div>
        <button class="reset-btn" id="new-run-btn" title="Reset current run and start new expedition">NEW</button>
      </div>
      <div class="legacy-actions">
        <button class="reset-btn" id="raw-list-btn">RAW NODES</button><button class="reset-btn" id="evidence-btn">EVIDENCE</button><button class="reset-btn" id="ambiguity-btn">AMBIGUITY</button><button class="reset-btn" id="claims-btn">CLAIMS</button><button class="reset-btn" id="redteam-btn">RED TEAM</button><button class="reset-btn" id="replication-btn">REPLICATION</button><button class="reset-btn" id="outline-btn">OUTLINE</button><button class="reset-btn" id="export-md-btn">EXPORT MD</button><button class="reset-btn" id="export-fig-btn">EXPORT FIGURE</button><button class="reset-btn" id="rerun-synth-btn">RERUN SYNTH</button><button class="reset-btn" id="deep-report-btn">DEEP REPORT</button><button class="reset-btn" id="reset-btn">NEW EXPEDITION</button>
      </div>
    </div>
  </div>
  <div id="viz-body">
    <div id="sidebar">
      <div><div class="sec-label">PROBE DISCIPLINES</div><div id="disc-list"></div><div style="margin-top:8px;display:flex;align-items:center;gap:8px;padding:4px;cursor:pointer" id="surf-toggle"><input type="checkbox" id="surf-check" checked style="cursor:pointer"/><label for="surf-check" style="font-size:13px;color:var(--muted);cursor:pointer;letter-spacing:.5px">PROBE SURFACES</label></div></div>
      <div><div class="sec-label">TERM CATEGORIES</div><div id="type-list"></div></div>
      <div>
        <div class="sec-label">GROUNDING VISUALS</div>
        <div class="field-group" style="margin-top:6px">
          <label for="node-color-mode-select">NODE COLOR MODE</label>
          <select id="node-color-mode-select">
            <option value="type">Color by node type</option>
            <option value="grounding">Color by grounding quality</option>
          </select>
        </div>
        <div style="margin-top:8px;display:flex;align-items:center;gap:8px;padding:4px;cursor:pointer">
          <input type="checkbox" id="grounding-overlay-check" checked style="cursor:pointer"/>
          <label for="grounding-overlay-check" style="font-size:13px;color:var(--muted);cursor:pointer;letter-spacing:.5px">GROUNDING HALOS / RINGS</label>
        </div>
        <div class="matrix-note" id="grounding-encoding-note">Node type color mode active. Halos indicate grounding confidence.</div>
      </div>
      <div id="node-filter-panel">
        <div class="sec-label">NODE SEARCH / FILTER</div>
        <input type="text" id="node-search-input" placeholder="Search node label (fuzzy)" aria-label="Node search"/>
        <div class="filter-grid" style="margin-top:6px">
          <select id="node-type-filter" aria-label="Filter by node type">
            <option value="all">Type: all</option>
            <option value="unique">Type: unique</option>
            <option value="convergent">Type: convergent</option>
            <option value="contradictory">Type: contradictory</option>
            <option value="emergent">Type: emergent</option>
          </select>
          <select id="node-grounding-filter" aria-label="Filter by WA grounding status">
            <option value="all">WA status: all</option>
            <option value="grounded">WA status: grounded (applied)</option>
            <option value="weak">WA status: weak (metadata-only/unresolved)</option>
            <option value="metadata_only">WA status: metadata-only</option>
            <option value="rejected">WA status: unresolved</option>
            <option value="local_defined">WA status: not suitable (local-defined)</option>
            <option value="not_attempted">WA status: not attempted</option>
          </select>
          <input type="number" id="node-min-probe-filter" min="0" value="0" placeholder="Min probe count" aria-label="Minimum probe count"/>
          <input type="number" id="node-min-citation-filter" min="0" value="0" placeholder="Min citation count" aria-label="Minimum citation count"/>
          <select id="node-sort-select" aria-label="Sort nodes">
            <option value="probe_coverage">Sort: probe coverage</option>
            <option value="citation_count">Sort: citation count</option>
            <option value="grounding_confidence">Sort: grounding confidence</option>
            <option value="alphabetical">Sort: alphabetical</option>
          </select>
          <button class="small-btn" id="node-filter-clear-btn" type="button">CLEAR</button>
        </div>
        <div class="matrix-note" id="node-filter-summary" style="margin-top:6px">No nodes loaded.</div>
        <div id="node-filter-results"></div>
      </div>
      <div id="detail"><div class="sec-label">SELECTED</div><h3 id="d-label"></h3><div class="detail-type" id="d-type"></div><div class="detail-desc" id="d-desc"></div><div class="dtags" id="d-slices"></div><div class="sec-label" style="margin-top:10px">EVIDENCE</div><div class="card-list" id="d-citations"></div><button class="reset-btn" id="clear-btn" style="margin-top:8px;font-size:11px">CLEAR</button></div>
      <div id="embedding-diagnostics">
        <div class="sec-label">PROJECTION CHECKS</div>
        <div class="matrix-note" id="disc-sim-status">No embedding diagnostics yet.</div>
        <div class="matrix-note" id="projection-stability"></div>
        <div class="matrix-wrap" id="disc-sim-matrix"></div>
      </div>
      <div id="wa-hotspot-audit">
        <div class="sec-label">GENERIC INTERPRETATION HOTSPOT AUDIT</div>
        <div class="matrix-note" id="wa-hotspot-status">No Wolfram interpretation hotspot diagnostics yet.</div>
        <div class="matrix-wrap" id="wa-hotspot-matrix"></div>
      </div>
      <div class="ca-card" id="ca-panel">
        <div class="sec-label">COMPUTATIONAL IRREDUCIBILITY</div>
        <div class="ca-title" id="ca-title"></div>
        <div class="ca-meta" id="ca-meta"></div>
        <img id="ca-image" alt="Cellular automaton evolution"/>
        <div class="ca-meta" id="ca-commentary"></div>
      </div>
      <div id="stats"><div class="sec-label">CORPUS</div><div id="stat-rows"></div></div>
    </div>
    <div id="sidebar-resizer" role="separator" aria-orientation="vertical" aria-label="Resize plot sidebar" tabindex="0"></div>
    <div id="plot-wrap"><div id="plot"></div></div>
  </div>
  <div id="footer"><span style="letter-spacing:.5px;color:var(--muted)">GEOMETRY</span><div class="leg"><span class="leg-sym" style="color:#64748b">o</span><span>unique - discipline-specific</span></div><div class="leg"><span class="leg-sym" style="color:#4f46e5">d</span><span>convergent - shared across probes</span></div><div class="leg"><span class="leg-sym" style="color:#ea580c">x</span><span>contradictory - tension zones</span></div><div class="leg"><span class="leg-sym" style="color:#ca8a04">*</span><span>emergent - synthesis only</span></div><span style="letter-spacing:.5px;color:var(--muted)">GROUNDING</span><div class="leg"><span class="leg-sym" style="color:#22c55e">?</span><span>Wolfram halo; thicker ring = stronger confidence</span></div><div class="leg"><span class="leg-sym" style="color:#f97316">?</span><span>dotted ring = unresolved / ambiguous</span></div><span id="color-mode-label" style="margin-left:auto;color:var(--muted);letter-spacing:.5px">NODE COLOR: TYPE</span><span style="color:var(--muted);letter-spacing:.5px">SEMANTIC EMBEDDING MAP | RULIAD TOPOLOGY SCAN</span></div>
</div>
</div>
<div id="toast"></div>
<div id="artifact-drawer">
  <div class="artifact-head">
    <div style="font-size:13px;letter-spacing:.5px;color:var(--accent)">RUN ARTIFACTS</div>
    <button class="small-btn" id="artifact-drawer-close" type="button">CLOSE</button>
  </div>
  <div id="artifact-list"></div>
  <div style="display:flex;justify-content:flex-end;margin-top:8px">
    <button class="small-btn" id="artifact-rerun-synth-btn" type="button" title="Re-run synthesis and mark downstream artifacts stale">RERUN SYNTHESIS</button>
  </div>
</div>
<div class="modal" id="artifact-modal">
  <div class="modal-card">
    <div class="modal-top">
      <div>
        <div class="modal-title" id="artifact-modal-title">ARTIFACT</div>
        <div class="evidence-meta" id="artifact-modal-meta"></div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button class="reset-btn" id="artifact-copy-btn" type="button">COPY</button>
        <button class="reset-btn" id="artifact-download-btn" type="button">DOWNLOAD</button>
        <button class="reset-btn" id="artifact-regenerate-btn" type="button">REGENERATE</button>
        <button class="reset-btn" id="artifact-close-btn" type="button">CLOSE</button>
      </div>
    </div>
    <div class="artifact-modal-body">
      <div class="mono-block" id="artifact-modal-content"></div>
    </div>
  </div>
</div>
<div class="modal" id="raw-modal">
  <div class="modal-card">
    <div class="modal-top">
      <div class="modal-title">RAW NODE LIST</div>
      <button class="reset-btn" id="raw-close-btn" type="button">CLOSE</button>
    </div>
    <div class="mono-block" id="raw-modal-content"></div>
  </div>
</div>
<div class="modal" id="report-modal">
  <div class="modal-card">
    <div class="modal-top">
      <div class="modal-title">DEEP RESEARCH REPORT</div>
      <div style="display:flex;gap:8px;align-items:center">
        <button class="reset-btn" id="report-copy-btn" type="button">COPY</button>
        <button class="reset-btn" id="report-close-btn" type="button">CLOSE</button>
      </div>
    </div>
    <div class="mono-block" id="report-modal-content"></div>
  </div>
</div>
<div class="modal" id="evidence-modal">
  <div class="modal-card">
    <div class="modal-top">
      <div class="modal-title">EVIDENCE CARDS</div>
      <button class="reset-btn" id="evidence-close-btn" type="button">CLOSE</button>
    </div>
    <div id="evidence-filter-bar" class="field-group"></div>
    <div class="card-list" id="evidence-modal-content"></div>
  </div>
</div>
<div class="modal" id="claims-modal">
  <div class="modal-card">
    <div class="modal-top">
      <div class="modal-title">CLAIMS LEDGER</div>
      <div style="display:flex;gap:8px;align-items:center">
        <button class="reset-btn" id="claims-copy-btn" type="button">COPY</button>
        <button class="reset-btn" id="claims-close-btn" type="button">CLOSE</button>
      </div>
    </div>
    <div class="mono-block" id="claims-modal-content"></div>
  </div>
</div>
<div class="modal" id="outline-modal">
  <div class="modal-card">
    <div class="modal-top">
      <div class="modal-title">OUTLINE FROM MAP</div>
      <div style="display:flex;gap:8px;align-items:center">
        <button class="reset-btn" id="outline-copy-btn" type="button">COPY</button>
        <button class="reset-btn" id="outline-close-btn" type="button">CLOSE</button>
      </div>
    </div>
    <div class="mono-block" id="outline-modal-content"></div>
  </div>
</div>
<div class="modal" id="critique-modal">
  <div class="modal-card">
    <div class="modal-top">
      <div class="modal-title">RED-TEAM CRITIQUE</div>
      <div style="display:flex;gap:8px;align-items:center">
        <button class="reset-btn" id="critique-copy-btn" type="button">COPY</button>
        <button class="reset-btn" id="critique-close-btn" type="button">CLOSE</button>
      </div>
    </div>
    <div class="mono-block" id="critique-modal-content"></div>
  </div>
</div>
<div class="modal" id="replication-modal">
  <div class="modal-card">
    <div class="modal-top">
      <div class="modal-title">REPLICATION RESULTS</div>
      <div style="display:flex;gap:8px;align-items:center">
        <button class="reset-btn" id="replication-close-btn" type="button">CLOSE</button>
      </div>
    </div>
    <div class="mono-block" id="replication-modal-content"></div>
  </div>
</div>
<div class="modal" id="ambiguity-modal">
  <div class="modal-card">
    <div class="modal-top">
      <div>
        <div class="modal-title">WOLFRAM AMBIGUITY QUEUE</div>
        <div class="evidence-meta" id="ambiguity-summary"></div>
      </div>
      <button class="reset-btn" id="ambiguity-close-btn" type="button">CLOSE</button>
    </div>
    <div class="card-list" id="ambiguity-modal-content"></div>
  </div>
</div>
<script>
const COLORS=["#00cfff","#ff6b35","#7fff2a","#ff3dff","#ffe600","#00ff9f","#bf5fff"];
const FALLBACK_DIRS=[[0.940,0.000,0.342],[0.552,0.760,-0.342],[-0.210,0.916,0.342],[-0.846,0.411,-0.342],[-0.846,-0.411,0.342],[-0.210,-0.916,-0.342],[0.552,-0.760,0.342]];
const DEFAULT_DISCS=["Thermodynamics / Physics","Neuroscience / Cognitive Science","Philosophy / Metaphysics","Biology / Evolution","Mathematics / Information Theory","Sociology / Anthropology","Computer Science / AI"];
const TYPE_CFG={unique:{label:"UNIQUE",col:"#666",desc:"one discipline only"},convergent:{label:"CONVERGENT",col:"#99aaff",desc:"shared across 2+ disciplines"},contradictory:{label:"CONTRADICTORY",col:"#ff9500",desc:"tension between disciplines"},emergent:{label:"EMERGENT",col:"#ffd700",desc:"synthesis only"}};
const TYPE_PRIORITY={unique:1,convergent:2,contradictory:3,emergent:4};
const QUALITY_PROFILES={
  fast:{id:"fast",probeTermMin:6,probeTermMax:8,synthConvergent:"2-4",synthContradictory:"1-3",synthEmergent:"2-3",temperature:0.15,maxTokens:1000,embedBatchSize:36,cleanup:false},
  balanced:{id:"balanced",probeTermMin:8,probeTermMax:10,synthConvergent:"3-6",synthContradictory:"2-4",synthEmergent:"3-5",temperature:0.2,maxTokens:1400,embedBatchSize:24,cleanup:false},
  rigor:{id:"rigor",probeTermMin:10,probeTermMax:14,synthConvergent:"4-8",synthContradictory:"3-6",synthEmergent:"4-7",temperature:0.1,maxTokens:1900,embedBatchSize:16,cleanup:true}
};
const API_ENDPOINTS={direct:{chat:"https://openrouter.ai/api/v1/chat/completions",embeddings:"https://openrouter.ai/api/v1/embeddings"},proxy:{chat:"/api/llm/chat/completions",embeddings:"/api/llm/embeddings"}};
const PROJECTION_BASE_SEED=20260218;
const PROJECTION_STABILITY_RUNS=4;
class RNG{constructor(seed){this.s=seed>>>0;}next(){this.s=(Math.imul(this.s,1664525)+1013904223)>>>0;return this.s/0xFFFFFFFF;}jitter(scale=0.07){return (this.next()-0.5)*scale;}}
let DISCS=[],TERMS=[],activeSlices=new Set(),activeTypes=new Set(),showSurfaces=true,plotInited=false,sessionConfig=null,umapModulePromise=null,nodeColorMode="type",showGroundingOverlays=true;
let LAST_RUN=null,activeTab="generator",isGenerating=false,lastReportText="",lastClaimsText="",lastOutlineText="",lastCritiqueText="",lastMarkdownText="";
let CALL_LOGS=[],RUN_STATE=null,CITATIONS=[],CURRENT_RUN_ID=null,CITATION_UNMAPPED_SUPPORTING_TERMS=[];
let DISC_SIM_MATRIX=null,PROJECTION_STABILITY=null;
let CA_PROBE_OUTPUT=null;
let WOLFRAM_GROUNDING_DIAGNOSTICS=[];
let AMBIGUITY_QUEUE=[];
let EVIDENCE_FILTER_STATE={sourceType:"all",termLabel:"",provider:"all"};
const WOLFRAM_CACHE_VERSION=1;
const WOLFRAM_QUERY_CACHE_TTL_MS=1000*60*60*24;
const WOLFRAM_TERM_CACHE_TTL_MS=1000*60*60*12;
const WOLFRAM_QUERY_CACHE_MAX=500;
const WOLFRAM_TERM_CACHE_MAX=800;
const WOLFRAM_CACHE_STORAGE_KEY="ruliad_wolfram_cache";
const WOLFRAM_QUERY_CACHE_MEM=new Map();
const WOLFRAM_TERM_CACHE_MEM=new Map();
let WOLFRAM_CACHE_STORAGE_ENABLED=true;
let WOLFRAM_CACHE_LAST_SAVE=0;
const SIDEBAR_WIDTH_STORAGE_KEY="ruliad_sidebar_width_px";
const SIDEBAR_WIDTH_DEFAULT=320;
const SIDEBAR_WIDTH_MIN=250;
const SIDEBAR_WIDTH_MAX=620;
const GENERATION_WORKBENCH_WIDTH_STORAGE_KEY="ruliad_generation_workbench_left_px";
const GENERATION_WORKBENCH_LEFT_MIN=320;
const GENERATION_WORKBENCH_RIGHT_MIN=320;
const PROMPT_OVERRIDE_KINDS=["probe_system","probe_user","synthesis","lens_generation","artifact_deep_report","artifact_claims","artifact_outline","artifact_red_team","artifact_replication","artifact_markdown"];
const PROMPT_KIND_META={
  probe_system:{label:"Probe system prompt",usage:"Prepended for every probe call as global system instruction.",scope:"global"},
  probe_user:{label:"Probe user prompt",usage:"Sent once per probe lens during probe generation.",scope:"lens"},
  synthesis:{label:"Synthesis prompt",usage:"Used once after probe results to produce convergent/contradictory/emergent terms.",scope:"global"},
  lens_generation:{label:"Lens-generation prompt",usage:"Used only when generating orthogonal probe lenses from the focus concept.",scope:"global"},
  artifact_deep_report:{label:"Artifact deep report prompt",usage:"Used when generating the deep report artifact.",scope:"global"},
  artifact_claims:{label:"Artifact claims prompt",usage:"Used when generating the claims ledger artifact.",scope:"global"},
  artifact_outline:{label:"Artifact outline prompt",usage:"Used when generating the outline artifact.",scope:"global"},
  artifact_red_team:{label:"Artifact red-team prompt",usage:"Used when running the red-team critique artifact.",scope:"global"},
  artifact_replication:{label:"Artifact replication prompt",usage:"Used when running replication artifact generation.",scope:"global"},
  artifact_markdown:{label:"Artifact markdown prompt",usage:"Used when generating markdown report artifact output.",scope:"global"}
};
let PROMPT_TEMPLATE_OVERRIDES={};
let PROMPT_PREVIEW_RENDERING=false;
const ARTIFACT_DEFS={
  raw_terms:{name:"Raw term list",desc:"All plotted nodes in raw form.",kind:"derived"},
  evidence:{name:"Evidence library",desc:"Captured sources and quality tags.",kind:"derived"},
  wa_grounding_graph:{name:"WA interpretation graph",desc:"Diagnostics map: term -> query -> interpretation -> outcome.",kind:"derived"},
  claims:{name:"Claims ledger",desc:"Structured claims with confidence and verification steps.",kind:"generated"},
  outline:{name:"Outline from map",desc:"Narrative structure from convergences, fault lines, and emergence.",kind:"generated"},
  deep_report:{name:"Deep report",desc:"Substantive synthesis memo from map artifacts.",kind:"generated"},
  red_team:{name:"Red team critique",desc:"Attacks weak joints, unsupported leaps, and evidence gaps.",kind:"generated"},
  replication:{name:"Replication results",desc:"Stability estimate via model reruns and overlap scores.",kind:"generated"},
  markdown:{name:"Markdown report",desc:"Substack-ready report export artifact.",kind:"generated"}
};
let ARTIFACT_STORE={};
let ARTIFACT_BUSY=false;
let ACTIVE_ARTIFACT_KEY="";
let ACTIVE_MODAL_ID="";
const MODAL_RETURN_FOCUS=new Map();
const MODAL_FOCUSABLE_SELECTOR=[
  "a[href]",
  "area[href]",
  "input:not([disabled]):not([type='hidden'])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "iframe",
  "[tabindex]:not([tabindex='-1'])",
  "[contenteditable='true']"
].join(",");
const WA_GRAPH_STATUS_META={
  accepted:{label:"accepted",color:"#16a34a"},
  metadata_only:{label:"metadata-only",color:"#d97706"},
  rejected_category_mismatch:{label:"rejected_category_mismatch",color:"#dc2626"},
  rejected_low_confidence:{label:"rejected_low_confidence",color:"#ef4444"},
  no_plaintext:{label:"no_plaintext",color:"#64748b"}
};
const WA_ACCEPTED_GROUNDING_STATUSES=new Set(["accepted","accepted_metadata_only","accepted_annotation_only"]);
const TERM_GROUNDING_OUTCOME_META={
  grounded:{label:"WA grounded (applied)",color:"#16a34a"},
  metadata_only:{label:"WA grounded (metadata-only)",color:"#d97706"},
  rejected:{label:"WA unresolved",color:"#dc2626"},
  not_attempted:{label:"WA not attempted",color:"#64748b"},
  local_defined:{label:"Locally defined construct",color:"#0ea5e9"}
};
const WA_TERM_STATUS_META={
  wa_grounded_applied:{label:"WA grounded (applied)",color:"#16a34a"},
  wa_grounded_metadata_only:{label:"WA grounded (metadata-only)",color:"#d97706"},
  wa_unresolved_mismatch:{label:"WA mismatch",color:"#dc2626"},
  wa_unresolved_low_confidence:{label:"WA low-confidence",color:"#ef4444"},
  wa_unresolved_no_plaintext:{label:"WA no plaintext",color:"#64748b"},
  wa_not_attempted:{label:"WA not attempted",color:"#64748b"},
  wa_not_suitable:{label:"WA not suitable for term type",color:"#0ea5e9"}
};
function waTermStatusLabel(statusKey){return WA_TERM_STATUS_META[statusKey]?.label||String(statusKey||"WA status unknown");}
function waTermStatusColor(statusKey){return WA_TERM_STATUS_META[statusKey]?.color||"#64748b";}
function normalizeWolframCacheKey(query){return String(query||"").replace(/\s+/g," ").trim().toLowerCase();}
function normalizeWolframTermCacheKey(raw){return String(raw||"").replace(/\s+/g," ").trim().toLowerCase();}
function wolframCacheNow(){return Date.now();}
function buildWolframTermCacheKey(term,target,discName){const label=toCanonicalKey(term?.label||"");const entity=toCanonicalKey(buildWolframEntityRef(term?.wolfram_entity)||"");const disc=toCanonicalKey(discName||"");const tgt=toCanonicalKey(target||"");return normalizeWolframTermCacheKey(`${label}|${entity}|${disc}|${tgt}`);}
function enforceWolframCacheLimit(map,maxEntries){if(map.size<=maxEntries) return;const items=[...map.entries()].sort((a,b)=>Number(b[1]?.cachedAt||0)-Number(a[1]?.cachedAt||0));map.clear();for(const [key,val] of items.slice(0,maxEntries)){map.set(key,val);}}
function pruneExpiredWolframCache(map,now=wolframCacheNow()){let removed=0;for(const [key,entry] of map.entries()){if(!entry||!Number.isFinite(Number(entry.expiresAt))||Number(entry.expiresAt)<=now){map.delete(key);removed++;}}return removed;}
function persistWolframCaches(force=false){if(!WOLFRAM_CACHE_STORAGE_ENABLED) return;const now=wolframCacheNow();if(!force&&now-WOLFRAM_CACHE_LAST_SAVE<1200) return;WOLFRAM_CACHE_LAST_SAVE=now;try{const payload={version:WOLFRAM_CACHE_VERSION,savedAt:new Date(now).toISOString(),queryTtlMs:WOLFRAM_QUERY_CACHE_TTL_MS,termTtlMs:WOLFRAM_TERM_CACHE_TTL_MS,queryEntries:[...WOLFRAM_QUERY_CACHE_MEM.entries()],termEntries:[...WOLFRAM_TERM_CACHE_MEM.entries()]};localStorage.setItem(WOLFRAM_CACHE_STORAGE_KEY,JSON.stringify(payload));}catch(err){console.warn("Wolfram cache persistence disabled:",err);WOLFRAM_CACHE_STORAGE_ENABLED=false;}}
function loadWolframCaches(){if(!WOLFRAM_CACHE_STORAGE_ENABLED) return;try{const raw=localStorage.getItem(WOLFRAM_CACHE_STORAGE_KEY);if(!raw) return;const parsed=JSON.parse(raw);if(Number(parsed?.version)!==WOLFRAM_CACHE_VERSION){localStorage.removeItem(WOLFRAM_CACHE_STORAGE_KEY);return;}const now=wolframCacheNow();const loadInto=(arr,map,maxEntries)=>{if(!Array.isArray(arr)) return;for(const pair of arr){if(!Array.isArray(pair)||pair.length!==2) continue;const key=String(pair[0]||"").trim();const entry=pair[1]&&typeof pair[1]==="object"?pair[1]:null;if(!key||!entry) continue;const expiresAt=Number(entry.expiresAt);if(!Number.isFinite(expiresAt)||expiresAt<=now) continue;map.set(key,{cachedAt:Number(entry.cachedAt)||now,expiresAt,value:entry.value});}enforceWolframCacheLimit(map,maxEntries);};loadInto(parsed.queryEntries,WOLFRAM_QUERY_CACHE_MEM,WOLFRAM_QUERY_CACHE_MAX);loadInto(parsed.termEntries,WOLFRAM_TERM_CACHE_MEM,WOLFRAM_TERM_CACHE_MAX);pruneExpiredWolframCache(WOLFRAM_QUERY_CACHE_MEM,now);pruneExpiredWolframCache(WOLFRAM_TERM_CACHE_MEM,now);}catch(err){console.warn("Wolfram cache load failed:",err);WOLFRAM_CACHE_STORAGE_ENABLED=false;}}
function getWolframQueryCache(query){const key=normalizeWolframCacheKey(query);if(!key) return null;const entry=WOLFRAM_QUERY_CACHE_MEM.get(key);if(!entry) return null;if(Number(entry.expiresAt)<=wolframCacheNow()){WOLFRAM_QUERY_CACHE_MEM.delete(key);persistWolframCaches();return null;}return structuredCloneSafe(entry.value);}
function setWolframQueryCache(query,value){const key=normalizeWolframCacheKey(query);if(!key||!value) return;const now=wolframCacheNow();WOLFRAM_QUERY_CACHE_MEM.set(key,{cachedAt:now,expiresAt:now+WOLFRAM_QUERY_CACHE_TTL_MS,value:structuredCloneSafe(value)});enforceWolframCacheLimit(WOLFRAM_QUERY_CACHE_MEM,WOLFRAM_QUERY_CACHE_MAX);persistWolframCaches();}
function getWolframTermCache(cacheKey){const key=normalizeWolframTermCacheKey(cacheKey);if(!key) return null;const entry=WOLFRAM_TERM_CACHE_MEM.get(key);if(!entry) return null;if(Number(entry.expiresAt)<=wolframCacheNow()){WOLFRAM_TERM_CACHE_MEM.delete(key);persistWolframCaches();return null;}return structuredCloneSafe(entry.value);}
function setWolframTermCache(cacheKey,value){const key=normalizeWolframTermCacheKey(cacheKey);if(!key||!value) return;const now=wolframCacheNow();WOLFRAM_TERM_CACHE_MEM.set(key,{cachedAt:now,expiresAt:now+WOLFRAM_TERM_CACHE_TTL_MS,value:structuredCloneSafe(value)});enforceWolframCacheLimit(WOLFRAM_TERM_CACHE_MEM,WOLFRAM_TERM_CACHE_MAX);persistWolframCaches();}
const discInputsEl=document.getElementById("disc-inputs");
const setupEl=document.getElementById("setup");
const plotPanelEl=document.getElementById("plot-panel");
const progressEl=document.getElementById("progress");
const vizEl=document.getElementById("viz");
const generatorTabBtn=document.getElementById("tab-generator-btn");
const plotTabBtn=document.getElementById("tab-plot-btn");
const TAB_ORDER=[generatorTabBtn,plotTabBtn].filter(Boolean);
loadWolframCaches();
renderDisciplineInputs(7);
initGenerationPanelQol();
initSidebarResizer();
initGenerationWorkbenchResizer();
initWorkbenchJumpNav();
document.getElementById("launch-btn").addEventListener("click",launchExpedition);
document.getElementById("reset-btn").addEventListener("click",resetToSetup);
document.getElementById("clear-btn").addEventListener("click",()=>{document.getElementById("detail").style.display="none";});
document.getElementById("toggle-key-btn").addEventListener("click",toggleApiKey);
document.getElementById("clear-key-btn").addEventListener("click",clearApiKey);
document.getElementById("gen-lenses-btn").addEventListener("click",generateOrthogonalLenses);
const themeSelectGlobalEl=document.getElementById("theme-select-global");
if(themeSelectGlobalEl){themeSelectGlobalEl.addEventListener("change",e=>{applyTheme(e.target.value,true);});}
initTabAccessibility();
initNodeFilterControls();
document.getElementById("node-color-mode-select").addEventListener("change",e=>{nodeColorMode=e.target.value==="grounding"?"grounding":"type";renderGroundingLegend();if(plotInited&&activeTab==="plot"){renderPlot();}});
document.getElementById("grounding-overlay-check").addEventListener("change",e=>{showGroundingOverlays=Boolean(e.target.checked);renderGroundingLegend();if(plotInited&&activeTab==="plot"){renderPlot();}});
renderGroundingLegend();
document.getElementById("export-run-btn").addEventListener("click",exportRunToFile);
document.getElementById("import-run-btn").addEventListener("click",()=>document.getElementById("run-file-input").click());
document.getElementById("run-file-input").addEventListener("change",importRunFromFile);
document.getElementById("add-probe-btn").addEventListener("click",addProbeSpec);
discInputsEl.addEventListener("click",onProbeActionClick);
document.getElementById("target-input").addEventListener("input",()=>{markArtifactsStale(["claims","outline","deep_report","red_team","replication","markdown"]);refreshPromptPreview();});
discInputsEl.addEventListener("input",()=>{markArtifactsStale(["claims","outline","deep_report","red_team","replication","markdown"]);syncPromptPreviewDiscOptions();refreshPromptPreview();});
discInputsEl.addEventListener("change",()=>{syncPromptPreviewDiscOptions();refreshPromptPreview();});
for(const id of ["api-mode","quality-mode-select","redteam-check","source-policy-input","replication-models-input","replication-runs-input","replication-strategy-select","research-model-input","embedding-model-input","web-search-check","wolfram-grounding-check","wolfram-appid-input","grounding-mode-select","grounding-min-score-input","grounding-min-alignment-score-input","grounding-annotate-only-check","grounding-allow-category-mismatch-check","ca-probe-check","ca-rule-input","ca-steps-input","ca-width-input","prompt-intent-input","prompt-lens-emphasis-input","prompt-hard-constraints-input","prompt-output-style-input","prompt-artifact-focus-input"]){const el=document.getElementById(id);if(!el) continue;const onChange=()=>{markArtifactsStale(["claims","outline","deep_report","red_team","replication","markdown"]);refreshPromptPreview();};el.addEventListener("change",onChange);el.addEventListener("input",onChange);}
for(const id of ["prompt-preview-kind-select","prompt-preview-disc-select","lens-count-input"]){const el=document.getElementById(id);if(!el) continue;const onPreview=()=>{refreshPromptPreview();};el.addEventListener("change",onPreview);el.addEventListener("input",onPreview);}
document.getElementById("prompt-preview-refresh-btn").addEventListener("click",refreshPromptPreview);
document.getElementById("prompt-preview-apply-btn").addEventListener("click",applyPromptPreviewOverride);
document.getElementById("prompt-preview-reset-btn").addEventListener("click",resetPromptPreviewOverride);
document.getElementById("prompt-preview-discard-btn").addEventListener("click",refreshPromptPreview);
document.getElementById("raw-list-btn").addEventListener("click",showRawNodeList);
document.getElementById("evidence-btn").addEventListener("click",showEvidenceModal);
document.getElementById("ambiguity-btn").addEventListener("click",showAmbiguityQueueModal);
document.getElementById("claims-btn").addEventListener("click",generateClaimsLedger);
document.getElementById("redteam-btn").addEventListener("click",runRedTeamPass);
document.getElementById("replication-btn").addEventListener("click",runReplication);
document.getElementById("outline-btn").addEventListener("click",generateOutlineFromMap);
document.getElementById("export-md-btn").addEventListener("click",exportMarkdownReport);
document.getElementById("export-fig-btn").addEventListener("click",exportFigure);
document.getElementById("rerun-synth-btn").addEventListener("click",rerunSynthesis);
document.getElementById("raw-close-btn").addEventListener("click",()=>closeModal("raw-modal"));
document.getElementById("deep-report-btn").addEventListener("click",generateDeepReport);
document.getElementById("report-close-btn").addEventListener("click",()=>closeModal("report-modal"));
document.getElementById("report-copy-btn").addEventListener("click",copyReportText);
document.getElementById("evidence-close-btn").addEventListener("click",()=>closeModal("evidence-modal"));
document.getElementById("ambiguity-close-btn").addEventListener("click",()=>closeModal("ambiguity-modal"));
document.getElementById("claims-close-btn").addEventListener("click",()=>closeModal("claims-modal"));
document.getElementById("claims-copy-btn").addEventListener("click",copyClaimsText);
document.getElementById("outline-close-btn").addEventListener("click",()=>closeModal("outline-modal"));
document.getElementById("outline-copy-btn").addEventListener("click",copyOutlineText);
document.getElementById("critique-close-btn").addEventListener("click",()=>closeModal("critique-modal"));
document.getElementById("critique-copy-btn").addEventListener("click",copyCritiqueText);
document.getElementById("replication-close-btn").addEventListener("click",()=>closeModal("replication-modal"));
document.getElementById("artifacts-btn").addEventListener("click",toggleArtifactDrawer);
document.getElementById("artifact-drawer-close").addEventListener("click",()=>setArtifactDrawer(false));
document.getElementById("artifact-rerun-synth-btn").addEventListener("click",async()=>{setArtifactDrawer(false);await rerunSynthesis();markArtifactsStale(["claims","outline","deep_report","red_team","replication","markdown"]);refreshArtifactList();});
document.getElementById("new-run-btn").addEventListener("click",resetToSetup);
document.getElementById("export-menu-btn").addEventListener("click",toggleExportMenu);
document.getElementById("export-menu-figure").addEventListener("click",async()=>{setExportMenu(false);await exportFigure();});
document.getElementById("export-menu-markdown").addEventListener("click",async()=>{setExportMenu(false);await openArtifact("markdown",{regenerate:true,openAfter:false});await downloadArtifact("markdown");});
document.getElementById("export-menu-wa-graph").addEventListener("click",async()=>{setExportMenu(false);await exportWAGraphReadyArtifacts();});
document.getElementById("export-menu-bundle").addEventListener("click",async()=>{setExportMenu(false);await exportArtifactBundle();});
document.getElementById("artifact-close-btn").addEventListener("click",()=>closeModal("artifact-modal"));
document.getElementById("artifact-copy-btn").addEventListener("click",copyActiveArtifact);
document.getElementById("artifact-download-btn").addEventListener("click",downloadActiveArtifact);
document.getElementById("artifact-regenerate-btn").addEventListener("click",async()=>{if(!ACTIVE_ARTIFACT_KEY) return;await openArtifact(ACTIVE_ARTIFACT_KEY,{regenerate:true,openAfter:true});});
for(const modalId of ["raw-modal","report-modal","evidence-modal","ambiguity-modal","claims-modal","outline-modal","critique-modal","replication-modal"]){document.getElementById(modalId).addEventListener("click",e=>{if(e.target.id===modalId) closeModal(modalId);});}
document.getElementById("artifact-modal").addEventListener("click",e=>{if(e.target.id==="artifact-modal") closeModal("artifact-modal");});
document.getElementById("ambiguity-modal-content").addEventListener("click",onAmbiguityQueueClick);
document.addEventListener("keydown",handleModalKeyboard);
document.addEventListener("click",e=>{const menu=document.getElementById("export-menu");const btn=document.getElementById("export-menu-btn");if(!menu.classList.contains("open")) return;if(e.target===btn||btn.contains(e.target)||menu.contains(e.target)) return;setExportMenu(false);});
document.getElementById("api-mode").addEventListener("change",syncApiModeNote);syncApiModeNote();
updateAmbiguityQueueUIState();
window.addEventListener("resize",()=>{
  const raw=getComputedStyle(document.documentElement).getPropertyValue("--sidebar-width").replace("px","").trim();
  const width=Number(raw);
  applySidebarWidth(Number.isFinite(width)?width:SIDEBAR_WIDTH_DEFAULT,{persist:true});
  const wbRaw=Number(sessionStorage.getItem(GENERATION_WORKBENCH_WIDTH_STORAGE_KEY));
  if(Number.isFinite(wbRaw)) applyGenerationWorkbenchLeftWidth(wbRaw,{persist:true});
  if(plotInited&&activeTab==="plot"){try{Plotly.Plots.resize(document.getElementById("plot"));}catch{}}
});
applyTheme(sessionStorage.getItem("ruliad_theme")||"light",false);
switchMainTab("generator",{silent:true,focusTarget:false});
initArtifactStore();
syncPromptPreviewDiscOptions();
refreshPromptPreview();
function renderDisciplineInputs(count,seeds=[]){const n=clampInt(count,2,12);discInputsEl.innerHTML="";for(let i=0;i<n;i++){const fallback=DEFAULT_DISCS[i%DEFAULT_DISCS.length];const val=(seeds[i]||fallback).trim();const row=document.createElement("div");row.className="disc-row";row.innerHTML=`<span class="disc-num">${i+1}</span><div class="disc-color" style="background:${COLORS[i%COLORS.length]}"></div><input class="disc-input" type="text" data-idx="${i}" value="${val}" placeholder="discipline ${i+1}"/><button class="mini-btn probe-del-btn" type="button" data-probe-del="${i}" title="Delete this probe">DEL</button>`;discInputsEl.appendChild(row);}const countEl=document.getElementById("lens-count-input");if(countEl) countEl.value=String(n);syncPromptPreviewDiscOptions();refreshPromptPreview();}
function clampInt(v,min,max){const n=Number.isFinite(Number(v))?Math.round(Number(v)):min;return Math.max(min,Math.min(max,n));}
function applyTheme(theme,persist){const t=(theme==="dark"||theme==="contrast")?theme:"light";document.documentElement.setAttribute("data-theme",t);for(const id of ["theme-select-global"]){const sel=document.getElementById(id);if(sel&&sel.value!==t) sel.value=t;}if(persist){sessionStorage.setItem("ruliad_theme",t);}if(plotInited){renderPlot();}}
function createSetupSection(title,helpText,open=false){
  const details=document.createElement("details");
  details.className="setup-section";
  if(open) details.open=true;
  const summary=document.createElement("summary");
  const label=document.createElement("span");
  label.textContent=title;
  const help=document.createElement("span");
  help.className="setup-help";
  help.textContent="?";
  help.setAttribute("title",helpText);
  help.setAttribute("aria-label",helpText);
  summary.append(label,help);
  const body=document.createElement("div");
  body.className="setup-section-body";
  details.append(summary,body);
  return {details,body};
}
function findDirectChildBlock(root,controlId){
  const el=document.getElementById(controlId);
  if(!root||!el) return null;
  let node=el;
  while(node&&node.parentElement!==root){node=node.parentElement;}
  return node&&node.parentElement===root?node:null;
}
function extractSetupBlocks(root,controlIds){
  const blocks=[];
  const seen=new Set();
  for(const id of (controlIds||[])){
    const block=findDirectChildBlock(root,id);
    if(!block||seen.has(block)) continue;
    seen.add(block);
    blocks.push(block);
  }
  return blocks;
}
function applySetupTooltips(){
  const tooltipById={
    "target-input":"Primary concept to map across probes.",
    "api-mode":"Use proxy to avoid browser CORS and keep keys server-side.",
    "research-model-input":"Model used for probe and synthesis generation.",
    "api-key-input":"Only used in direct mode; not persisted to localStorage.",
    "embedding-model-input":"Model used to position nodes in semantic space.",
    "web-search-check":"Allows model responses to use web-grounded retrieval when supported.",
    "source-policy-input":"Source preference and exclusion instructions for the model.",
    "wolfram-grounding-check":"Enables Wolfram-based grounding and interpretation checks.",
    "wolfram-appid-input":"Required for live Wolfram requests via proxy.",
    "grounding-mode-select":"Preset profile for grounding strictness.",
    "grounding-min-score-input":"q_min: minimum snippet quality score.",
    "grounding-min-alignment-score-input":"a_min: minimum semantic alignment score.",
    "grounding-annotate-only-check":"Never append WA text to descriptions; keep as metadata only.",
    "grounding-allow-category-mismatch-check":"Override category mismatch safeguards if explicitly needed.",
    "ca-probe-check":"Adds local computational irreducibility probe outputs.",
    "ca-rule-input":"Elementary cellular automaton rule (0-255).",
    "ca-steps-input":"Simulation depth in time steps.",
    "ca-width-input":"Simulation width; odd values generally read better.",
    "quality-mode-select":"Balances speed vs depth and cleanup behavior.",
    "redteam-check":"Generate skeptical critique after synthesis.",
    "replication-models-input":"Comma-separated models for replication checks.",
    "replication-runs-input":"Number of reruns per model during replication.",
    "replication-strategy-select":"Fixed parameters or jittered temperature per run.",
    "lens-count-input":"How many orthogonal lenses to auto-generate.",
    "gen-lenses-btn":"Generate distinct probe lenses from the target concept."
  };
  for(const [id,text] of Object.entries(tooltipById)){
    const el=document.getElementById(id);
    if(!el) continue;
    if(!String(el.getAttribute("title")||"").trim()) el.setAttribute("title",text);
  }
}
function initGenerationPanelQol(){
  if(document.getElementById("generation-workbench")){applySetupTooltips();return;}
  const configGroup=document.getElementById("api-mode")?.closest(".field-group");
  if(!configGroup||configGroup.dataset.qolEnhanced==="1") return;
  configGroup.dataset.qolEnhanced="1";
  const heading=configGroup.querySelector(":scope > label");
  if(heading) heading.textContent="RUN CONFIGURATION";
  const inlineThemeSelect=document.getElementById("theme-select");
  if(inlineThemeSelect){
    const inlineThemeRow=inlineThemeSelect.closest(".prefs-row");
    inlineThemeSelect.remove();
    if(inlineThemeRow) inlineThemeRow.classList.add("prefs-row-single");
  }
  const datalists=[...configGroup.querySelectorAll(":scope > datalist")];
  for(const dl of datalists){dl.remove();}
  const sections=[
    {
      title:"Models & Access",
      help:"Connection mode, model IDs, credentials, and source-policy defaults.",
      open:true,
      ids:["api-mode","api-key-input","embedding-model-input","web-search-check","source-policy-input","api-mode-note"]
    },
    {
      title:"Grounding Rules",
      help:"Wolfram controls, score thresholds, and safety guards for mismatched interpretations.",
      open:false,
      ids:["wolfram-grounding-check","wolfram-appid-input","grounding-mode-select","grounding-min-score-input","grounding-min-alignment-score-input","grounding-annotate-only-check","grounding-allow-category-mismatch-check"]
    },
    {
      title:"Quality & Replication",
      help:"CA probe settings, quality profile, red-team pass, and replication controls.",
      open:false,
      ids:["ca-probe-check","ca-rule-input","ca-width-input","quality-mode-select","redteam-check","replication-models-input","replication-runs-input","replication-strategy-select"]
    }
  ];
  const stack=document.createElement("div");
  stack.className="setup-section-stack";
  const used=new Set();
  for(const sectionDef of sections){
    const section=createSetupSection(sectionDef.title,sectionDef.help,sectionDef.open);
    stack.appendChild(section.details);
    const blocks=extractSetupBlocks(configGroup,sectionDef.ids);
    for(const block of blocks){
      if(used.has(block)) continue;
      used.add(block);
      section.body.appendChild(block);
    }
  }
  const fallbackBody=stack.querySelector(".setup-section-body");
  for(const child of [...configGroup.children]){
    if(child===stack||datalists.includes(child)||child.tagName==="LABEL") continue;
    if(used.has(child)) continue;
    fallbackBody?.appendChild(child);
    used.add(child);
  }
  configGroup.appendChild(stack);
  for(const dl of datalists){configGroup.appendChild(dl);}
  applySetupTooltips();
}
function clampSidebarWidth(px){
  const dynamicMax=Math.min(SIDEBAR_WIDTH_MAX,Math.floor((window.innerWidth||1200)*0.62));
  const max=Math.max(SIDEBAR_WIDTH_MIN+40,dynamicMax);
  const n=Number(px);
  if(!Number.isFinite(n)) return Math.min(SIDEBAR_WIDTH_DEFAULT,max);
  return Math.max(SIDEBAR_WIDTH_MIN,Math.min(max,Math.round(n)));
}
function applySidebarWidth(px,{persist=false}={}){
  const clamped=clampSidebarWidth(px);
  document.documentElement.style.setProperty("--sidebar-width",`${clamped}px`);
  if(persist) sessionStorage.setItem(SIDEBAR_WIDTH_STORAGE_KEY,String(clamped));
  return clamped;
}
function initSidebarResizer(){
  const vizBody=document.getElementById("viz-body");
  const resizer=document.getElementById("sidebar-resizer");
  if(!vizBody||!resizer) return;
  const saved=Number(sessionStorage.getItem(SIDEBAR_WIDTH_STORAGE_KEY));
  applySidebarWidth(Number.isFinite(saved)?saved:SIDEBAR_WIDTH_DEFAULT,{persist:false});
  let dragging=false;
  const moveWithClientX=(clientX)=>{
    if(!dragging) return;
    const rect=vizBody.getBoundingClientRect();
    applySidebarWidth(clientX-rect.left,{persist:false});
    if(plotInited&&activeTab==="plot"){try{Plotly.Plots.resize(document.getElementById("plot"));}catch{}}
  };
  const startDrag=(clientX)=>{
    if(window.matchMedia("(max-width:900px)").matches) return;
    dragging=true;
    vizBody.classList.add("resizing");
    moveWithClientX(clientX);
  };
  const stopDrag=()=>{
    if(!dragging) return;
    dragging=false;
    vizBody.classList.remove("resizing");
    const raw=getComputedStyle(document.documentElement).getPropertyValue("--sidebar-width").replace("px","").trim();
    const width=Number(raw);
    if(Number.isFinite(width)) sessionStorage.setItem(SIDEBAR_WIDTH_STORAGE_KEY,String(Math.round(width)));
  };
  resizer.addEventListener("mousedown",e=>{e.preventDefault();startDrag(e.clientX);});
  window.addEventListener("mousemove",e=>moveWithClientX(e.clientX));
  window.addEventListener("mouseup",stopDrag);
  resizer.addEventListener("touchstart",e=>{const t=e.touches?.[0];if(!t) return;startDrag(t.clientX);},{passive:true});
  window.addEventListener("touchmove",e=>{const t=e.touches?.[0];if(!t) return;if(dragging) e.preventDefault();moveWithClientX(t.clientX);},{passive:false});
  window.addEventListener("touchend",stopDrag);
  resizer.addEventListener("keydown",e=>{
    if(e.key!=="ArrowLeft"&&e.key!=="ArrowRight") return;
    e.preventDefault();
    const raw=getComputedStyle(document.documentElement).getPropertyValue("--sidebar-width").replace("px","").trim();
    const current=Number.isFinite(Number(raw))?Number(raw):SIDEBAR_WIDTH_DEFAULT;
    const delta=e.key==="ArrowLeft"?-22:22;
    applySidebarWidth(current+delta,{persist:true});
    if(plotInited&&activeTab==="plot"){try{Plotly.Plots.resize(document.getElementById("plot"));}catch{}}
  });
}
function clampGenerationWorkbenchLeftWidth(px){
  const workbench=document.getElementById("generation-workbench");
  const total=Math.max(760,Math.round(workbench?.getBoundingClientRect?.().width||window.innerWidth||1200));
  const divider=10;
  const max=Math.max(GENERATION_WORKBENCH_LEFT_MIN+120,total-divider-GENERATION_WORKBENCH_RIGHT_MIN);
  const n=Number(px);
  if(!Number.isFinite(n)) return Math.max(GENERATION_WORKBENCH_LEFT_MIN,Math.min(max,Math.round((total-divider)/2)));
  return Math.max(GENERATION_WORKBENCH_LEFT_MIN,Math.min(max,Math.round(n)));
}
function applyGenerationWorkbenchLeftWidth(px,{persist=false}={}){
  const workbench=document.getElementById("generation-workbench");
  if(!workbench) return null;
  const clamped=clampGenerationWorkbenchLeftWidth(px);
  workbench.style.setProperty("--generation-left-width",`${clamped}px`);
  if(persist) sessionStorage.setItem(GENERATION_WORKBENCH_WIDTH_STORAGE_KEY,String(clamped));
  return clamped;
}
function initGenerationWorkbenchResizer(){
  const workbench=document.getElementById("generation-workbench");
  const resizer=document.getElementById("workbench-resizer");
  if(!workbench||!resizer) return;
  const saved=Number(sessionStorage.getItem(GENERATION_WORKBENCH_WIDTH_STORAGE_KEY));
  applyGenerationWorkbenchLeftWidth(Number.isFinite(saved)?saved:null,{persist:false});
  let dragging=false;
  const moveWithClientX=(clientX)=>{
    if(!dragging) return;
    const rect=workbench.getBoundingClientRect();
    applyGenerationWorkbenchLeftWidth(clientX-rect.left,{persist:false});
  };
  const startDrag=(clientX)=>{
    if(window.matchMedia("(max-width:700px)").matches) return;
    dragging=true;
    workbench.classList.add("resizing");
    moveWithClientX(clientX);
  };
  const stopDrag=()=>{
    if(!dragging) return;
    dragging=false;
    workbench.classList.remove("resizing");
    const raw=workbench.style.getPropertyValue("--generation-left-width").replace("px","").trim();
    const width=Number(raw);
    if(Number.isFinite(width)) sessionStorage.setItem(GENERATION_WORKBENCH_WIDTH_STORAGE_KEY,String(Math.round(width)));
  };
  resizer.addEventListener("mousedown",e=>{e.preventDefault();startDrag(e.clientX);});
  window.addEventListener("mousemove",e=>moveWithClientX(e.clientX));
  window.addEventListener("mouseup",stopDrag);
  resizer.addEventListener("touchstart",e=>{const t=e.touches?.[0];if(!t) return;startDrag(t.clientX);},{passive:true});
  window.addEventListener("touchmove",e=>{const t=e.touches?.[0];if(!t) return;if(dragging) e.preventDefault();moveWithClientX(t.clientX);},{passive:false});
  window.addEventListener("touchend",stopDrag);
  resizer.addEventListener("keydown",e=>{
    if(e.key!=="ArrowLeft"&&e.key!=="ArrowRight") return;
    e.preventDefault();
    const raw=workbench.style.getPropertyValue("--generation-left-width").replace("px","").trim();
    const current=Number.isFinite(Number(raw))?Number(raw):clampGenerationWorkbenchLeftWidth(null);
    const delta=e.key==="ArrowLeft"?-22:22;
    applyGenerationWorkbenchLeftWidth(current+delta,{persist:true});
  });
}
function initWorkbenchJumpNav(){
  const pane=document.getElementById("workbench-controls-pane");
  if(!pane) return;
  const buttons=Array.from(document.querySelectorAll("[data-workbench-jump]"));
  for(const btn of buttons){
    btn.addEventListener("click",()=>{
      const targetId=String(btn.getAttribute("data-workbench-jump")||"").trim();
      if(!targetId) return;
      const targetEl=document.getElementById(targetId);
      if(!targetEl) return;
      if(pane.contains(targetEl)){
        const paneRect=pane.getBoundingClientRect();
        const targetRect=targetEl.getBoundingClientRect();
        const nextTop=Math.max(0,pane.scrollTop+(targetRect.top-paneRect.top)-52);
        pane.scrollTo({top:nextTop,behavior:"smooth"});
      }else{
        targetEl.scrollIntoView({behavior:"smooth",block:"start"});
      }
      targetEl.classList.add("workbench-jump-highlight");
      setTimeout(()=>targetEl.classList.remove("workbench-jump-highlight"),900);
    });
  }
}
function getCurrentProbeSpecs(){return Array.from(document.querySelectorAll(".disc-input")).map(el=>el.value.trim());}
function addProbeSpec(){const specs=getCurrentProbeSpecs();if(specs.length>=12){showToast("Maximum probe count is 12.");return;}specs.push(`Probe ${specs.length+1}`);renderDisciplineInputs(specs.length,specs);}
function onProbeActionClick(e){const btn=e.target.closest("[data-probe-del]");if(!btn) return;const idx=Number(btn.getAttribute("data-probe-del"));const specs=getCurrentProbeSpecs();if(specs.length<=2){showToast("At least 2 probes are required.");return;}if(Number.isNaN(idx)||idx<0||idx>=specs.length) return;specs.splice(idx,1);renderDisciplineInputs(specs.length,specs);}
function getNodeFilterState(){return {search:String(document.getElementById("node-search-input")?.value||"").trim(),type:String(document.getElementById("node-type-filter")?.value||"all"),grounding:String(document.getElementById("node-grounding-filter")?.value||"all"),minProbes:clampInt(document.getElementById("node-min-probe-filter")?.value||0,0,99),minCitations:clampInt(document.getElementById("node-min-citation-filter")?.value||0,0,999),sort:String(document.getElementById("node-sort-select")?.value||"probe_coverage")};}
function getNodeGroundingStatus(term){return String(term?.grounding?.groundingStatus||"not_attempted");}
function termGroundingOutcomeLabel(outcome){return TERM_GROUNDING_OUTCOME_META[outcome]?.label||String(outcome||"not attempted");}
function termGroundingOutcomeColor(outcome){return TERM_GROUNDING_OUTCOME_META[outcome]?.color||"#64748b";}
function isLocalDefinedTerm(term){
  if(String(term?.grounding?.termOutcome||"").trim().toLowerCase()==="local_defined") return true;
  if(normalizeGroundingEligibility(term?.grounding?.groundingEligibility||"eligible")==="synthetic_local") return true;
  const slices=Array.isArray(term?.slices)?term.slices.filter(i=>Number.isInteger(i)):[];
  if(!slices.length) return false;
  return slices.every(i=>String(DISCS?.[i]?.kind||"llm")==="ca");
}
function isWolframGroundingCitation(cite){
  if(!cite||typeof cite!=="object") return false;
  const isWolframSource=normalizeSourceType(cite?.source_type,cite?.publisher)==="wolfram"||/wolfram/i.test(String(cite?.publisher||""));
  if(!isWolframSource) return false;
  const status=String(cite?.grounding_status||"").trim();
  const confidence=String(cite?.grounding_confidence||"").trim();
  const score=Number(cite?.grounding_score);
  const reasons=Array.isArray(cite?.grounding_reasons)?cite.grounding_reasons:[];
  const interp=String(cite?.wolfram_input_interpretation||"").trim();
  const definition=String(cite?.wolfram_best_definition||"").trim();
  return Boolean(status||confidence||(Number.isFinite(score)&&score>0)||reasons.length||interp||definition);
}
function getWolframCitationsForTerm(term){
  const linked=getLinkedCitationsForTerm(term);
  return linked.filter(cite=>isWolframGroundingCitation(cite));
}
function getResearchCitationsForTerm(term){
  const linked=getLinkedCitationsForTerm(term);
  return linked.filter(cite=>normalizeSourceType(cite?.source_type,cite?.publisher)!=="wolfram");
}
function getLLMProbeCount(){
  const llmCount=DISCS.filter(d=>String(d?.kind||"llm")!=="ca").length;
  return Math.max(1,llmCount||DISCS.length||1);
}
function computeTermRelevanceScore(term){
  const centrality=clamp01(Number(term?.centrality??0.5));
  const sliceCount=Array.isArray(term?.slices)?term.slices.length:0;
  const probeCount=getLLMProbeCount();
  const probeCoverage=term?.type==="emergent"&&sliceCount===0?0.65:clamp01(sliceCount/probeCount);
  const recurrence=clamp01(sliceCount<=1?0:(sliceCount-1)/Math.max(1,probeCount-1));
  const typeSignal=term?.type==="contradictory"?0.98:term?.type==="convergent"?0.95:term?.type==="emergent"?0.86:0.56;
  return Number(clamp01((centrality*0.46)+(probeCoverage*0.24)+(recurrence*0.14)+(typeSignal*0.16)).toFixed(3));
}
function computeTermEvidenceSupportScore(term){
  const researchCitations=getResearchCitationsForTerm(term);
  const researchCount=researchCitations.length;
  const researchSignal=researchCount?Math.min(1,researchCount/3):0;
  const sourceDiversityCount=new Set(researchCitations.map(c=>normalizeSourceType(c?.source_type,c?.publisher)||"untyped")).size;
  const sourceDiversity=researchCount?Math.min(1,sourceDiversityCount/Math.min(3,researchCount)):0;
  const sliceCount=Array.isArray(term?.slices)?term.slices.length:0;
  const probeCoverage=clamp01(sliceCount/getLLMProbeCount());
  const structureSignal=term?.type==="convergent"||term?.type==="contradictory"?Math.max(probeCoverage,0.72):term?.type==="emergent"?0.58:probeCoverage;
  return Number(clamp01((researchSignal*0.68)+(sourceDiversity*0.12)+(structureSignal*0.2)).toFixed(3));
}
function termScoreBand(score){
  const val=Number(score);
  if(!Number.isFinite(val)) return "low";
  if(val>=0.72) return "high";
  if(val>=0.48) return "medium";
  return "low";
}
function getTermGroundingReasonHints(term){
  const key=toCanonicalKey(term?.label||"");
  if(!key) return [];
  const reasons=[];
  for(const diag of (WOLFRAM_GROUNDING_DIAGNOSTICS||[])){
    if(toCanonicalKey(diag?.termLabel||"")!==key) continue;
    reasons.push(String(diag?.status||""));
    for(const reason of (Array.isArray(diag?.reasons)?diag.reasons:[])){reasons.push(String(reason||""));}
  }
  for(const cite of getWolframCitationsForTerm(term)){
    reasons.push(String(cite?.grounding_status||""));
    for(const reason of (Array.isArray(cite?.grounding_reasons)?cite.grounding_reasons:[])){reasons.push(String(reason||""));}
  }
  return dedupeCasefold(reasons.map(x=>String(x||"").trim().toLowerCase()).filter(Boolean),160);
}
function deriveWaGroundingStatusKey(term,outcome=getTermGroundingOutcome(term)){
  const eligibility=normalizeGroundingEligibility(term?.grounding?.groundingEligibility||"eligible");
  if(outcome==="local_defined"||eligibility==="synthetic_local"||eligibility==="ca_bypassed") return "wa_not_suitable";
  if(outcome==="not_attempted") return "wa_not_attempted";
  if(outcome==="grounded") return "wa_grounded_applied";
  if(outcome==="metadata_only") return "wa_grounded_metadata_only";
  if(outcome!=="rejected") return "wa_not_attempted";
  const resolution=String(term?.grounding?.wolframResolution||"").trim().toLowerCase();
  const reasons=getTermGroundingReasonHints(term);
  const hasNoPlaintext=resolution.includes("no plaintext")||resolution.includes("no match")||reasons.some(r=>r.includes("no_plaintext")||r==="empty"||r.includes("parser_selection_exhausted"));
  if(hasNoPlaintext) return "wa_unresolved_no_plaintext";
  const hasMismatch=resolution.includes("category mismatch")||reasons.some(r=>r.startsWith("category_mismatch_")||r.includes("mismatch"));
  if(hasMismatch) return "wa_unresolved_mismatch";
  return "wa_unresolved_low_confidence";
}
function deriveTermStateBadge(signal){
  if(!signal||typeof signal!=="object") return "Relevant | WA status pending";
  if(signal.waGroundingStatus==="wa_not_suitable") return "Relevant | Probe-local construct | No WA expectation";
  if(signal.researchSupported&&signal.waGroundingStatus.startsWith("wa_unresolved")) return "Relevant | Research-supported | WA unresolved";
  if(signal.waGroundingStatus==="wa_grounded_metadata_only") return "Relevant | WA metadata-only";
  if(signal.waGroundingStatus==="wa_grounded_applied") return "Relevant | WA grounded";
  if(signal.waGroundingStatus==="wa_not_attempted") return "Relevant | WA not attempted";
  return "Relevant | WA unresolved";
}
function getTermSignalModel(term){
  const relevanceScore=computeTermRelevanceScore(term);
  const evidenceSupportScore=computeTermEvidenceSupportScore(term);
  const relevanceBand=termScoreBand(relevanceScore);
  const evidenceBand=termScoreBand(evidenceSupportScore);
  const outcome=getTermGroundingOutcome(term);
  const waGroundingStatus=deriveWaGroundingStatusKey(term,outcome);
  const waEligibility=normalizeGroundingEligibility(term?.grounding?.groundingEligibility||"eligible");
  const researchCitationCount=getResearchCitationsForTerm(term).length;
  const sourceCitationCount=getLinkedCitationsForTerm(term).length;
  const probeMentions=Array.isArray(term?.slices)?term.slices.length:0;
  const displayDescriptionSource=String(term?.description_source||"").trim().toLowerCase()||"unknown";
  const primarySupportSummary=researchCitationCount>0?`${researchCitationCount} non-WA citation(s)`:"none linked";
  const secondarySupportSummary=`${probeMentions} probe mention(s); type ${String(term?.type||"unknown")}`;
  const tertiarySupportSummary=waTermStatusLabel(waGroundingStatus);
  const researchSupported=researchCitationCount>0;
  const stateBadge=deriveTermStateBadge({relevanceScore,evidenceSupportScore,waGroundingStatus,researchSupported});
  return {relevanceScore,evidenceSupportScore,relevanceBand,evidenceBand,waGroundingStatus,waEligibility,displayDescriptionSource,researchCitationCount,sourceCitationCount,probeMentions,primarySupportSummary,secondarySupportSummary,tertiarySupportSummary,researchSupported,stateBadge,outcome};
}
function refreshTermSignalFields(terms=TERMS){
  for(const term of (Array.isArray(terms)?terms:[])){
    if(!term||typeof term!=="object") continue;
    const signal=getTermSignalModel(term);
    term.relevance_score=signal.relevanceScore;
    term.evidence_support_score=signal.evidenceSupportScore;
    term.wa_eligibility=signal.waEligibility;
    term.wa_grounding_status=signal.waGroundingStatus;
    term.display_description_source=signal.displayDescriptionSource;
  }
}
function getTermGroundingOutcome(term,{termDiags=null,termWolframCitations=null}={}){
  if(!term||typeof term!=="object") return "not_attempted";
  const status=getNodeGroundingStatus(term);
  const eligibility=normalizeGroundingEligibility(term?.grounding?.groundingEligibility||"eligible");
  const displayMode=normalizeWolframDisplayMode(term?.descriptions?.wolframDisplayMode||"auto");
  const termKey=toCanonicalKey(term?.label||"");
  const diagnostics=Array.isArray(termDiags)?termDiags:(termKey?(WOLFRAM_GROUNDING_DIAGNOSTICS||[]).filter(diag=>toCanonicalKey(diag?.termLabel||"")===termKey):[]);
  const wolframCitations=Array.isArray(termWolframCitations)?termWolframCitations:getWolframCitationsForTerm(term);
  const hasAcceptedDiag=diagnostics.some(diag=>Boolean(diag?.accepted)||WA_ACCEPTED_GROUNDING_STATUSES.has(String(diag?.status||"").trim().toLowerCase()));
  const hasAcceptedCite=wolframCitations.some(cite=>WA_ACCEPTED_GROUNDING_STATUSES.has(String(cite?.grounding_status||"").trim().toLowerCase()));
  const hasAccepted=status==="grounded"||hasAcceptedDiag||hasAcceptedCite;
  const localDefinedByEligibility=eligibility==="synthetic_local"||eligibility==="ca_bypassed";
  const hasWolframTrace=Boolean(status==="failed"||hasWolframGrounding(term)||wolframCitations.length||diagnostics.length||String(term?.descriptions?.wolframGrounding||"").trim());
  if(status==="grounded"||(hasAccepted&&displayMode==="append")) return "grounded";
  if(status==="partial") return "metadata_only";
  if(hasAccepted) return "metadata_only";
  if(localDefinedByEligibility) return "local_defined";
  if(hasWolframTrace||status==="partial") return "rejected";
  if(isLocalDefinedTerm(term)) return "local_defined";
  return "not_attempted";
}
function getNodeGroundingConfidenceScore(term){const level=String(term?.grounding?.wolframConfidence?.level||"none").toLowerCase();const base=level==="high"?3:level==="medium"?2:level==="low"?1:0;const numeric=Number.isFinite(Number(term?.grounding?.wolframConfidence?.score))?Number(term.grounding.wolframConfidence.score):null;return numeric!==null?base+numeric:base;}
function fuzzyLabelMatch(label,query){const text=String(label||"").toLowerCase();const q=String(query||"").toLowerCase().trim();if(!q) return true;if(text.includes(q)) return true;const parts=q.split(/\s+/).filter(Boolean);if(parts.length>1&&parts.every(part=>text.includes(part))) return true;let i=0;for(const ch of text){if(ch===q[i]) i++;if(i>=q.length) return true;}return false;}
function matchesNodeFilters(term,state){if(!term) return false;if(!activeTypes.has(term.type)) return false;if(!(term.slices.length===0||term.slices.some(s=>activeSlices.has(s)))) return false;if(state.type!=="all"&&term.type!==state.type) return false;const outcome=getTermGroundingOutcome(term);if(state.grounding==="grounded"&&outcome!=="grounded") return false;if((state.grounding==="metadata_only"||state.grounding==="partial")&&outcome!=="metadata_only") return false;if((state.grounding==="rejected"||state.grounding==="failed")&&outcome!=="rejected") return false;if(state.grounding==="local_defined"&&outcome!=="local_defined") return false;if(state.grounding==="not_attempted"&&outcome!=="not_attempted") return false;if(state.grounding==="weak"&&!["metadata_only","rejected"].includes(outcome)) return false;if(state.minProbes>0&&((term.slices||[]).length<state.minProbes)) return false;if(state.minCitations>0&&((term.citations||[]).length<state.minCitations)) return false;if(state.search&&!fuzzyLabelMatch(term.label,state.search)) return false;return true;}
function sortNodes(terms,sortMode){const arr=[...(terms||[])];arr.sort((a,b)=>{if(sortMode==="alphabetical"){return String(a.label||"").localeCompare(String(b.label||""));}if(sortMode==="citation_count"){const diff=(b.citations?.length||0)-(a.citations?.length||0);if(diff!==0) return diff;return String(a.label||"").localeCompare(String(b.label||""));}if(sortMode==="grounding_confidence"){const diff=getNodeGroundingConfidenceScore(b)-getNodeGroundingConfidenceScore(a);if(diff!==0) return diff;return String(a.label||"").localeCompare(String(b.label||""));}const probeDiff=(b.slices?.length||0)-(a.slices?.length||0);if(probeDiff!==0) return probeDiff;const citeDiff=(b.citations?.length||0)-(a.citations?.length||0);if(citeDiff!==0) return citeDiff;return String(a.label||"").localeCompare(String(b.label||""));});return arr;}
function getVisibleNodeTerms(){const state=getNodeFilterState();return sortNodes(TERMS.filter(term=>matchesNodeFilters(term,state)),state.sort);}
function showTermDetail(term){
  if(!term) return;
  const detail=document.getElementById("detail");
  detail.style.display="block";
  detail.style.borderColor=(TYPE_CFG[term.type]?.col||"#444")+"44";
  detail.setAttribute("tabindex","-1");
  document.getElementById("d-label").textContent=term.label;
  const typeEl=document.getElementById("d-type");
  typeEl.textContent=term.type.toUpperCase();
  typeEl.style.color=TYPE_CFG[term.type]?.col||"var(--text)";
  document.getElementById("d-desc").innerHTML=buildTermDescriptionDetail(term);
  const slicesEl=document.getElementById("d-slices");
  if(term.slices.length){
    slicesEl.innerHTML=term.slices.map(sliceId=>{
      const disc=DISCS[sliceId];
      if(!disc) return "";
      return `<span class="dtag" style="background:${disc.col}22;color:${disc.col};border:1px solid ${disc.col}44">${disc.abbr}</span>`;
    }).join("");
  }else{
    slicesEl.innerHTML="<span style=\"font-size:12px;color:var(--muted);font-style:italic\">synthesis only - not in any single probe</span>";
  }
  const citeEl=document.getElementById("d-citations");
  const linked=getLinkedCitationsForTerm(term);
  renderEvidenceCardsInto(citeEl,linked,{variant:"compact",currentTermLabel:term.label});
  detail.focus();
}
function renderNodeFilterResults(){
  const list=document.getElementById("node-filter-results");
  const summary=document.getElementById("node-filter-summary");
  if(!list||!summary) return;
  const visible=getVisibleNodeTerms();
  summary.textContent=`Showing ${visible.length}/${TERMS.length} nodes after filters.`;
  list.innerHTML="";
  if(!visible.length){
    list.innerHTML="<div class=\"matrix-note\">No nodes match current filters.</div>";
    return;
  }
  for(const term of visible.slice(0,40)){
    const row=document.createElement("button");
    row.type="button";
    row.className="node-hit";
    const signal=getTermSignalModel(term);
    const outcome=signal.outcome;
    const waStatus=waTermStatusLabel(signal.waGroundingStatus);
    const relevance=Number(signal.relevanceScore).toFixed(2);
    const evidence=Number(signal.evidenceSupportScore).toFixed(2);
    row.innerHTML=`<div>${escapeHtml(term.label)}</div><div class="node-hit-meta">${escapeHtml(term.type)} | probes ${(term.slices||[]).length} | citations ${(term.citations||[]).length} | outcome ${escapeHtml(termGroundingOutcomeLabel(outcome))} | WA ${escapeHtml(waStatus)} | relevance ${relevance} (${escapeHtml(signal.relevanceBand)}) | evidence ${evidence} (${escapeHtml(signal.evidenceBand)})</div>`;
    row.addEventListener("click",()=>{if(activeTab!=="plot"){switchMainTab("plot",{focusTarget:false});}showTermDetail(term);});
    list.appendChild(row);
  }
}
function clearNodeFilters(){const set=(id,val)=>{const el=document.getElementById(id);if(!el) return;el.value=val;};set("node-search-input","");set("node-type-filter","all");set("node-grounding-filter","all");set("node-min-probe-filter","0");set("node-min-citation-filter","0");set("node-sort-select","probe_coverage");}
function initNodeFilterControls(){const ids=["node-search-input","node-type-filter","node-grounding-filter","node-min-probe-filter","node-min-citation-filter","node-sort-select"];for(const id of ids){const el=document.getElementById(id);if(!el) continue;const evt=(id==="node-search-input"||id==="node-min-probe-filter"||id==="node-min-citation-filter")?"input":"change";el.addEventListener(evt,()=>{if(plotInited&&activeTab==="plot"){renderPlot();}renderNodeFilterResults();});}const clearBtn=document.getElementById("node-filter-clear-btn");if(clearBtn){clearBtn.addEventListener("click",()=>{clearNodeFilters();if(plotInited&&activeTab==="plot"){renderPlot();}renderNodeFilterResults();});}}
function renderGroundingLegend(){const modeSel=document.getElementById("node-color-mode-select");if(modeSel&&modeSel.value!==nodeColorMode) modeSel.value=nodeColorMode;const overlayCheck=document.getElementById("grounding-overlay-check");if(overlayCheck&&overlayCheck.checked!==showGroundingOverlays) overlayCheck.checked=showGroundingOverlays;const modeLabel=document.getElementById("color-mode-label");if(modeLabel) modeLabel.textContent=nodeColorMode==="grounding"?"NODE COLOR: GROUNDING QUALITY":"NODE COLOR: TYPE";const note=document.getElementById("grounding-encoding-note");if(note){note.textContent=nodeColorMode==="grounding"?"Grounding color mode active. Green/teal = WA grounded or local-defined; amber = WA metadata-only; red = WA unresolved; gray = WA not attempted.":"Node type color mode active. Enable grounding color mode to spotlight WA-unresolved clusters without affecting relevance.";if(showGroundingOverlays){note.textContent+= " Halos/rings are enabled.";}else{note.textContent+= " Halos/rings are hidden.";}}}
function tabNameForButton(btn){if(!btn) return "generator";return btn.id==="tab-plot-btn"?"plot":"generator";}
function buttonForTabName(name){return name==="plot"?plotTabBtn:generatorTabBtn;}
function setPanelVisibility(el,visible,displayStyle){if(!el) return;el.hidden=!visible;el.setAttribute("aria-hidden",visible?"false":"true");el.style.display=visible?displayStyle:"none";}
function updateTabState(activeName){for(const btn of TAB_ORDER){const selected=tabNameForButton(btn)===activeName;btn.classList.toggle("active",selected);btn.setAttribute("aria-selected",selected?"true":"false");btn.tabIndex=selected?0:-1;}}
function focusTabTarget(activeName){if(activeName==="generator"){const focusEl=document.getElementById("target-input")||setupEl;if(focusEl&&typeof focusEl.focus==="function"){focusEl.focus();}return;}if(isGenerating){progressEl.setAttribute("tabindex","-1");progressEl.focus();return;}const sidebar=document.getElementById("sidebar");if(sidebar&&typeof sidebar.focus==="function"){sidebar.setAttribute("tabindex","-1");sidebar.focus();return;}const plotEl=document.getElementById("plot");if(plotEl&&typeof plotEl.focus==="function"){plotEl.setAttribute("tabindex","-1");plotEl.focus();}}
function moveTabFocus(currentBtn,delta){const idx=TAB_ORDER.indexOf(currentBtn);if(idx===-1||!TAB_ORDER.length) return;const next=(idx+delta+TAB_ORDER.length)%TAB_ORDER.length;TAB_ORDER[next]?.focus();}
function initTabAccessibility(){for(const btn of TAB_ORDER){btn.addEventListener("click",()=>switchMainTab(tabNameForButton(btn),{focusTarget:true}));btn.addEventListener("keydown",e=>{if(e.key==="ArrowRight"){e.preventDefault();moveTabFocus(btn,1);return;}if(e.key==="ArrowLeft"){e.preventDefault();moveTabFocus(btn,-1);return;}if(e.key==="Home"){e.preventDefault();TAB_ORDER[0]?.focus();return;}if(e.key==="End"){e.preventDefault();TAB_ORDER[TAB_ORDER.length-1]?.focus();return;}if(e.key==="Enter"||e.key===" "){e.preventDefault();switchMainTab(tabNameForButton(btn),{focusTarget:true});}});}}
function switchMainTab(tab,{silent=false,focusTarget=true}={}){const target=tab==="plot"?"plot":"generator";if(target==="plot"&&!isGenerating&&!plotInited&&!TERMS.length){if(!silent) showToast("No plot yet. Launch an expedition first.");return;}activeTab=target;updateTabState(activeTab);if(activeTab==="generator"){setPanelVisibility(setupEl,true,"flex");setPanelVisibility(plotPanelEl,false,"block");setPanelVisibility(progressEl,false,"flex");setPanelVisibility(vizEl,false,"flex");setArtifactDrawer(false);setExportMenu(false);if(focusTarget) focusTabTarget("generator");return;}setPanelVisibility(setupEl,false,"flex");setPanelVisibility(plotPanelEl,true,"block");if(isGenerating){setPanelVisibility(progressEl,true,"flex");setPanelVisibility(vizEl,false,"flex");setArtifactDrawer(false);}else{setPanelVisibility(progressEl,false,"flex");setPanelVisibility(vizEl,true,"flex");refreshArtifactList();if(plotInited){requestAnimationFrame(()=>{try{Plotly.Plots.resize(document.getElementById("plot"));renderPlot();}catch(err){console.warn("Plot resize failed:",err);}});}}if(focusTarget) focusTabTarget("plot");}
function isElementVisibleForFocus(el){if(!(el instanceof HTMLElement)) return false;if(el.hidden) return false;const style=getComputedStyle(el);if(style.display==="none"||style.visibility==="hidden") return false;return el.getClientRects().length>0;}
function getFocusableElementsInModal(modal){if(!modal) return [];const nodes=[...modal.querySelectorAll(MODAL_FOCUSABLE_SELECTOR)];return nodes.filter(el=>el instanceof HTMLElement&&isElementVisibleForFocus(el));}
function getOpenModals(){return [...document.querySelectorAll(".modal")].filter(el=>el instanceof HTMLElement&&getComputedStyle(el).display!=="none");}
function getActiveOpenModal(){if(ACTIVE_MODAL_ID){const candidate=document.getElementById(ACTIVE_MODAL_ID);if(candidate&&getComputedStyle(candidate).display!=="none") return candidate;}const open=getOpenModals();return open.length?open[open.length-1]:null;}
function focusModalEntry(modal){if(!modal) return;const card=modal.querySelector(".modal-card");const focusables=getFocusableElementsInModal(modal);const target=focusables[0]||card||modal;if(target instanceof HTMLElement){if(!target.hasAttribute("tabindex")&&(target===card||target===modal)) target.setAttribute("tabindex","-1");target.focus({preventScroll:true});}}
function handleModalKeyboard(e){
  const modal=getActiveOpenModal();
  if(!modal) return;
  if(e.key==="Escape"){
    e.preventDefault();
    closeModal(modal.id);
    return;
  }
  if(e.key!=="Tab") return;
  const focusables=getFocusableElementsInModal(modal);
  if(!focusables.length){
    e.preventDefault();
    focusModalEntry(modal);
    return;
  }
  const first=focusables[0];
  const last=focusables[focusables.length-1];
  const active=document.activeElement;
  if(e.shiftKey){
    if(active===first||!modal.contains(active)){e.preventDefault();last.focus();}
    return;
  }
  if(active===last||!modal.contains(active)){e.preventDefault();first.focus();}
}
function openModal(id){
  const el=document.getElementById(id);
  if(!el) return;
  const wasOpen=getComputedStyle(el).display!=="none";
  const opener=document.activeElement;
  if(!wasOpen&&opener instanceof HTMLElement&&!el.contains(opener)){MODAL_RETURN_FOCUS.set(id,opener);}
  el.style.display="flex";
  ACTIVE_MODAL_ID=id;
  requestAnimationFrame(()=>focusModalEntry(el));
}
function closeModal(id){
  const el=document.getElementById(id);
  if(!el) return;
  const wasOpen=getComputedStyle(el).display!=="none";
  el.style.display="none";
  if(ACTIVE_MODAL_ID===id){const open=getOpenModals();ACTIVE_MODAL_ID=open.length?open[open.length-1].id:"";}
  const opener=MODAL_RETURN_FOCUS.get(id);
  MODAL_RETURN_FOCUS.delete(id);
  if(wasOpen&&opener instanceof HTMLElement&&document.contains(opener)){requestAnimationFrame(()=>{try{opener.focus({preventScroll:true});}catch{}});}
}
function ambiguityQueueKey(raw){const runId=String(raw?.runId||CURRENT_RUN_ID||"run").trim()||"run";const term=toCanonicalKey(raw?.termLabel||"");const disc=toCanonicalKey(raw?.discName||"");if(!term) return "";return `${runId}|${disc}|${term}`;}
function getAmbiguityReasonsFromDiagnostic(item){const reasons=[];const diagReasons=(Array.isArray(item?.reasons)?item.reasons:[]).map(x=>String(x||"").trim().toLowerCase()).filter(Boolean);if(diagReasons.some(r=>["generic_placeholder","too_short","mostly_numeric","same_as_label","empty"].includes(r))||String(item?.snippet||"").trim().toLowerCase()==="entity"){reasons.push("generic_result");}const mismatchReason=diagReasons.find(r=>r.startsWith("category_mismatch_"));if(mismatchReason) reasons.push(mismatchReason);if(diagReasons.includes("name_like_interpretation")) reasons.push("name_like_interpretation");if(diagReasons.includes("forced_metadata_only_name_like_interpretation")) reasons.push("forced_metadata_only_name_like_interpretation");if(diagReasons.some(r=>r.startsWith("single_word_drift"))) reasons.push("single_word_drift");if(diagReasons.some(r=>r.includes("closest_interpretation_type_mismatch"))) reasons.push("closest_interpretation_type_mismatch");if(diagReasons.some(r=>r.includes("assumption_clash_generic_token"))) reasons.push("assumption_clash_generic_token");if(diagReasons.some(r=>r.includes("composite_term_default_metadata_only"))) reasons.push("composite_term_default_metadata_only");if(diagReasons.some(r=>r.startsWith("suspicious_acceptance_"))) reasons.push("suspicious_acceptance_audit");const assumptions=(Array.isArray(item?.assumptions)?item.assumptions:[]).map(x=>String(x||"").trim()).filter(Boolean);if(new Set(assumptions.map(x=>x.toLowerCase())).size>1){reasons.push("conflicting_assumptions");}const status=String(item?.status||"").trim().toLowerCase();const confidence=String(item?.confidence||"").trim().toLowerCase();const lowConfidence=confidence==="low"||/rejected|error|failed|no_plaintext/.test(status)||diagReasons.some(r=>r.startsWith("score_below_threshold")||r.startsWith("quality_below_threshold")||r.startsWith("alignment_below_threshold"));if(lowConfidence) reasons.push("low_confidence_interpretation");return [...new Set(reasons)];}
function normalizeAmbiguityQueueItem(raw){const base=raw&&typeof raw==="object"?raw:{};const id=ambiguityQueueKey(base)||String(base.id||"").trim();const reasons=getAmbiguityReasonsFromDiagnostic(base);const reviewStatus=String(base.reviewStatus||"pending").trim().toLowerCase();const normalizedReview=["pending","kept_probe_only","accepted_wa","retried"].includes(reviewStatus)?reviewStatus:"pending";return {id,runId:base?.runId||CURRENT_RUN_ID||null,timestamp:String(base?.timestamp||new Date().toISOString()),target:String(base?.target||"").trim(),discName:String(base?.discName||"").trim(),termLabel:String(base?.termLabel||"").trim(),query:String(base?.query||"").trim(),snippet:String(base?.snippet||"").trim(),inputInterpretation:String(base?.inputInterpretation||"").trim(),bestDefinition:String(base?.bestDefinition||"").trim(),chosenInterpretation:String(base?.chosenInterpretation||"").trim(),assumptions:Array.isArray(base?.assumptions)?base.assumptions.map(x=>normalizeWolframAssumptionText(x,{})).filter(Boolean):[],didYouMeans:Array.isArray(base?.didYouMeans)?base.didYouMeans.map(x=>String(x||"").trim()).filter(Boolean):[],warnings:Array.isArray(base?.warnings)?base.warnings.map(x=>String(x||"").trim()).filter(Boolean):[],reasons:Array.isArray(base?.reasons)?base.reasons.map(x=>String(x||"").trim()).filter(Boolean):[],ambiguityReasons:Array.isArray(base?.ambiguityReasons)&&base.ambiguityReasons.length?base.ambiguityReasons.map(x=>String(x||"").trim()).filter(Boolean):reasons,score:Number.isFinite(Number(base?.score))?Number(base.score):null,snippetQualityScore:Number.isFinite(Number(base?.snippetQualityScore))?Number(base.snippetQualityScore):Number.isFinite(Number(base?.snippet_quality_score))?Number(base.snippet_quality_score):null,semanticAlignmentScore:Number.isFinite(Number(base?.semanticAlignmentScore))?Number(base.semanticAlignmentScore):Number.isFinite(Number(base?.semantic_alignment_score))?Number(base.semantic_alignment_score):null,confidence:String(base?.confidence||"").trim()||"low",status:String(base?.status||"").trim(),accepted:Boolean(base?.accepted),reviewStatus:normalizedReview,reviewNote:String(base?.reviewNote||"").trim(),reviewedAt:String(base?.reviewedAt||"").trim(),retryCount:clampInt(base?.retryCount||0,0,999),lastUpdated:String(base?.lastUpdated||base?.timestamp||new Date().toISOString()).trim()};}
function normalizeAmbiguitySeverity(item){
  const reasons=new Set((Array.isArray(item?.ambiguityReasons)?item.ambiguityReasons:[]).map(x=>String(x||"").toLowerCase()));
  let severity=1;
  if(reasons.has("low_confidence_interpretation")) severity+=0.35;
  if(reasons.has("conflicting_assumptions")) severity+=0.55;
  if(reasons.has("generic_result")) severity+=0.3;
  if(reasons.has("closest_interpretation_type_mismatch")) severity+=0.45;
  if(reasons.has("single_word_drift")) severity+=0.25;
  if(reasons.has("name_like_interpretation")||reasons.has("forced_metadata_only_name_like_interpretation")) severity+=0.5;
  if([...reasons].some(r=>r.startsWith("category_mismatch_"))) severity+=0.4;
  const status=String(item?.status||"").toLowerCase();
  if(status.includes("no_plaintext")) severity+=0.3;
  if(status.includes("error")) severity+=0.35;
  const confidence=String(item?.confidence||"low").toLowerCase();
  if(confidence==="low") severity+=0.25;
  else if(confidence==="medium") severity+=0.1;
  const didYouCount=Array.isArray(item?.didYouMeans)?item.didYouMeans.length:0;
  const warnCount=Array.isArray(item?.warnings)?item.warnings.length:0;
  const assumptionCount=Array.isArray(item?.assumptions)?item.assumptions.length:0;
  severity+=Math.min(0.55,(didYouCount*0.06)+(warnCount*0.06)+(assumptionCount>1?0.18:0));
  const retryCount=clampInt(item?.retryCount||0,0,999);
  severity+=Math.min(0.5,retryCount*0.1);
  return Math.max(0.8,Math.min(4,severity));
}
function computeAmbiguityPriority(item){
  const term=findTermForAmbiguityItem(item);
  const centrality=clamp01(Number(term?.centrality??0.5));
  const contradictionBoost=term?.type==="contradictory"?0.8:0;
  const emergentBoost=term?.type==="emergent"?0.6:0;
  const ambiguitySeverity=normalizeAmbiguitySeverity(item);
  const priority=centrality*(1+contradictionBoost+emergentBoost)*ambiguitySeverity;
  return {priority,centrality,ambiguitySeverity,contradictionBoost,emergentBoost,termType:String(term?.type||"unknown")};
}
function sortAmbiguityQueueInPlace(){AMBIGUITY_QUEUE.sort((a,b)=>{const ap=a?.reviewStatus==="pending"?0:1;const bp=b?.reviewStatus==="pending"?0:1;if(ap!==bp) return ap-bp;const pa=computeAmbiguityPriority(a).priority;const pb=computeAmbiguityPriority(b).priority;if(Math.abs(pb-pa)>1e-6) return pb-pa;const at=Date.parse(a?.lastUpdated||a?.timestamp||0)||0;const bt=Date.parse(b?.lastUpdated||b?.timestamp||0)||0;return bt-at;});}
function getPendingAmbiguityCount(){return AMBIGUITY_QUEUE.filter(item=>item.reviewStatus==="pending").length;}
function updateAmbiguityQueueUIState(){const btn=document.getElementById("ambiguity-btn");if(!btn) return;const pending=getPendingAmbiguityCount();btn.textContent=pending>0?`AMBIGUITY (${pending})`:"AMBIGUITY";}
function upsertAmbiguityQueueItem(raw,{preserveReview=true}={}){const item=normalizeAmbiguityQueueItem(raw);if(!item.id||!item.termLabel) return null;if(!Array.isArray(item.ambiguityReasons)||!item.ambiguityReasons.length) return null;const idx=AMBIGUITY_QUEUE.findIndex(row=>row.id===item.id);if(idx>=0){const existing=AMBIGUITY_QUEUE[idx];const merged={...existing,...item};if(preserveReview&&existing.reviewStatus&&existing.reviewStatus!=="pending"){merged.reviewStatus=existing.reviewStatus;merged.reviewNote=existing.reviewNote;merged.reviewedAt=existing.reviewedAt;}merged.retryCount=Math.max(clampInt(existing.retryCount||0,0,999),clampInt(item.retryCount||0,0,999));AMBIGUITY_QUEUE[idx]=merged;}else{AMBIGUITY_QUEUE.push(item);}sortAmbiguityQueueInPlace();if(RUN_STATE) RUN_STATE.ambiguityQueue=[...AMBIGUITY_QUEUE];updateAmbiguityQueueUIState();return item;}
function upsertAmbiguityFromDiagnostic(item){const reasons=getAmbiguityReasonsFromDiagnostic(item);if(!reasons.length) return;upsertAmbiguityQueueItem({...item,ambiguityReasons:reasons,lastUpdated:String(item?.timestamp||new Date().toISOString())});}
function rebuildAmbiguityQueueFromDiagnostics(importedQueue=[]){const preserved=new Map();if(Array.isArray(importedQueue)){for(const raw of importedQueue){const item=normalizeAmbiguityQueueItem(raw);if(!item.id) continue;preserved.set(item.id,item);}}const rebuilt=[];for(const diag of (WOLFRAM_GROUNDING_DIAGNOSTICS||[])){const reasons=getAmbiguityReasonsFromDiagnostic(diag);if(!reasons.length) continue;const item=normalizeAmbiguityQueueItem({...diag,ambiguityReasons:reasons,lastUpdated:String(diag?.timestamp||new Date().toISOString())});if(!item.id) continue;const existing=preserved.get(item.id);if(existing&&existing.reviewStatus&&existing.reviewStatus!=="pending"){item.reviewStatus=existing.reviewStatus;item.reviewNote=existing.reviewNote;item.reviewedAt=existing.reviewedAt;item.retryCount=existing.retryCount||0;}const idx=rebuilt.findIndex(row=>row.id===item.id);if(idx>=0){const prev=rebuilt[idx];const prevTs=Date.parse(prev?.lastUpdated||prev?.timestamp||0)||0;const nowTs=Date.parse(item?.lastUpdated||item?.timestamp||0)||0;if(nowTs>=prevTs) rebuilt[idx]=item;}else{rebuilt.push(item);}}for(const [id,item] of preserved.entries()){if(!rebuilt.some(row=>row.id===id)) rebuilt.push(item);}AMBIGUITY_QUEUE=rebuilt;sortAmbiguityQueueInPlace();if(RUN_STATE) RUN_STATE.ambiguityQueue=[...AMBIGUITY_QUEUE];updateAmbiguityQueueUIState();}
function formatAmbiguityReason(reason){const key=String(reason||"").trim().toLowerCase();if(key==="generic_result") return "generic WA result";if(key==="conflicting_assumptions") return "conflicting assumptions";if(key==="low_confidence_interpretation") return "low-confidence interpretation";if(key==="single_word_drift") return "single-word drift on multi-word label";if(key==="closest_interpretation_type_mismatch") return "closest interpretation type mismatch";if(key==="assumption_clash_generic_token") return "assumption clash on generic label token";if(key==="composite_term_default_metadata_only") return "composite concept defaulted to metadata-only";if(key==="name_like_interpretation") return "name-like interpretation";if(key==="forced_metadata_only_name_like_interpretation") return "forced metadata-only: name-like interpretation";if(key==="name_like_interpretation_high_alignment_override") return "name-like interpretation allowed by high-alignment override";if(key==="suspicious_acceptance_audit") return "suspicious acceptance auto-downgraded";if(key==="category_mismatch_airport") return "category mismatch: airport";if(key==="category_mismatch_periodical") return "category mismatch: periodical";if(key==="category_mismatch_chemical_compound") return "category mismatch: chemical compound";if(key==="category_mismatch_person") return "category mismatch: person";if(key==="category_mismatch_place") return "category mismatch: place";if(key==="category_mismatch_name_like") return "category mismatch: name-like interpretation";return key||"unspecified";}
function findTermForAmbiguityItem(item){const key=toCanonicalKey(item?.termLabel||"");if(!key) return null;const discName=toCanonicalKey(item?.discName||"");return TERMS.find(t=>toCanonicalKey(t?.label||"")===key&&(!discName||t.slices.some(i=>toCanonicalKey(DISCS[i]?.name||"")===discName)))||TERMS.find(t=>toCanonicalKey(t?.label||"")===key)||null;}
function upsertCitationEntry(cite){if(!cite||typeof cite!=="object") return null;const norm=normalizeCitation(cite);const key=(norm?.url||`${norm?.title}|${norm?.publisher}|${norm?.date}`).toLowerCase();if(!key) return null;const existing=CITATIONS.find(row=>(row?.url||`${row?.title}|${row?.publisher}|${row?.date}`).toLowerCase()===key);if(existing) return existing.id;const nextId=CITATIONS.reduce((max,row)=>Math.max(max,Number(row?.id)||-1),-1)+1;const entry={id:nextId,...norm};CITATIONS.push(entry);return nextId;}
function applyAmbiguityDecisionToTerm(item,decision,{note=""}={}){
  const term=findTermForAmbiguityItem(item);
  if(!term) return false;
  const snippet=String(item?.snippet||item?.bestDefinition||item?.inputInterpretation||"").trim();
  term.descriptions=normalizeTermDescriptions(term.descriptions,{fallbackDescription:term.description,fallbackSource:term.description_source,label:term.label});
  if(snippet){
    term.descriptions.wolframGrounding=mergeDescription(term.descriptions.wolframGrounding,snippet);
  }
  term.descriptions.wolframDisplayMode=decision==="accept"?"append":"metadata_only";
  if(Number.isFinite(Number(item?.score))) term.descriptions.wolframMinScore=clampGroundingSnippetScore(item.score,0.58);
  if(Number.isFinite(Number(item?.semanticAlignmentScore))) term.descriptions.wolframMinAlignmentScore=clampGroundingSnippetScore(item.semanticAlignmentScore,0.55);
  const fallbackDescription=String(term?.descriptions?.synthesisSummary||term?.descriptions?.probeSummary||term.description||"").trim();
  applyDisplayDescriptionForTerm(term,{fallbackDescription,fallbackSource:term.description_source||"llm"});
  const confLevel=normalizeConfidenceLevel(item?.confidence||"low");
  const confScore=Number.isFinite(Number(item?.score))?Number(item.score):null;
  const groundingStatus=decision==="accept"?"grounded":"failed";
  term.grounding=mergeGroundingBlocks(term.grounding,normalizeGroundingBlock({wolframQueriesTried:item?.query?[item.query]:[],wolframInterpretations:[item?.chosenInterpretation,item?.inputInterpretation,...(item?.didYouMeans||[])].filter(Boolean),groundingStatus,wolframConfidence:{level:confLevel,score:confScore},wolframResolution:`manual review: ${decision}`,wolframChosenInterpretation:String(item?.chosenInterpretation||item?.inputInterpretation||"").trim()}));
  term.description_provenance=mergeDescriptionProvenance(term.description_provenance,[{source:"wolfram",stage:"manual_review",status:decision==="accept"?"accepted_manual":"probe_only_manual",impact:decision==="accept"?"display_description_enriched":"metadata_only",query:String(item?.query||""),note:note||`Ambiguity queue decision: ${decision}`}]);
  if(decision==="accept"&&snippet){
    const chosen={query:String(item?.query||""),definition:snippet,scoring:{score:Number.isFinite(Number(item?.score))?Number(item.score):0,confidence:String(item?.confidence||"low"),reasons:Array.isArray(item?.reasons)?item.reasons:[]},parsed:{inputInterpretation:String(item?.inputInterpretation||""),bestDefinition:String(item?.bestDefinition||""),altFacts:[],assumptions:Array.isArray(item?.assumptions)?item.assumptions:[],didYouMeans:Array.isArray(item?.didYouMeans)?item.didYouMeans:[],warnings:Array.isArray(item?.warnings)?item.warnings:[]}};
    const cite=buildWolframGroundingCitation(term.label,chosen,true,"manual ambiguity review",{appliedToDescription:true,policyMode:"manual"});
    const citeId=upsertCitationEntry(cite);
    if(Number.isInteger(citeId)&&!term.citations.includes(citeId)) term.citations.push(citeId);
  }
  refreshTermSignalFields([term]);
  if(document.getElementById("d-label")?.textContent===term.label) showTermDetail(term);
  return true;
}
function buildAmbiguityRetryTemplates(item){
  const label=sanitizeWolframToken(item?.termLabel||"");
  const discName=sanitizeWolframToken(item?.discName||"");
  const domainHint=deriveWolframDomainHintFromDiscName(discName)||discName;
  const templates=[
    {key:"quoted_label",label:"RETRY QUOTED",query:label?`"${label}"`:""},
    {key:"domain_hint",label:"RETRY DOMAIN",query:label&&domainHint?`${label} ${domainHint}`.trim():label},
    {key:"concept_query",label:"RETRY CONCEPT",query:label?`${label} concept`:""}
  ];
  const seen=new Set();
  const out=[];
  for(const t of templates){
    const q=String(t.query||"").trim();
    if(!q) continue;
    const key=q.toLowerCase();
    if(seen.has(key)) continue;
    seen.add(key);
    out.push({...t,query:q});
  }
  return out;
}
function getAmbiguityRetryTemplate(item,templateKey){
  const wanted=String(templateKey||"").trim().toLowerCase();
  return buildAmbiguityRetryTemplates(item).find(t=>String(t.key||"").toLowerCase()===wanted)||null;
}
async function retryAmbiguityWithQuery(item,query,{attemptStrategy="manual_retry",resolutionLabel="manual_retry",reviewNotePrefix="Retried query"}={}){
  const normalizedQuery=String(query||"").trim();
  if(!normalizedQuery) return false;
  const cfg=readApiConfig();
  if(normalizeMode(cfg)!=="proxy"){showToast("Retry requires proxy mode for Wolfram.");return false;}
  if(!cfg?.wolframAppId){showToast("Add Wolfram AppID to retry.");return false;}
  const target=item?.target||RUN_STATE?.target||LAST_RUN?.target||document.getElementById("viz-target-label")?.textContent||"";
  const policy=resolveGroundingPolicy(cfg);
  const data=await fetchWolframJSON(normalizedQuery,cfg,{target,discName:item?.discName||"Ambiguity Review",termLabel:item?.termLabel||"",resolutionLabel});
  const parsed=extractWolframStructured(data);
  const selected=selectWolframSnippetFromParsed(parsed);
  const snippet=String(selected?.snippet||"").trim();
  const chosenInterpretation=String(selected?.chosenInterpretation||parsed?.inputInterpretation||parsed?.bestDefinition||"").trim();
  const chosenPod=resolveWolframChosenPod(parsed,snippet);
  const entityType=String(item?.entityType||item?.wolframEntityType||"").trim();
  const scoring=scoreWolframSnippet(snippet,item?.termLabel||"",policy.minQualityScore,policy.minAlignmentScore,{chosenInterpretation,parsed,entityType,chosenPod});
  const categoryGate=evaluateGroundingCategoryMismatch({termLabel:item?.termLabel||"",entityType,chosenInterpretation,definition:snippet,parsed,chosenPod,policy,scoring});
  const baseDecision=evaluateGroundingApplication(scoring,policy);
  const driftDecision=applySingleWordDriftGuard(baseDecision,scoring);
  const warningDecision=applyWarningAssumptionRiskGuard(driftDecision,scoring);
  const compositeDecision=applyCompositeTermAppendGuard(warningDecision,scoring,{termLabel:item?.termLabel||"",definition:snippet,chosenInterpretation,parsed});
  const decision=applyGroundingCategoryMismatchGuard(compositeDecision,categoryGate);
  const combinedReasons=[...(Array.isArray(scoring?.reasons)?scoring.reasons:[]),...(Array.isArray(decision?.reasons)?decision.reasons:[])];
  const retryStatus=snippet?(decision.accepted?decision.status:String(decision?.status||"rejected_low_confidence")):"no_plaintext";
  const retryReasons=snippet?combinedReasons:[...new Set([...(combinedReasons||[]),...buildNoPlaintextReasons(parsed)])];
  recordWolframGroundingDiagnostic({target,discName:item?.discName||"Ambiguity Review",termLabel:item?.termLabel||"",attemptRank:null,attemptStrategy,resolutionLabel,stopReason:resolutionLabel,query:normalizedQuery,snippet,accepted:Boolean(decision?.accepted),status:retryStatus,score:Number.isFinite(Number(scoring?.score))?Number(scoring.score):0,snippetQualityScore:Number.isFinite(Number(scoring?.snippet_quality_score))?Number(scoring.snippet_quality_score):null,semanticAlignmentScore:Number.isFinite(Number(scoring?.semantic_alignment_score))?Number(scoring.semantic_alignment_score):null,confidence:String(scoring?.confidence||"low"),reasons:retryReasons,inputInterpretation:String(parsed?.inputInterpretation||""),bestDefinition:String(parsed?.bestDefinition||""),altFacts:Array.isArray(parsed?.altFacts)?parsed.altFacts:[],assumptions:Array.isArray(parsed?.assumptions)?parsed.assumptions:[],didYouMeans:Array.isArray(parsed?.didYouMeans)?parsed.didYouMeans:[],warnings:Array.isArray(parsed?.warnings)?parsed.warnings:[],chosenInterpretation:String(chosenInterpretation||parsed?.inputInterpretation||parsed?.bestDefinition||""),mode:normalizeMode(cfg),statusCode:200,durationMs:0,cacheStatus:"memory_miss",chosenPod,appliedToDescription:false,success:true});
  const key=ambiguityQueueKey({runId:item?.runId||CURRENT_RUN_ID||"run",discName:item?.discName,termLabel:item?.termLabel});
  const hit=AMBIGUITY_QUEUE.find(row=>row.id===key);
  if(hit){
    hit.reviewStatus="pending";
    hit.reviewNote=`${reviewNotePrefix}: ${normalizedQuery}`;
    hit.reviewedAt="";
    hit.retryCount=clampInt((hit.retryCount||0)+1,0,999);
    hit.lastUpdated=new Date().toISOString();
  }
  sortAmbiguityQueueInPlace();
  updateAmbiguityQueueUIState();
  showToast(snippet?"Retry captured. Review and choose keep/accept.":"Retry returned no usable plaintext.");
  return true;
}
async function retryAmbiguityWithTemplate(item,templateKey){
  const template=getAmbiguityRetryTemplate(item,templateKey);
  if(!template){showToast("Template retry unavailable for this term.");return false;}
  return retryAmbiguityWithQuery(item,template.query,{attemptStrategy:`manual_retry_${template.key}`,resolutionLabel:`manual_retry_${template.key}`,reviewNotePrefix:`Retried ${template.label.toLowerCase()}`});
}
async function retryAmbiguityWithCustomQuery(item){
  const current=String(item?.query||item?.termLabel||"").trim();
  const query=String(prompt("Retry Wolfram query for this term:",current)||"").trim();
  if(!query) return false;
  return retryAmbiguityWithQuery(item,query,{attemptStrategy:"manual_retry",resolutionLabel:"manual_retry",reviewNotePrefix:"Retried custom query"});
}
function renderAmbiguityQueueModal(){
  const summaryEl=document.getElementById("ambiguity-summary");
  const listEl=document.getElementById("ambiguity-modal-content");
  if(!summaryEl||!listEl) return;
  const pending=getPendingAmbiguityCount();
  const resolved=Math.max(0,AMBIGUITY_QUEUE.length-pending);
  summaryEl.textContent=`${pending} pending | ${resolved} reviewed | ${AMBIGUITY_QUEUE.length} total | sorted by priority = centrality * (1 + contradictionBoost + emergentBoost) * ambiguitySeverity`;
  if(!AMBIGUITY_QUEUE.length){
    listEl.innerHTML="<div class=\"matrix-note\">No ambiguous Wolfram terms captured in this run.</div>";
    return;
  }
  listEl.innerHTML=AMBIGUITY_QUEUE.map((item,idx)=>{
    const reasons=(Array.isArray(item?.ambiguityReasons)?item.ambiguityReasons:[]).map(formatAmbiguityReason);
    const statusTag=item.reviewStatus==="pending"?"pending review":item.reviewStatus==="accepted_wa"?"accepted WA":item.reviewStatus==="kept_probe_only"?"kept probe-only":"retried";
    const statusCol=item.reviewStatus==="pending"?"#d97706":"#16a34a";
    const snippet=String(item?.snippet||item?.bestDefinition||item?.inputInterpretation||"").trim();
    const canAccept=Boolean(snippet);
    const assumptions=Array.isArray(item?.assumptions)?item.assumptions:[];
    const warnings=Array.isArray(item?.warnings)?item.warnings:[];
    const didYouMeans=Array.isArray(item?.didYouMeans)?item.didYouMeans:[];
    const priorityMeta=computeAmbiguityPriority(item);
    const templateRetries=buildAmbiguityRetryTemplates(item);
    const reasonHtml=reasons.map(r=>`<span class="tag strong">${escapeHtml(r)}</span>`).join("")||"<span class='tag'>unspecified ambiguity</span>";
    const confidenceText=Number.isFinite(Number(item.score))?` (${Number(item.score).toFixed(2)})`:"";
    const templateButtons=templateRetries.map(t=>`<button class="small-btn" type="button" data-amb-action="retry_template" data-amb-template="${escapeHtml(t.key)}" data-amb-index="${idx}" title="${escapeHtml(t.query)}">${escapeHtml(t.label)}</button>`).join("");
    const templatePreview=templateRetries.length?`<div class="evidence-meta">Templated rewrites: ${escapeHtml(templateRetries.map(t=>`${t.label}: ${t.query}`).join(" | "))}</div>`:"";
    return `<div class="evidence-card"><div class="evidence-top"><div><div class="evidence-title">${escapeHtml(item.termLabel||"(unlabeled term)")}</div><div class="evidence-meta">${escapeHtml(item.discName||"Unknown probe")}</div></div><div class="tag" style="border-color:${statusCol};color:${statusCol}">${escapeHtml(statusTag)}</div></div><div class="tag-row">${reasonHtml}<span class="tag">confidence: ${escapeHtml(item.confidence||"low")}${confidenceText}</span><span class="tag">priority: ${Number(priorityMeta.priority||0).toFixed(2)}</span><span class="tag">severity: ${Number(priorityMeta.ambiguitySeverity||0).toFixed(2)}</span><span class="tag">centrality: ${Number(priorityMeta.centrality||0).toFixed(2)}</span><span class="tag">type: ${escapeHtml(priorityMeta.termType||"unknown")}</span></div><div class="evidence-meta">Query: ${escapeHtml(item.query||"-")}</div><div class="evidence-meta">Snippet: ${escapeHtml(snippet||"(none)")}</div>${assumptions.length?`<div class="evidence-meta">Assumptions: ${escapeHtml(assumptions.slice(0,4).join(" | "))}</div>`:""}${didYouMeans.length?`<div class="evidence-meta">Alternatives: ${escapeHtml(didYouMeans.slice(0,4).join(" | "))}</div>`:""}${warnings.length?`<div class="evidence-meta">Warnings: ${escapeHtml(warnings.slice(0,3).join(" | "))}</div>`:""}${templatePreview}${item.reviewNote?`<div class="evidence-meta">Review note: ${escapeHtml(item.reviewNote)}</div>`:""}<div style="display:flex;gap:6px;flex-wrap:wrap;margin-top:6px"><button class="small-btn" type="button" data-amb-action="keep" data-amb-index="${idx}">KEEP PROBE-ONLY</button><button class="small-btn" type="button" data-amb-action="accept" data-amb-index="${idx}" ${canAccept?"":"disabled"}>ACCEPT WA RESULT</button><button class="small-btn" type="button" data-amb-action="retry" data-amb-index="${idx}">RETRY CUSTOM</button>${templateButtons}</div></div>`;
  }).join("");
}
function showAmbiguityQueueModal(){renderAmbiguityQueueModal();openModal("ambiguity-modal");}
async function onAmbiguityQueueClick(e){
  const btn=e.target.closest("[data-amb-action]");
  if(!btn) return;
  const action=String(btn.getAttribute("data-amb-action")||"").trim();
  const idx=Number(btn.getAttribute("data-amb-index"));
  if(!Number.isInteger(idx)||idx<0||idx>=AMBIGUITY_QUEUE.length) return;
  const item=AMBIGUITY_QUEUE[idx];
  if(!item) return;
  const asyncRetryAction=action==="retry"||action==="retry_template";
  if(asyncRetryAction) btn.disabled=true;
  try{
    if(action==="keep"){
      const ok=applyAmbiguityDecisionToTerm(item,"keep",{note:"Manual review chose probe-only text."});
      if(!ok){showToast("Term not found for this ambiguity entry.");}
      else{item.reviewStatus="kept_probe_only";item.reviewedAt=new Date().toISOString();item.reviewNote="Kept probe-only wording.";item.lastUpdated=item.reviewedAt;showToast("Applied: keep probe-only.");}
    }else if(action==="accept"){
      const ok=applyAmbiguityDecisionToTerm(item,"accept",{note:"Manual review accepted Wolfram result."});
      if(!ok){showToast("Term not found for this ambiguity entry.");}
      else{item.reviewStatus="accepted_wa";item.reviewedAt=new Date().toISOString();item.reviewNote="Accepted Wolfram grounding result.";item.lastUpdated=item.reviewedAt;showToast("Applied: accepted WA result.");}
    }else if(action==="retry"){
      await retryAmbiguityWithCustomQuery(item);
    }else if(action==="retry_template"){
      const templateKey=String(btn.getAttribute("data-amb-template")||"").trim().toLowerCase();
      await retryAmbiguityWithTemplate(item,templateKey);
    }
  }catch(err){
    console.error("Ambiguity queue action failed:",err);
    showToast(`Ambiguity action failed: ${err.message||err}`);
  }finally{
    if(asyncRetryAction) btn.disabled=false;
    if(RUN_STATE) RUN_STATE.ambiguityQueue=[...AMBIGUITY_QUEUE];
    sortAmbiguityQueueInPlace();
    updateAmbiguityQueueUIState();
    renderAmbiguityQueueModal();
    buildStats();
    if(plotInited&&activeTab==="plot"){renderPlot();}
  }
}
function showRawNodeList(){if(!TERMS.length){showToast("No plotted nodes available yet.");return;}const lines=[];for(const term of TERMS){applyDisplayDescriptionForTerm(term,{fallbackDescription:term.description,fallbackSource:term.description_source});const slices=term.slices.length?term.slices.map(i=>DISCS[i]?.name||`Probe ${i+1}`).join(" | "):"Synthesis-only";const pos=`(${(term.pos?.[0]||0).toFixed(3)}, ${(term.pos?.[1]||0).toFixed(3)}, ${(term.pos?.[2]||0).toFixed(3)})`;const reason=String(term?.descriptions?.displayDescriptionReason||"");lines.push(`[${term.type.toUpperCase()}] ${term.label}\n  Probes: ${slices}\n  Pos: ${pos}\n  Desc: ${term.description||"-"}\n  Desc reason: ${reason||"-"}`);}document.getElementById("raw-modal-content").textContent=lines.join("\n\n");openModal("raw-modal");}
async function generateDeepReport(){if(!TERMS.length){showToast("No plotted data available yet.");return;}const cfg=readApiConfig();const cfgError=validateApiConfig(cfg);if(cfgError){showToast(cfgError);return;}const target=LAST_RUN?.target||document.getElementById("viz-target-label").textContent||"Topic";const reportEl=document.getElementById("report-modal-content");reportEl.textContent="Generating report...";openModal("report-modal");const byType={unique:TERMS.filter(t=>t.type==="unique"),convergent:TERMS.filter(t=>t.type==="convergent"),contradictory:TERMS.filter(t=>t.type==="contradictory"),emergent:TERMS.filter(t=>t.type==="emergent")};const partySummaries=DISCS.map(d=>{const terms=TERMS.filter(t=>t.slices.includes(d.id)).map(t=>t.label);return `${d.name}: ${terms.slice(0,18).join(", ")}`;}).join("\n");const contras=byType.contradictory.map(t=>`${t.label} :: ${(t.slices||[]).map(i=>DISCS[i]?.name||`Probe ${i+1}`).join(" vs ")}`).join("\n");const emers=byType.emergent.map(t=>t.label).join(", ");const converg=byType.convergent.map(t=>`${t.label} (${t.slices.length} probes)`).join(", ");const citationLines=CITATIONS.map(c=>`- ${c.title||c.publisher||"Source"} (${c.date||"n.d."}) ${c.url} :: ${c.relevance||"supporting evidence"} [${c.source_type||"untyped"}]`).join("\n");const defaultSystemPrompt="You are a policy analyst writing a deep-research memo from structured multi-perspective evidence.";const userPromptBase=`Topic: ${target}\n\nSource policy: ${cfg.sourcePolicy||"none specified"}\n\nProbe specifications:\n${DISCS.map((d,i)=>`${i+1}. ${d.name}`).join("\n")}\n\nPer-probe key terms:\n${partySummaries}\n\nConvergent terms:\n${converg}\n\nContradictory terms:\n${contras}\n\nEmergent terms:\n${emers}\n\nEvidence sources:\n${citationLines||"- none captured"}\n\nWrite a concise but substantive report with sections:\n1) Executive Summary\n2) Major Alignments\n3) Major Fault Lines\n4) Integrative Policy Options\n5) Key Unknowns and Research Priorities\n6) Caveats\n\nUse clear, non-inflammatory language and cite terms from the map explicitly.`;const defaultUserPrompt=appendPromptMadLibBlock(userPromptBase,cfg,{includeArtifact:true});const promptBundle=resolvePromptBundleWithOverrides("artifact_deep_report",{target,cfg,quality:getQualityProfile(cfg.qualityMode),defaults:{systemPrompt:defaultSystemPrompt,userPrompt:defaultUserPrompt}});try{const text=await callLLM(promptBundle.systemPrompt,promptBundle.userPrompt,cfg);lastReportText=text;LAST_RUN={...(LAST_RUN||{}),report:text};reportEl.textContent=text;}catch(err){console.error("Report generation failed:",err);reportEl.textContent=`Report generation failed:\n${err.message||err}`;}}
async function copyReportText(){if(!lastReportText){showToast("No report text to copy.");return;}try{await navigator.clipboard.writeText(lastReportText);showToast("Report copied to clipboard.");}catch{showToast("Clipboard copy failed.");}}
function buildWolframCitationContext(cite){
  const lines=[];
  if(cite?.wolfram_input_interpretation) lines.push(`Interpretation: ${cite.wolfram_input_interpretation}`);
  if(Array.isArray(cite?.wolfram_did_you_means)&&cite.wolfram_did_you_means.length) lines.push(`Alternatives: ${cite.wolfram_did_you_means.slice(0,4).join(", ")}`);
  if(Array.isArray(cite?.wolfram_assumptions)&&cite.wolfram_assumptions.length) lines.push(`Assumptions: ${cite.wolfram_assumptions.slice(0,3).join(" | ")}`);
  if(Array.isArray(cite?.wolfram_warnings)&&cite.wolfram_warnings.length) lines.push(`Warnings: ${cite.wolfram_warnings.slice(0,2).join(" | ")}`);
  return lines.join("\n");
}
function formatWolframGroundingStatusLabel(status){
  const key=String(status||"").trim().toLowerCase();
  if(!key) return "";
  if(key==="accepted") return "WA grounded (applied)";
  if(key==="accepted_metadata_only"||key==="accepted_annotation_only") return "WA grounded (metadata-only)";
  if(key==="rejected_category_mismatch") return "WA mismatch";
  if(key==="no_plaintext"||key==="no_plaintext_after_fallbacks"||key==="cache_hit_term_no_match") return "WA no plaintext";
  if(key==="rejected_low_confidence") return "WA low-confidence";
  if(key==="error") return "WA unresolved (request error)";
  return key.replace(/_/g," ");
}
function detectCitationProvider(cite){
  const sourceType=normalizeSourceType(cite?.source_type,cite?.publisher);
  if(sourceType==="wolfram") return "wolfram";
  const publisher=String(cite?.publisher||"").toLowerCase();
  const url=String(cite?.url||"").toLowerCase();
  if(publisher.includes("wolfram")||url.includes("wolfram")) return "wolfram";
  return "web";
}
function getEvidenceFilterState(){
  const state=EVIDENCE_FILTER_STATE&&typeof EVIDENCE_FILTER_STATE==="object"?EVIDENCE_FILTER_STATE:{};
  return {sourceType:String(state.sourceType||"all"),termLabel:String(state.termLabel||"").trim(),provider:String(state.provider||"all")};
}
function setEvidenceFilterState(nextState){
  const prev=getEvidenceFilterState();
  EVIDENCE_FILTER_STATE={sourceType:String(nextState?.sourceType||prev.sourceType||"all"),termLabel:String(nextState?.termLabel||prev.termLabel||"").trim(),provider:String(nextState?.provider||prev.provider||"all")};
}
function citationSupportsTerm(cite,termLabel){
  const query=String(termLabel||"").trim().toLowerCase();
  if(!query) return true;
  const mappingTerms=(Array.isArray(cite?.supporting_term_mappings)?cite.supporting_term_mappings:[]).flatMap(m=>[m?.supporting_term,m?.mapped_term,m?.via_alias]);
  const fields=[...(Array.isArray(cite?.supporting_terms)?cite.supporting_terms:[]),...(Array.isArray(cite?.supporting_terms_raw)?cite.supporting_terms_raw:[]),...mappingTerms,cite?.title,cite?.publisher,cite?.quote_or_snippet,cite?.relevance];
  return fields.some(value=>String(value||"").toLowerCase().includes(query));
}
function citationMatchesEvidenceFilters(cite,state){
  const sourceType=normalizeSourceType(cite?.source_type,cite?.publisher)||"untyped";
  if(state.sourceType!=="all"&&sourceType!==state.sourceType) return false;
  const provider=detectCitationProvider(cite);
  if(state.provider!=="all"&&provider!==state.provider) return false;
  if(!citationSupportsTerm(cite,state.termLabel)) return false;
  return true;
}
function createEvidenceTag(text,{strong=false,extraClass=""}={}){
  const tag=document.createElement("span");
  tag.className=`tag${strong?" strong":""}${extraClass?` ${extraClass}`:""}`;
  tag.textContent=String(text||"").trim();
  return tag;
}
function getCitationSupportingTerms(cite,maxItems=10){
  const values=[
    ...(Array.isArray(cite?.supporting_terms)?cite.supporting_terms:[]),
    ...(Array.isArray(cite?.supporting_terms_raw)?cite.supporting_terms_raw:[])
  ];
  return dedupeCasefold(values,maxItems).slice(0,maxItems);
}
function buildEvidenceSnippetText(cite,{variant="full"}={}){
  const base=String(cite?.quote_or_snippet||cite?.relevance||"No snippet provided.").trim();
  if(variant==="compact"){
    return base.length>220?`${base.slice(0,217)}...`:base;
  }
  const wolframContext=buildWolframCitationContext(cite);
  const mapContext=(Array.isArray(cite?.supporting_term_mappings)&&cite.supporting_term_mappings.length)?`Alias mapping: ${cite.supporting_term_mappings.slice(0,4).map(m=>`${m.supporting_term} => ${m.mapped_term} (${m.strategy}${Number.isFinite(Number(m.confidence))?`, ${Number(m.confidence).toFixed(2)}`:""})`).join(" | ")}`:"";
  const unmappedContext=(Array.isArray(cite?.unmapped_supporting_terms)&&cite.unmapped_supporting_terms.length)?`Unmapped supporting terms: ${cite.unmapped_supporting_terms.slice(0,6).join(", ")}`:"";
  return [base,mapContext,unmappedContext,wolframContext].filter(Boolean).join("\n");
}
function renderEvidenceCard(cite,{variant="full",currentTermLabel=""}={}){
  const card=document.createElement("div");
  card.className=`evidence-card${variant==="compact"?" compact":""}`;
  const top=document.createElement("div");
  top.className="evidence-top";
  const title=document.createElement("div");
  title.className="evidence-title";
  title.textContent=cite?.title||cite?.publisher||cite?.url||"Untitled source";
  const meta=document.createElement("div");
  meta.className="evidence-meta";
  meta.textContent=[cite?.publisher,cite?.date].filter(Boolean).join(" | ");
  top.appendChild(title);
  top.appendChild(meta);
  card.appendChild(top);
  const tags=document.createElement("div");
  tags.className="tag-row";
  const sourceType=normalizeSourceType(cite?.source_type,cite?.publisher);
  if(sourceType){
    tags.appendChild(createEvidenceTag(sourceTypeLabel(sourceType,cite?.publisher),{strong:true}));
  }
  tags.appendChild(createEvidenceTag(`provider: ${detectCitationProvider(cite)}`));
  if(cite?.grounding_status){
    tags.appendChild(createEvidenceTag(`grounding: ${formatWolframGroundingStatusLabel(cite.grounding_status)}`));
  }
  const supportingTerms=getCitationSupportingTerms(cite,variant==="compact"?5:12);
  if(supportingTerms.length){
    tags.appendChild(createEvidenceTag(`supports: ${supportingTerms.length}`));
  }
  if(Array.isArray(cite?.supporting_term_mappings)&&cite.supporting_term_mappings.length&&variant!=="compact"){
    tags.appendChild(createEvidenceTag(`mapped aliases: ${cite.supporting_term_mappings.length}`));
  }
  if(Array.isArray(cite?.unmapped_supporting_terms)&&cite.unmapped_supporting_terms.length&&variant!=="compact"){
    tags.appendChild(createEvidenceTag(`unmapped terms: ${cite.unmapped_supporting_terms.length}`));
  }
  card.appendChild(tags);
  if(supportingTerms.length){
    const termsRow=document.createElement("div");
    termsRow.className="evidence-supporting";
    const label=document.createElement("span");
    label.className="evidence-meta";
    label.textContent="supporting terms:";
    termsRow.appendChild(label);
    const currentKey=toCanonicalKey(currentTermLabel||"");
    for(const termLabel of supportingTerms){
      const matched=currentKey&&toCanonicalKey(termLabel)===currentKey;
      termsRow.appendChild(createEvidenceTag(termLabel,{strong:matched,extraClass:matched?"evidence-term-match":""}));
    }
    card.appendChild(termsRow);
  }
  const snippet=document.createElement("div");
  snippet.className="evidence-meta";
  snippet.textContent=buildEvidenceSnippetText(cite,{variant});
  card.appendChild(snippet);
  const actions=document.createElement("div");
  const openBtn=document.createElement("button");
  openBtn.className="small-btn";
  const safeUrl=safeHttpUrl(cite?.url);
  openBtn.textContent=safeUrl?"OPEN":"NO URL";
  openBtn.disabled=!safeUrl;
  openBtn.onclick=()=>{if(safeUrl) window.open(safeUrl,"_blank","noopener");};
  actions.appendChild(openBtn);
  card.appendChild(actions);
  return card;
}
function renderEvidenceCardsInto(container,citations,{variant="full",currentTermLabel=""}={}){
  if(!container) return;
  container.innerHTML="";
  const entries=Array.isArray(citations)?citations:[];
  if(!entries.length){
    container.innerHTML="<div class=\"matrix-note\">No linked evidence.</div>";
    return;
  }
  for(const cite of entries){
    container.appendChild(renderEvidenceCard(cite,{variant,currentTermLabel}));
  }
}
function renderEvidenceModalContent(){
  const list=document.getElementById("evidence-modal-content");
  const bar=document.getElementById("evidence-filter-bar");
  if(!list||!bar) return;
  const state=getEvidenceFilterState();
  const sourceTypes=dedupeCasefold(CITATIONS.map(c=>normalizeSourceType(c.source_type,c.publisher)||"untyped"),40).sort((a,b)=>sourceTypeLabel(a).localeCompare(sourceTypeLabel(b)));
  const termOptions=dedupeCasefold(CITATIONS.flatMap(c=>[...(Array.isArray(c?.supporting_terms)?c.supporting_terms:[]),...(Array.isArray(c?.supporting_terms_raw)?c.supporting_terms_raw:[]),...((Array.isArray(c?.supporting_term_mappings)?c.supporting_term_mappings:[]).flatMap(m=>[m?.supporting_term,m?.mapped_term,m?.via_alias]))]),220);
  const sourceOptions=sourceTypes.map(type=>`<option value="${escapeHtml(type)}">${escapeHtml(sourceTypeLabel(type))}</option>`).join("");
  const termDatalist=termOptions.length?`<datalist id="evidence-term-options">${termOptions.map(term=>`<option value="${escapeHtml(term)}"></option>`).join("")}</datalist>`:"";
  bar.innerHTML=`<div class="sec-label">EVIDENCE FILTERS</div>
  <div class="filter-grid" style="margin-top:6px">
    <div class="field-group"><label for="evidence-source-filter">Source type</label><select id="evidence-source-filter"><option value="all">All</option>${sourceOptions}</select></div>
    <div class="field-group"><label for="evidence-provider-filter">Provider</label><select id="evidence-provider-filter"><option value="all">All</option><option value="wolfram">Wolfram</option><option value="web">Web</option></select></div>
    <div class="field-group"><label for="evidence-term-filter">Term label</label><input id="evidence-term-filter" list="evidence-term-options" type="text" value="${escapeHtml(state.termLabel)}" placeholder="Filter by term label"/></div>
  </div>
  ${termDatalist}
  <div class="row-inline" style="margin-top:6px"><button class="small-btn" id="evidence-filter-clear-btn" type="button">CLEAR</button><div class="matrix-note" id="evidence-filter-summary"></div></div>`;
  const sourceEl=document.getElementById("evidence-source-filter");
  const providerEl=document.getElementById("evidence-provider-filter");
  const termEl=document.getElementById("evidence-term-filter");
  if(sourceEl) sourceEl.value=sourceTypes.includes(state.sourceType)||state.sourceType==="all"?state.sourceType:"all";
  if(providerEl) providerEl.value=state.provider==="wolfram"||state.provider==="web"?state.provider:"all";
  if(termEl) termEl.value=state.termLabel;
  const activeState={sourceType:sourceEl?.value||"all",provider:providerEl?.value||"all",termLabel:String(termEl?.value||"").trim()};
  setEvidenceFilterState(activeState);
  const filtered=CITATIONS.filter(cite=>citationMatchesEvidenceFilters(cite,activeState));
  const summaryEl=document.getElementById("evidence-filter-summary");
  if(summaryEl) summaryEl.textContent=`Showing ${filtered.length}/${CITATIONS.length} sources.`;
  list.innerHTML="";
  if(!filtered.length){
    list.innerHTML="<div class=\"matrix-note\">No evidence matches current filters.</div>";
  }else{
    for(const cite of filtered){
      list.appendChild(renderEvidenceCard(cite,{variant:"full",currentTermLabel:activeState.termLabel}));
    }
  }
  sourceEl?.addEventListener("change",()=>{setEvidenceFilterState({sourceType:sourceEl.value});renderEvidenceModalContent();});
  providerEl?.addEventListener("change",()=>{setEvidenceFilterState({provider:providerEl.value});renderEvidenceModalContent();});
  termEl?.addEventListener("input",()=>{setEvidenceFilterState({termLabel:termEl.value});renderEvidenceModalContent();});
  document.getElementById("evidence-filter-clear-btn")?.addEventListener("click",()=>{setEvidenceFilterState({sourceType:"all",provider:"all",termLabel:""});renderEvidenceModalContent();});
}
function showEvidenceModal(){
  if(!CITATIONS.length){collectCitations();}
  if(!CITATIONS.length){showToast("No citations captured yet.");return;}
  renderEvidenceModalContent();
  openModal("evidence-modal");
}
async function generateClaimsLedger(){if(!TERMS.length){showToast("No plotted data available yet.");return;}const cfg=readApiConfig();const cfgError=validateApiConfig(cfg);if(cfgError){showToast(cfgError);return;}const target=LAST_RUN?.target||document.getElementById("viz-target-label").textContent||"Topic";const el=document.getElementById("claims-modal-content");el.textContent="Generating claims ledger...";openModal("claims-modal");const emergent=TERMS.filter(t=>t.type==="emergent").map(t=>t.label);const contradictory=TERMS.filter(t=>t.type==="contradictory").map(t=>t.label);const reportText=lastReportText||"";const defaultSystemPrompt="You are an analyst creating a claims ledger. Return strict JSON only.";const userPromptBase=`Topic: ${target}\n\nEmergent terms:\n${emergent.join(", ")||"-"}\n\nContradictory terms:\n${contradictory.join(", ")||"-"}\n\nReport excerpt:\n${reportText.slice(0,2000)||"(no report yet)"}\n\nReturn JSON only:\n{\n  "claims":[\n    {\n      "claim":"",\n      "confidence":"low|medium|high",\n      "claim_type":"empirical|normative|methodological|forecast",\n      "scope":"where it applies and does not apply",\n      "linked_nodes":["term label"],\n      "evidence_status":"unverified|partial|verified",\n      "counterclaim":"best opposing formulation",\n      "what_would_change_mind":"",\n      "evidence_needed":"what kind of source would count",\n      "next_action":"one concrete verification step"\n    }\n  ]\n}\n\nRules:\n- Use concise, non-inflammatory language\n- If confidence is high, you must provide a falsifiable what_would_change_mind; otherwise set confidence to medium\n- Link claims to emergent or contradictory terms when possible`;const defaultUserPrompt=appendPromptMadLibBlock(userPromptBase,cfg,{includeArtifact:true});const promptBundle=resolvePromptBundleWithOverrides("artifact_claims",{target,cfg,quality:getQualityProfile(cfg.qualityMode),defaults:{systemPrompt:defaultSystemPrompt,userPrompt:defaultUserPrompt}});try{const raw=await callLLMJSON(promptBundle.systemPrompt,promptBundle.userPrompt,cfg);const parsed=extractJSON(raw);const claims=Array.isArray(parsed.claims)?parsed.claims:[];for(const c of claims){const conf=String(c.confidence||"").toLowerCase();const wcm=String(c.what_would_change_mind||"").trim();if(conf==="high"&&!wcm){c.confidence="medium";c.what_would_change_mind="Not specified; requires falsifiability.";}if(!c.evidence_status) c.evidence_status="unverified";}lastClaimsText=formatClaimsLedger(claims);LAST_RUN={...(LAST_RUN||{}),claimsLedger:claims};el.textContent=lastClaimsText||"No claims returned.";}catch(err){console.error("Claims ledger failed:",err);el.textContent=`Claims ledger failed:\n${err.message||err}`;}}
function formatClaimsLedger(claims){if(!Array.isArray(claims)||!claims.length) return "";return claims.map((c,i)=>`#${i+1} ${c.claim||""}\n- Confidence: ${c.confidence||""}\n- Type: ${c.claim_type||""}\n- Scope: ${c.scope||""}\n- Linked nodes: ${(c.linked_nodes||[]).join(", ")||"-"}\n- Evidence status: ${c.evidence_status||""}\n- Counterclaim: ${c.counterclaim||""}\n- What would change mind: ${c.what_would_change_mind||""}\n- Evidence needed: ${c.evidence_needed||""}\n- Next action: ${c.next_action||""}`).join("\n\n");}
async function copyClaimsText(){if(!lastClaimsText){showToast("No claims text to copy.");return;}try{await navigator.clipboard.writeText(lastClaimsText);showToast("Claims copied to clipboard.");}catch{showToast("Clipboard copy failed.");}}
async function generateOutlineFromMap(){if(!TERMS.length){showToast("No plotted data available yet.");return;}const cfg=readApiConfig();const cfgError=validateApiConfig(cfg);if(cfgError){showToast(cfgError);return;}const target=LAST_RUN?.target||document.getElementById("viz-target-label").textContent||"Topic";const el=document.getElementById("outline-modal-content");el.textContent="Generating outline...";openModal("outline-modal");const converg=TERMS.filter(t=>t.type==="convergent").map(t=>t.label);const contras=TERMS.filter(t=>t.type==="contradictory").map(t=>t.label);const emergent=TERMS.filter(t=>t.type==="emergent").map(t=>t.label);const defaultSystemPrompt="You are an editor creating a structured outline from a research map.";const userPromptBase=`Topic: ${target}\n\nPick exactly 3 convergences, 2 fault lines (contradictions), and 1 emergent idea to anchor the outline.\nConvergences: ${converg.join(", ")}\nFault lines: ${contras.join(", ")}\nEmergent: ${emergent.join(", ")}\n\nReturn a structured outline with headings and bullet points, explicitly referencing the chosen nodes.`;const defaultUserPrompt=appendPromptMadLibBlock(userPromptBase,cfg,{includeArtifact:true});const promptBundle=resolvePromptBundleWithOverrides("artifact_outline",{target,cfg,quality:getQualityProfile(cfg.qualityMode),defaults:{systemPrompt:defaultSystemPrompt,userPrompt:defaultUserPrompt}});try{const text=await callLLM(promptBundle.systemPrompt,promptBundle.userPrompt,cfg);lastOutlineText=text;el.textContent=text;LAST_RUN={...(LAST_RUN||{}),outline:text};}catch(err){console.error("Outline generation failed:",err);el.textContent=`Outline generation failed:\n${err.message||err}`;}}
async function copyOutlineText(){if(!lastOutlineText){showToast("No outline text to copy.");return;}try{await navigator.clipboard.writeText(lastOutlineText);showToast("Outline copied to clipboard.");}catch{showToast("Clipboard copy failed.");}}
async function runRedTeamPass(silent=false){if(!TERMS.length){if(!silent) showToast("No plotted data available yet.");return;}const cfg=readApiConfig();const cfgError=validateApiConfig(cfg);if(cfgError){if(!silent) showToast(cfgError);return;}const target=LAST_RUN?.target||document.getElementById("viz-target-label").textContent||"Topic";const el=document.getElementById("critique-modal-content");if(!silent){el.textContent="Generating critique...";openModal("critique-modal");}const defaults={systemPrompt:"You are a skeptical reviewer.",userPrompt:buildRedTeamPrompt(target,RUN_STATE?.probeResults||[],RUN_STATE?.synthResult||{convergent:[],contradictory:[],emergent:[]},cfg)};const promptBundle=resolvePromptBundleWithOverrides("artifact_red_team",{target,cfg,quality:getQualityProfile(cfg.qualityMode),defaults});try{const text=await callLLM(promptBundle.systemPrompt,promptBundle.userPrompt,cfg);lastCritiqueText=text;LAST_RUN={...(LAST_RUN||{}),redTeamCritique:text};if(!silent){el.textContent=text;}}catch(err){console.error("Red-team pass failed:",err);if(!silent){el.textContent=`Red-team pass failed:\n${err.message||err}`;}}}
async function runReplication(){const cfg=readApiConfig();const cfgError=validateApiConfig(cfg);if(cfgError){showToast(cfgError);return;}const models=(cfg.replicationModels||"").split(",").map(s=>s.trim()).filter(Boolean);if(!models.length){showToast("Add replication models (comma-separated) first.");return;}if(!RUN_STATE?.probeResults?.length){showToast("Run a baseline expedition first.");return;}const el=document.getElementById("replication-modal-content");el.textContent="Running replication...";openModal("replication-modal");const target=RUN_STATE.target;const quality=getQualityProfile(cfg.qualityMode);const baseTermSet=new Set(RUN_STATE.probeResults.flatMap(r=>(r.terms||[]).map(t=>String(t.label||"").trim()).filter(Boolean)));const baseContras=new Set((RUN_STATE.synthResult?.contradictory||[]).map(t=>String(t.label||"").trim()).filter(Boolean));const baseEmerg=new Set((RUN_STATE.synthResult?.emergent||[]).map(t=>String(t.label||"").trim()).filter(Boolean));const results=[];const priorCA=CA_PROBE_OUTPUT;for(const model of models){try{const cfg2={...cfg,researchModel:model};const probeSystemDefault=buildProbeSystemPrompt(cfg2);const probeSystemBundle=resolvePromptBundleWithOverrides("probe_system",{target,cfg:cfg2,quality,defaults:{systemPrompt:probeSystemDefault,userPrompt:""}});const probeResults=await Promise.all(DISCS.map(async(d)=>{if(d.kind==="ca"){const simNorm=await runComputationalIrreducibilityProbe(target,cfg2);return {discId:d.id,summary:simNorm.summary,terms:Array.isArray(simNorm.terms)?simNorm.terms:[]};}const probeDefaults={systemPrompt:probeSystemBundle.systemPrompt||probeSystemDefault,userPrompt:buildProbeUserPrompt(target,d.name,quality,cfg2)};const probeBundle=resolvePromptBundleWithOverrides("probe_user",{discName:d.name,target,cfg:cfg2,quality,defaults:probeDefaults});let norm=await getProbeResultWithRecovery({target,discName:d.name,probeSystem:probeBundle.systemPrompt||probeSystemBundle.systemPrompt||probeSystemDefault,userMsg:probeBundle.userPrompt,cfg:cfg2});norm=await groundProbeTermsWithWolfram(norm,target,d.name,cfg2);return {discId:d.id,summary:norm.summary,terms:Array.isArray(norm.terms)?norm.terms:[]};}));const synthResult=await getSynthesisResultWithRecovery(target,probeResults,quality,cfg2,{contextLabel:`replication_${model}`});const termSet=new Set(probeResults.flatMap(r=>(r.terms||[]).map(t=>String(t.label||"").trim()).filter(Boolean)));const contraSet=new Set((synthResult.contradictory||[]).map(t=>String(t.label||"").trim()).filter(Boolean));const emergSet=new Set((synthResult.emergent||[]).map(t=>String(t.label||"").trim()).filter(Boolean));const overlap=(a,b)=>{const union=new Set([...a,...b]);if(!union.size) return 0;let inter=0;for(const v of a){if(b.has(v)) inter++;}return inter/union.size;};results.push({model,termOverlap:overlap(baseTermSet,termSet),contradictionOverlap:overlap(baseContras,contraSet),emergentOverlap:overlap(baseEmerg,emergSet),synthCounts:{convergent:(synthResult.convergent||[]).length,contradictory:(synthResult.contradictory||[]).length,emergent:(synthResult.emergent||[]).length}});}catch(err){results.push({model,error:err.message||String(err)});} }
  const lines=results.map(r=>r.error?`- ${r.model}: ERROR ${r.error}`:`- ${r.model}: term overlap ${(r.termOverlap*100).toFixed(1)}% | contradiction overlap ${(r.contradictionOverlap*100).toFixed(1)}% | emergent overlap ${(r.emergentOverlap*100).toFixed(1)}%`).join("\n");el.textContent=`Replication summary for ${target}:\n\n${lines}`;LAST_RUN={...(LAST_RUN||{}),replication:results};CA_PROBE_OUTPUT=priorCA;renderCAPanel();}
async function copyCritiqueText(){if(!lastCritiqueText){showToast("No critique text to copy.");return;}try{await navigator.clipboard.writeText(lastCritiqueText);showToast("Critique copied to clipboard.");}catch{showToast("Clipboard copy failed.");}}
async function exportMarkdownReport(){if(!TERMS.length){showToast("No plotted data available yet.");return;}const cfg=readApiConfig();const cfgError=validateApiConfig(cfg);if(cfgError){showToast(cfgError);return;}const target=LAST_RUN?.target||document.getElementById("viz-target-label").textContent||"Topic";const defaultSystemPrompt="You are a research assistant producing Substack-ready Markdown with citations and methods. Return Markdown only.";const byType={convergent:TERMS.filter(t=>t.type==="convergent"),contradictory:TERMS.filter(t=>t.type==="contradictory"),emergent:TERMS.filter(t=>t.type==="emergent")};const citationLines=CITATIONS.map((c,i)=>`${i+1}. ${c.title||c.publisher||"Source"} (${c.date||"n.d."}) ${c.url}`).join("\n");const method=`Model: ${cfg.researchModel}\nEmbeddings: ${cfg.embeddingModel}\nQuality: ${cfg.qualityMode}\nWeb search: ${cfg.webSearch?"on":"off"}\nSource policy: ${cfg.sourcePolicy||"none"}`;const userPromptBase=`Topic: ${target}\n\nConvergent terms:\n${byType.convergent.map(t=>t.label).join(", ")}\n\nContradictory terms:\n${byType.contradictory.map(t=>t.label).join(", ")}\n\nEmergent terms:\n${byType.emergent.map(t=>t.label).join(", ")}\n\nClaims ledger:\n${lastClaimsText||"(not generated)"}\n\nCitations:\n${citationLines||"(none)"}\n\nMethods:\n${method}\n\nReturn Markdown with:\n- Title + hook\n- Thesis\n- Map summary (convergent / contradictory / emergent)\n- Claims ledger table (if available)\n- Footnoted citations list\n- Methods appendix`;const defaultUserPrompt=appendPromptMadLibBlock(userPromptBase,cfg,{includeArtifact:true});const promptBundle=resolvePromptBundleWithOverrides("artifact_markdown",{target,cfg,quality:getQualityProfile(cfg.qualityMode),defaults:{systemPrompt:defaultSystemPrompt,userPrompt:defaultUserPrompt}});try{const text=await callLLM(promptBundle.systemPrompt,promptBundle.userPrompt,cfg);lastMarkdownText=text;LAST_RUN={...(LAST_RUN||{}),markdown:text};downloadTextFile(`ruliad-${target.toLowerCase().replace(/[^a-z0-9]+/g,"-")||"report"}.md`,text);showToast("Markdown exported.");}catch(err){console.error("Markdown export failed:",err);showToast(`Markdown export failed: ${err.message||err}`);}}
async function exportFigure(){if(!plotInited){showToast("No plot available.");return;}try{const dataUrl=await Plotly.toImage("plot",{format:"png",width:1600,height:1000});const a=document.createElement("a");a.href=dataUrl;a.download=`ruliad-figure-${(LAST_RUN?.target||"plot").toLowerCase().replace(/[^a-z0-9]+/g,"-")}.png`;document.body.appendChild(a);a.click();a.remove();showToast("Figure exported.");}catch(err){console.error("Figure export failed:",err);showToast("Figure export failed.");}}
function downloadTextFile(filename,text){const blob=new Blob([text],{type:"text/plain"});const url=URL.createObjectURL(blob);const a=document.createElement("a");a.href=url;a.download=filename;document.body.appendChild(a);a.click();a.remove();setTimeout(()=>URL.revokeObjectURL(url),250);}
async function rerunSynthesis(){if(!RUN_STATE?.probeResults?.length){showToast("No probe data to re-synthesize.");return;}const cfg=readApiConfig();const cfgError=validateApiConfig(cfg);if(cfgError){showToast(cfgError);return;}const quality=getQualityProfile(cfg.qualityMode);const synthBar=document.getElementById("synth-bar");synthBar.className="synth-bar running";synthBar.textContent="SYNTHESIS - re-running...";try{const synthResult=await getSynthesisResultWithRecovery(RUN_STATE.target,RUN_STATE.probeResults,quality,cfg,{contextLabel:"rerun"});RUN_STATE.synthResult=synthResult;buildTerms(RUN_STATE.probeResults,synthResult);collectCitations();await assignSemanticPositions(RUN_STATE.target,cfg,msg=>{synthBar.textContent=msg;});synthBar.className="synth-bar done";synthBar.textContent=`SYNTHESIS COMPLETE - ${synthResult.convergent?.length||0} convergent | ${synthResult.contradictory?.length||0} contradictions | ${synthResult.emergent?.length||0} emergent`;LAST_RUN=buildRunSnapshot(RUN_STATE.target,RUN_STATE.probeResults,synthResult,cfg);syncArtifactStoreFromRun();markArtifactsStale(["claims","outline","deep_report","red_team","replication","markdown"]);renderPlot();buildStats();}catch(err){console.error("Rerun synthesis failed:",err);synthBar.className="synth-bar error";synthBar.textContent="SYNTHESIS ERROR - see console";showToast("Synthesis rerun failed.");}}
async function rerunProbe(discId){
  if(RUN_STATE?.probeResults?.length===0){showToast("No probe data to rerun.");return;}
  const cfg=readApiConfig();
  const cfgError=validateApiConfig(cfg);
  if(cfgError){showToast(cfgError);return;}
  const target=RUN_STATE.target;
  const quality=getQualityProfile(cfg.qualityMode);
  const disc=DISCS.find(d=>d.id===discId);
  if(!disc){showToast("Probe not found.");return;}
  const probeSystemDefault=buildProbeSystemPrompt(cfg);
  const probeSystemBundle=resolvePromptBundleWithOverrides("probe_system",{target,cfg,quality,defaults:{systemPrompt:probeSystemDefault,userPrompt:""}});
  try{
    showToast(`Re-running ${disc.name}...`);
    let updated=null;
    if(disc.kind==="ca"){
      const simNorm=await runComputationalIrreducibilityProbe(target,cfg);
      updated={discId,summary:simNorm.summary,terms:Array.isArray(simNorm.terms)?simNorm.terms:[],claims_or_findings:simNorm.claims_or_findings,citations:simNorm.citations,confidence_notes:simNorm.confidence_notes};
      RUN_STATE.caProbe=CA_PROBE_OUTPUT;
    }else{
      const probeDefaults={systemPrompt:probeSystemBundle.systemPrompt||probeSystemDefault,userPrompt:buildProbeUserPrompt(target,disc.name,quality,cfg)};
      const probeBundle=resolvePromptBundleWithOverrides("probe_user",{discName:disc.name,target,cfg,quality,defaults:probeDefaults});
      let norm=await getProbeResultWithRecovery({target,discName:disc.name,probeSystem:probeBundle.systemPrompt||probeSystemBundle.systemPrompt||probeSystemDefault,userMsg:probeBundle.userPrompt,cfg});
      norm=await groundProbeTermsWithWolfram(norm,target,disc.name,cfg);
      updated={discId,summary:norm.summary,terms:Array.isArray(norm.terms)?norm.terms:[],claims_or_findings:norm.claims_or_findings,citations:norm.citations,confidence_notes:norm.confidence_notes};
    }
    const idx=RUN_STATE.probeResults.findIndex(r=>r.discId===discId);
    if(idx>=0){RUN_STATE.probeResults[idx]=updated;}else{RUN_STATE.probeResults.push(updated);}
    buildTerms(RUN_STATE.probeResults,RUN_STATE.synthResult||{convergent:[],contradictory:[],emergent:[]});
    collectCitations();
    await assignSemanticPositions(target,cfg,()=>{});
    LAST_RUN=buildRunSnapshot(target,RUN_STATE.probeResults,RUN_STATE.synthResult||{convergent:[],contradictory:[],emergent:[]},cfg);
    syncArtifactStoreFromRun();
    markArtifactsStale(["claims","outline","deep_report","red_team","replication","markdown"]);
    renderPlot();
    buildStats();
    renderCAPanel();
    showToast(`Probe ${disc.name} updated.`);
  }catch(err){
    console.error("Probe rerun failed:",err);
    showToast("Probe rerun failed.");
  }
}
function exportRunToFile(){if(!LAST_RUN||!Array.isArray(TERMS)||!TERMS.length){showToast("No run to export yet.");return;}const cfg=RUN_STATE?.config||readApiConfig();const payload={...buildRunSnapshot(LAST_RUN.target||RUN_STATE?.target||"run",RUN_STATE?.probeResults||LAST_RUN.probeResults||[],RUN_STATE?.synthResult||LAST_RUN.synthResult||{convergent:[],contradictory:[],emergent:[]},cfg),exportedAt:new Date().toISOString()};const safeTarget=(payload.target||"run").toLowerCase().replace(/[^a-z0-9]+/g,"-").replace(/^-+|-+$/g,"")||"run";const stamp=new Date().toISOString().replace(/[:.]/g,"-");const blob=new Blob([JSON.stringify(payload,null,2)],{type:"application/json"});const url=URL.createObjectURL(blob);const a=document.createElement("a");a.href=url;a.download=`ruliad-run-${safeTarget}-${stamp}.json`;document.body.appendChild(a);a.click();a.remove();setTimeout(()=>URL.revokeObjectURL(url),250);}
async function importRunFromFile(e){const input=e?.target;const file=input?.files?.[0];if(!file) return;try{const text=await file.text();const data=JSON.parse(text);hydrateRunFromImport(data);showToast("Run imported.");}catch(err){console.error("Import failed:",err);showToast(`Import failed: ${err.message||err}`);}finally{if(input) input.value="";}}
function hydrateRunFromImport(data){
  if(!data||typeof data!=="object") throw new Error("Invalid run file.");
  const target=String(data.target||"").trim();
  const importedDiscs=Array.isArray(data.discs)?data.discs:[];
  const importedTerms=Array.isArray(data.terms)?data.terms:[];
  if(!target) throw new Error("Missing target.");
  if(importedDiscs.length<2) throw new Error("Run file must include at least 2 probes.");
  DISCS=importedDiscs.map((disc,i)=>({id:i,name:String(disc.name||`Probe ${i+1}`),abbr:String(disc.abbr||makeAbbr(String(disc.name||`Probe ${i+1}`))),col:disc.col||COLORS[i%COLORS.length],kind:(disc.kind==="ca"?"ca":"llm")}));
  if(importedTerms.length){
    TERMS=importedTerms.map(term=>{
      const label=String(term.label||"").trim();
      const source=String(term.description_source||"").trim().toLowerCase()||"llm";
      const descriptions=normalizeTermDescriptions(term.descriptions,{fallbackDescription:String(term.description||""),fallbackSource:source,label});
      return {
        label,
        descriptions,
        description:String(descriptions.displayDescription||term.description||"").trim(),
        centrality:clamp01(Number(term.centrality||0.5)),
        slices:Array.isArray(term.slices)?term.slices.filter(i=>Number.isInteger(i)&&i>=0&&i<DISCS.length):[],
        type:["unique","convergent","contradictory","emergent"].includes(term.type)?term.type:"unique",
        pos:Array.isArray(term.pos)&&term.pos.length===3?[Number(term.pos[0]||0),Number(term.pos[1]||0),Number(term.pos[2]||0)]:[0,0,0],
        citations:Array.isArray(term.citations)?term.citations:[],
        aliases:Array.isArray(term.aliases)?term.aliases.map(x=>String(x||"").trim()).filter(Boolean):[],
        description_source:inferDescriptionSourceFromLayers(descriptions,source),
        description_provenance:mergeDescriptionProvenance(term.description_provenance,[]),
        grounding:normalizeGroundingBlock(term.grounding,{defaultStatus:"not_attempted"}),
        relevance_score:Number.isFinite(Number(term.relevance_score))?clamp01(Number(term.relevance_score)):Number.isFinite(Number(term.relevanceScore))?clamp01(Number(term.relevanceScore)):null,
        evidence_support_score:Number.isFinite(Number(term.evidence_support_score))?clamp01(Number(term.evidence_support_score)):Number.isFinite(Number(term.evidenceSupportScore))?clamp01(Number(term.evidenceSupportScore)):null,
        wa_eligibility:normalizeGroundingEligibility(term.wa_eligibility||term.waEligibility||term?.grounding?.groundingEligibility||"eligible"),
        wa_grounding_status:String(term.wa_grounding_status||term.waGroundingStatus||"").trim().toLowerCase(),
        display_description_source:String(term.display_description_source||term.displayDescriptionSource||source).trim().toLowerCase()||source
      };
    }).filter(t=>t.label);
  }else{
    const probeResults=Array.isArray(data.probeResults)?data.probeResults:[];
    const synthResult=data.synthResult&&typeof data.synthResult==="object"?data.synthResult:{convergent:[],contradictory:[],emergent:[]};
    buildTerms(probeResults,synthResult);
    applyFallbackPositions();
  }
  DISC_SIM_MATRIX=data?.embeddingDiagnostics?.similarityMatrix&&typeof data.embeddingDiagnostics.similarityMatrix==="object"?data.embeddingDiagnostics.similarityMatrix:null;
  PROJECTION_STABILITY=data?.embeddingDiagnostics?.projectionStability&&typeof data.embeddingDiagnostics.projectionStability==="object"?data.embeddingDiagnostics.projectionStability:null;
  CA_PROBE_OUTPUT=data?.caProbe&&typeof data.caProbe==="object"?data.caProbe:null;
  WOLFRAM_GROUNDING_DIAGNOSTICS=Array.isArray(data.wolframGroundingDiagnostics)?data.wolframGroundingDiagnostics.map(item=>({runId:item?.runId||null,timestamp:String(item?.timestamp||""),target:String(item?.target||""),discName:String(item?.discName||""),termLabel:String(item?.termLabel||""),attemptRank:Number.isFinite(Number(item?.attemptRank))?Number(item.attemptRank):null,attemptStrategy:String(item?.attemptStrategy||""),resolutionLabel:String(item?.resolutionLabel||""),stopReason:String(item?.stopReason||""),query:String(item?.query||""),snippet:String(item?.snippet||""),accepted:Boolean(item?.accepted),score:Number.isFinite(Number(item?.score))?Number(item.score):null,snippetQualityScore:Number.isFinite(Number(item?.snippetQualityScore))?Number(item.snippetQualityScore):Number.isFinite(Number(item?.snippet_quality_score))?Number(item.snippet_quality_score):null,semanticAlignmentScore:Number.isFinite(Number(item?.semanticAlignmentScore))?Number(item.semanticAlignmentScore):Number.isFinite(Number(item?.semantic_alignment_score))?Number(item.semantic_alignment_score):null,confidence:String(item?.confidence||""),reasons:Array.isArray(item?.reasons)?item.reasons.map(r=>String(r||"")).filter(Boolean):[],inputInterpretation:String(item?.inputInterpretation||""),bestDefinition:String(item?.bestDefinition||""),altFacts:Array.isArray(item?.altFacts)?item.altFacts.map(x=>String(x||"")).filter(Boolean):[],assumptions:Array.isArray(item?.assumptions)?item.assumptions.map(x=>normalizeWolframAssumptionText(x,{})).filter(Boolean):[],didYouMeans:Array.isArray(item?.didYouMeans)?item.didYouMeans.map(x=>String(x||"")).filter(Boolean):[],warnings:Array.isArray(item?.warnings)?item.warnings.map(x=>String(x||"")).filter(Boolean):[],chosenInterpretation:String(item?.chosenInterpretation||""),status:String(item?.status||""),error:String(item?.error||""),mode:String(item?.mode||""),durationMs:Number.isFinite(Number(item?.durationMs))?Number(item.durationMs):null,statusCode:Number.isFinite(Number(item?.statusCode))?Number(item.statusCode):null,cacheStatus:normalizeWolframCacheStatus(item?.cacheStatus),chosenPod:String(item?.chosenPod||""),appliedToDescription:typeof item?.appliedToDescription==="boolean"?item.appliedToDescription:null})):[];
  AMBIGUITY_QUEUE=Array.isArray(data?.ambiguityQueue)?data.ambiguityQueue.map(normalizeAmbiguityQueueItem).filter(item=>item?.id):[];
  rebuildAmbiguityQueueFromDiagnostics(AMBIGUITY_QUEUE);
  CITATIONS=Array.isArray(data.citations)?data.citations.map((c,i)=>({id:Number.isInteger(c.id)?c.id:i,source_type:normalizeSourceType(c.source_type,c.publisher),url:c.url||"",title:c.title||"",publisher:c.publisher||"",date:c.date||"",quote_or_snippet:c.quote_or_snippet||"",relevance:c.relevance||"",supporting_terms:Array.isArray(c.supporting_terms)?c.supporting_terms.map(t=>String(t||"").trim()).filter(Boolean):[],supporting_terms_raw:Array.isArray(c.supporting_terms_raw)?c.supporting_terms_raw.map(t=>String(t||"").trim()).filter(Boolean):Array.isArray(c.supporting_terms)?c.supporting_terms.map(t=>String(t||"").trim()).filter(Boolean):[],supporting_term_mappings:Array.isArray(c.supporting_term_mappings)?c.supporting_term_mappings.map(normalizeAliasMappingEntry).filter(Boolean):[],unmapped_supporting_terms:Array.isArray(c.unmapped_supporting_terms)?c.unmapped_supporting_terms.map(t=>String(t||"").trim()).filter(Boolean):[],probeId:c.probeId,grounding_status:c.grounding_status||"",grounding_confidence:c.grounding_confidence||"",grounding_score:Number.isFinite(Number(c.grounding_score))?Number(c.grounding_score):null,grounding_reasons:Array.isArray(c.grounding_reasons)?c.grounding_reasons:[],wolfram_input_interpretation:c.wolfram_input_interpretation||"",wolfram_best_definition:c.wolfram_best_definition||"",wolfram_alt_facts:Array.isArray(c.wolfram_alt_facts)?c.wolfram_alt_facts:[],wolfram_assumptions:Array.isArray(c.wolfram_assumptions)?c.wolfram_assumptions.map(x=>normalizeWolframAssumptionText(x,{})).filter(Boolean):[],wolfram_did_you_means:Array.isArray(c.wolfram_did_you_means)?c.wolfram_did_you_means:[],wolfram_warnings:Array.isArray(c.wolfram_warnings)?c.wolfram_warnings:[]})):[];
  CITATION_UNMAPPED_SUPPORTING_TERMS=dedupeCasefold(CITATIONS.flatMap(c=>Array.isArray(c.unmapped_supporting_terms)?c.unmapped_supporting_terms:[]),220);
  refreshTermSignalFields(TERMS);
  CALL_LOGS=Array.isArray(data.auditTrail)?data.auditTrail:[];
  CURRENT_RUN_ID=data.runId||null;
  RUN_STATE={runId:CURRENT_RUN_ID,target,config:data.config||{},probeResults:Array.isArray(data.probeResults)?data.probeResults:[],synthResult:data.synthResult&&typeof data.synthResult==="object"?data.synthResult:{convergent:[],contradictory:[],emergent:[]},generatedAt:data.generatedAt||new Date().toISOString(),caProbe:CA_PROBE_OUTPUT,wolframGroundingDiagnostics:[...WOLFRAM_GROUNDING_DIAGNOSTICS],ambiguityQueue:[...AMBIGUITY_QUEUE]};
  LAST_RUN={schemaVersion:data.schemaVersion||6,runId:data.runId||CURRENT_RUN_ID,target,generatedAt:data.generatedAt||new Date().toISOString(),probeResults:Array.isArray(data.probeResults)?data.probeResults:[],synthResult:data.synthResult&&typeof data.synthResult==="object"?data.synthResult:{convergent:[],contradictory:[],emergent:[]},config:data.config&&typeof data.config==="object"?data.config:{},sourcePolicy:data.sourcePolicy||"",groundingStats:data.groundingStats&&typeof data.groundingStats==="object"?data.groundingStats:computeGroundingStats(TERMS),sourceTypeBreakdown:data.sourceTypeBreakdown&&typeof data.sourceTypeBreakdown==="object"?data.sourceTypeBreakdown:computeSourceTypeBreakdown(CITATIONS),warnings:Array.isArray(data.warnings)?data.warnings.map(w=>String(w||"").trim()).filter(Boolean):buildGroundingHealthWarnings(data.groundingStats&&typeof data.groundingStats==="object"?data.groundingStats:computeGroundingStats(TERMS),data.sourceTypeBreakdown&&typeof data.sourceTypeBreakdown==="object"?data.sourceTypeBreakdown:computeSourceTypeBreakdown(CITATIONS)),report:data.report||"",discs:DISCS.map(d=>({id:d.id,name:d.name,abbr:d.abbr,col:d.col,kind:d.kind||"llm"})),terms:TERMS.map(serializeTermForRun),citations:[...CITATIONS],auditTrail:[...CALL_LOGS],embeddingDiagnostics:{similarityMatrix:structuredCloneSafe(DISC_SIM_MATRIX),projectionStability:structuredCloneSafe(PROJECTION_STABILITY)},wolframGroundingDiagnostics:structuredCloneSafe(WOLFRAM_GROUNDING_DIAGNOSTICS),ambiguityQueue:structuredCloneSafe(AMBIGUITY_QUEUE),claimsLedger:data.claimsLedger||[],redTeamCritique:data.redTeamCritique||"",replication:data.replication||[],outline:data.outline||"",markdown:data.markdown||"",caProbe:CA_PROBE_OUTPUT};
  document.getElementById("target-input").value=target;
  const llmDiscs=DISCS.filter(d=>d.kind!=="ca");
  renderDisciplineInputs(Math.max(2,llmDiscs.length),llmDiscs.map(d=>d.name));
  if(data?.config?.qualityMode){const qm=document.getElementById("quality-mode-select");if(qm) qm.value=data.config.qualityMode;}
  if(data?.config?.researchModel){setSelectValuePreserveOption("research-model-input",data.config.researchModel);}
  if(data?.config?.embeddingModel){setSelectValuePreserveOption("embedding-model-input",data.config.embeddingModel);}
  if(typeof data?.config?.webSearch==="boolean"){const ws=document.getElementById("web-search-check");if(ws) ws.checked=data.config.webSearch;}
  if(data?.config?.sourcePolicy){const sp=document.getElementById("source-policy-input");if(sp) sp.value=data.config.sourcePolicy;}
  if(typeof data?.config?.wolframEntityGrounding==="boolean"){const wg=document.getElementById("wolfram-grounding-check");if(wg) wg.checked=data.config.wolframEntityGrounding;}
  if(data?.config?.groundingMode){const gm=document.getElementById("grounding-mode-select");if(gm) gm.value=normalizeGroundingAggressiveness(data.config.groundingMode);}
  if(data?.config?.groundingMinSnippetScore!==undefined&&data?.config?.groundingMinSnippetScore!==null){const gs=document.getElementById("grounding-min-score-input");if(gs) gs.value=String(clampGroundingSnippetScore(data.config.groundingMinSnippetScore,0.58));}
  if(data?.config?.groundingMinAlignmentScore!==undefined&&data?.config?.groundingMinAlignmentScore!==null){const ga=document.getElementById("grounding-min-alignment-score-input");if(ga) ga.value=String(clampGroundingSnippetScore(data.config.groundingMinAlignmentScore,0.55));}
  if(typeof data?.config?.groundingAnnotateOnly==="boolean"){const ga=document.getElementById("grounding-annotate-only-check");if(ga) ga.checked=Boolean(data.config.groundingAnnotateOnly);}
  if(typeof data?.config?.allowGroundingCategoryMismatch==="boolean"){const gc=document.getElementById("grounding-allow-category-mismatch-check");if(gc) gc.checked=Boolean(data.config.allowGroundingCategoryMismatch);}
  if(typeof data?.config?.enableComputationalIrreducibility==="boolean"){const cp=document.getElementById("ca-probe-check");if(cp) cp.checked=data.config.enableComputationalIrreducibility;}else{const cp=document.getElementById("ca-probe-check");if(cp) cp.checked=DISCS.some(d=>d.kind==="ca");}
  if(data?.config?.wolframAppId){const wa=document.getElementById("wolfram-appid-input");if(wa) wa.value=data.config.wolframAppId;}
  if(data?.config?.caRule!==undefined){const cr=document.getElementById("ca-rule-input");if(cr) cr.value=String(clampInt(data.config.caRule,0,255));}
  if(data?.config?.caSteps!==undefined){const cs=document.getElementById("ca-steps-input");if(cs) cs.value=String(clampInt(data.config.caSteps,16,240));}
  if(data?.config?.caWidth!==undefined){const cw=document.getElementById("ca-width-input");if(cw) cw.value=String(clampInt(data.config.caWidth,31,401));}
  if(typeof data?.config?.redTeam==="boolean"){const rt=document.getElementById("redteam-check");if(rt) rt.checked=data.config.redTeam;}
  if(data?.config?.replicationModels){const rm=document.getElementById("replication-models-input");if(rm) rm.value=data.config.replicationModels;}
  if(data?.config?.replicationRuns){const rr=document.getElementById("replication-runs-input");if(rr) rr.value=String(clampInt(data.config.replicationRuns,1,5));}
  if(data?.config?.replicationStrategy){const rs=document.getElementById("replication-strategy-select");if(rs) rs.value=data.config.replicationStrategy;}
  PROMPT_TEMPLATE_OVERRIDES=data?.config?.promptTemplateOverrides&&typeof data.config.promptTemplateOverrides==="object"?structuredCloneSafe(data.config.promptTemplateOverrides):{};
  if(data?.config?.promptIntent!==undefined){const el=document.getElementById("prompt-intent-input");if(el) el.value=String(data.config.promptIntent||"");}
  if(data?.config?.promptLensEmphasis!==undefined){const el=document.getElementById("prompt-lens-emphasis-input");if(el) el.value=String(data.config.promptLensEmphasis||"");}
  if(data?.config?.promptHardConstraints!==undefined){const el=document.getElementById("prompt-hard-constraints-input");if(el) el.value=String(data.config.promptHardConstraints||"");}
  if(data?.config?.promptOutputStyle!==undefined){const el=document.getElementById("prompt-output-style-input");if(el) el.value=String(data.config.promptOutputStyle||"");}
  if(data?.config?.promptArtifactFocus!==undefined){const el=document.getElementById("prompt-artifact-focus-input");if(el) el.value=String(data.config.promptArtifactFocus||"");}
  if(data?.artifacts&&typeof data.artifacts==="object"){for(const key of Object.keys(ARTIFACT_DEFS)){if(data.artifacts[key]){ARTIFACT_STORE[key]={...ARTIFACT_STORE[key],...data.artifacts[key]};}}}
  if(CITATIONS.length&&!TERMS.some(t=>t.citations&&t.citations.length)) collectCitations();
  syncArtifactStoreFromRun();
  syncPromptPreviewDiscOptions();
  refreshPromptPreview();
  showViz(target);
  switchMainTab("plot",{silent:true});
}
function setSelectValuePreserveOption(selectId,value){const el=document.getElementById(selectId);const val=String(value||"").trim();if(!el||!val) return;if(el.tagName!=="SELECT"){el.value=val;return;}if(![...el.options].some(opt=>String(opt.value||"")===val)){const opt=document.createElement("option");opt.value=val;opt.textContent=`${val} (imported)`;el.appendChild(opt);}el.value=val;}
function getPromptPreviewDisciplineNames(){
  const fromInputs=Array.from(document.querySelectorAll(".disc-input")).map(el=>String(el?.value||"").trim()).filter(Boolean);
  if(fromInputs.length) return fromInputs;
  if(Array.isArray(DISCS)&&DISCS.length) return DISCS.map(d=>String(d?.name||"").trim()).filter(Boolean);
  return [...DEFAULT_DISCS];
}
function syncPromptPreviewDiscOptions(){
  const sel=document.getElementById("prompt-preview-disc-select");
  if(!sel) return;
  const names=getPromptPreviewDisciplineNames();
  const current=String(sel.value||"").trim();
  sel.innerHTML="";
  for(let i=0;i<names.length;i++){
    const option=document.createElement("option");
    option.value=names[i];
    option.textContent=`${i+1}. ${names[i]}`;
    sel.appendChild(option);
  }
  if(current&&names.includes(current)) sel.value=current;
  else if(names.length) sel.value=names[0];
}
function getPromptKindMeta(kind){
  const normalized=normalizePromptOverrideKind(kind);
  return PROMPT_KIND_META[normalized]||{label:normalized,usage:"Custom prompt template.",scope:"global"};
}
function summarizePromptOverrides(maxItems=10){
  const rows=Object.entries(PROMPT_TEMPLATE_OVERRIDES||{}).map(([key,entry])=>{
    const kind=normalizePromptOverrideKind(entry?.kind||String(key).split("::")[0]||"probe_user");
    const scope=kind==="probe_user"&&String(entry?.discName||"").trim()?"lens":"global";
    const discName=String(entry?.discName||"").trim();
    const updatedAt=String(entry?.updatedAt||"").trim();
    return {key,kind,scope,discName,updatedAt};
  }).sort((a,b)=>String(b.updatedAt||"").localeCompare(String(a.updatedAt||"")));
  const total=rows.length;
  const lensScoped=rows.filter(row=>row.scope==="lens").length;
  const global=total-lensScoped;
  return {total,lensScoped,global,rows:rows.slice(0,Math.max(0,maxItems))};
}
function formatPromptOverrideDisplay(row){
  const kindMeta=getPromptKindMeta(row?.kind||"probe_user");
  if(row?.scope==="lens"){
    const disc=String(row?.discName||"").trim()||"(unspecified lens)";
    return `${kindMeta.label} @ ${disc}`;
  }
  return `${kindMeta.label} (global)`;
}
function updatePromptKindHelp(kind,discName){
  const el=document.getElementById("prompt-preview-kind-help");
  if(!el) return;
  const meta=getPromptKindMeta(kind);
  const scopeLine=meta.scope==="lens"?"Override scope: lens-specific.":"Override scope: global.";
  const lensLine=meta.scope==="lens"?`Active preview lens: ${discName||"(select a lens)"}.`:"Lens selector is inactive for this prompt kind.";
  el.textContent=`${meta.usage} ${scopeLine} ${lensLine}`;
}
function updatePromptOverrideSummary(kind,discName,bundle){
  const el=document.getElementById("prompt-override-summary");
  if(!el) return;
  const summary=summarizePromptOverrides(6);
  const currentKey=buildPromptOverrideKey(kind,kind==="probe_user"?discName:"");
  const currentOverride=getPromptOverride(kind,kind==="probe_user"?discName:"");
  const currentState=currentOverride?.entry?`Current selection uses custom override (${currentOverride.key}).`:"Current selection uses default template.";
  const chips=(summary.rows||[]).map(row=>{
    const label=formatPromptOverrideDisplay(row);
    const isCurrent=row.key===currentKey;
    return `<span class="prompt-override-chip"${isCurrent?` style="border-color:var(--accent);color:var(--accent)"`:""}>${escapeHtml(label)}</span>`;
  }).join("");
  const countsLine=`Active overrides: ${summary.total} total (${summary.global} global, ${summary.lensScoped} lens-scoped).`;
  el.innerHTML=`<div>${escapeHtml(currentState)}</div><div>${escapeHtml(bundle?.status||"")}</div><div>${escapeHtml(countsLine)}</div>${chips?`<div class="prompt-override-chips">${chips}</div>`:""}`;
}
function collectRunReadinessChecks(){
  const target=String(document.getElementById("target-input")?.value||"").trim();
  const cfg=readApiConfig();
  const mode=normalizeMode(cfg);
  const rawLenses=Array.from(document.querySelectorAll(".disc-input")).map(el=>String(el?.value||"").trim());
  const lenses=rawLenses.filter(Boolean);
  const byCanon=new Map();
  for(const name of lenses){
    const key=toCanonicalKey(name)||name.toLowerCase();
    byCanon.set(key,(byCanon.get(key)||0)+1);
  }
  const duplicateLenses=[...byCanon.entries()].filter(([,count])=>count>1).map(([key])=>key);
  const overrideSummary=summarizePromptOverrides(99);
  const checks=[
    {label:"Focus concept",ok:Boolean(target),blocking:true,detail:Boolean(target)?`Configured: "${target}".`:"Enter a focus concept."},
    {label:"Probe lenses",ok:lenses.length>=2,blocking:true,detail:lenses.length>=2?`${lenses.length} lenses configured.`:`Need at least 2 non-empty lenses (current: ${lenses.length}).`},
    {label:"Distinct lens names",ok:duplicateLenses.length===0,blocking:false,detail:duplicateLenses.length?`Duplicate labels detected (${duplicateLenses.length}).`:"No duplicate lens labels detected."},
    {label:"Research model",ok:Boolean(cfg.researchModel),blocking:true,detail:cfg.researchModel?cfg.researchModel:"Select a research model."},
    {label:"Embedding model",ok:Boolean(cfg.embeddingModel),blocking:true,detail:cfg.embeddingModel?cfg.embeddingModel:"Select an embedding model."},
    {label:"Runtime credentials",ok:mode==="proxy"||Boolean(cfg.apiKey),blocking:mode==="direct",detail:mode==="proxy"?"Proxy mode selected (credentials handled by backend).":cfg.apiKey?"Direct mode key set.":"Direct mode requires an OpenRouter key."},
    {label:"Wolfram prerequisites",ok:!cfg.wolframEntityGrounding||(mode==="proxy"&&Boolean(cfg.wolframAppId)),blocking:Boolean(cfg.wolframEntityGrounding),detail:!cfg.wolframEntityGrounding?"Wolfram grounding disabled.":(mode==="proxy"&&cfg.wolframAppId)?"Proxy mode + AppID configured for Wolfram grounding.":"Enable proxy mode and set a Wolfram AppID."},
    {label:"Prompt overrides",ok:true,blocking:false,detail:`${overrideSummary.total} active override(s) (${overrideSummary.global} global, ${overrideSummary.lensScoped} lens-scoped).`}
  ];
  const blockingCount=checks.filter(item=>item.blocking&&!item.ok).length;
  const warningCount=checks.filter(item=>!item.blocking&&!item.ok).length;
  return {checks,blockingCount,warningCount};
}
function updateRunReadinessSummary(){
  const statusEl=document.getElementById("run-readiness-status");
  const listEl=document.getElementById("run-readiness-list");
  if(!statusEl||!listEl) return;
  const readiness=collectRunReadinessChecks();
  if(readiness.blockingCount===0){
    const warnSuffix=readiness.warningCount>0?` (${readiness.warningCount} warning${readiness.warningCount===1?"":"s"})`:"";
    statusEl.textContent=`Ready to run${warnSuffix}.`;
    statusEl.classList.add("ready");
    statusEl.classList.remove("blocked");
  }else{
    statusEl.textContent=`Not ready: ${readiness.blockingCount} blocking item${readiness.blockingCount===1?"":"s"}.`;
    statusEl.classList.add("blocked");
    statusEl.classList.remove("ready");
  }
  listEl.innerHTML=readiness.checks.map(item=>{
    const cls=item.ok?"ready":item.blocking?"blocked":"warn";
    const marker=item.ok?"OK":item.blocking?"BLOCK":"WARN";
    return `<li class="${cls}"><b>${marker} - ${escapeHtml(item.label)}</b>: ${escapeHtml(item.detail||"")}</li>`;
  }).join("");
}
function normalizePromptOverrideKind(kind){const raw=String(kind||"").trim();return PROMPT_OVERRIDE_KINDS.includes(raw)?raw:"probe_user";}
function normalizePromptOverrideDisciplineKey(discName){return String(discName||"").trim().toLowerCase().replace(/\s+/g," ");}
function buildPromptOverrideKey(kind,discName=""){const normalizedKind=normalizePromptOverrideKind(kind);if(normalizedKind!=="probe_user") return `${normalizedKind}::global`;const normalizedDisc=normalizePromptOverrideDisciplineKey(discName);return normalizedDisc?`${normalizedKind}::disc:${normalizedDisc}`:`${normalizedKind}::global`;}
function getPromptOverride(kind,discName=""){const normalizedKind=normalizePromptOverrideKind(kind);if(normalizedKind==="probe_user"){const scopedKey=buildPromptOverrideKey(normalizedKind,discName);if(PROMPT_TEMPLATE_OVERRIDES[scopedKey]) return {entry:PROMPT_TEMPLATE_OVERRIDES[scopedKey],key:scopedKey,scoped:true};const globalKey=buildPromptOverrideKey(normalizedKind,"");if(PROMPT_TEMPLATE_OVERRIDES[globalKey]) return {entry:PROMPT_TEMPLATE_OVERRIDES[globalKey],key:globalKey,scoped:false};return null;}const key=buildPromptOverrideKey(normalizedKind,"");if(!PROMPT_TEMPLATE_OVERRIDES[key]) return null;return {entry:PROMPT_TEMPLATE_OVERRIDES[key],key,scoped:false};}
function setPromptOverride(kind,discName,systemPrompt,userPrompt){const normalizedKind=normalizePromptOverrideKind(kind);const key=buildPromptOverrideKey(normalizedKind,discName);PROMPT_TEMPLATE_OVERRIDES[key]={kind:normalizedKind,discName:normalizedKind==="probe_user"?String(discName||"").trim():"",systemPrompt:String(systemPrompt||""),userPrompt:String(userPrompt||""),updatedAt:new Date().toISOString()};}
function clearPromptOverride(kind,discName){const key=buildPromptOverrideKey(kind,discName);delete PROMPT_TEMPLATE_OVERRIDES[key];}
function getPromptTemplateVars({target="",discName="",quality=null,cfg={},kind=""}={}){const q=quality||getQualityProfile(cfg?.qualityMode);return {target:String(target||""),discipline:String(discName||""),quality_mode:String(q?.id||cfg?.qualityMode||"balanced"),probe_term_min:String(q?.probeTermMin??""),probe_term_max:String(q?.probeTermMax??""),synth_convergent:String(q?.synthConvergent??""),synth_contradictory:String(q?.synthContradictory??""),synth_emergent:String(q?.synthEmergent??""),source_policy:String(cfg?.sourcePolicy||""),kind:String(kind||"")};}
function interpolatePromptTemplate(text,vars){const src=String(text||"");return src.replace(/\{\{\s*([a-z0-9_]+)\s*\}\}/gi,(_,key)=>Object.prototype.hasOwnProperty.call(vars,key)?String(vars[key]??""):"");}
function resolvePromptBundleWithOverrides(kind,{discName="",target="",quality=null,cfg={},defaults={systemPrompt:"",userPrompt:""}}={}){const normalizedKind=normalizePromptOverrideKind(kind);const vars=getPromptTemplateVars({target,discName,quality,cfg,kind:normalizedKind});let systemPrompt=String(defaults.systemPrompt||"");let userPrompt=String(defaults.userPrompt||"");let status="Using default prompt template";const scoped=getPromptOverride(normalizedKind,discName);if(scoped&&scoped.entry){systemPrompt=interpolatePromptTemplate(String(scoped.entry.systemPrompt||systemPrompt),vars);userPrompt=interpolatePromptTemplate(String(scoped.entry.userPrompt||userPrompt),vars);status=`Using custom override (${scoped.key})`;return {systemPrompt,userPrompt,status,isOverride:true};}if(normalizedKind==="probe_user"){const probeSystemOverride=getPromptOverride("probe_system","");if(probeSystemOverride?.entry){systemPrompt=interpolatePromptTemplate(String(probeSystemOverride.entry.systemPrompt||systemPrompt),vars);status="Using probe_system custom override";return {systemPrompt,userPrompt,status,isOverride:true};}}return {systemPrompt,userPrompt,status,isOverride:false};}
function buildDefaultPromptBundle(kind,{target,cfg,quality,discName}={}){let systemPrompt="";let userPrompt="";if(kind==="probe_system"){systemPrompt=buildProbeSystemPrompt(cfg);userPrompt="(No user prompt for this view.)";}else if(kind==="probe_user"){systemPrompt=buildProbeSystemPrompt(cfg);userPrompt=buildProbeUserPrompt(target,discName,quality,cfg);}else if(kind==="synthesis"){systemPrompt=buildProbeSystemPrompt(cfg);const previewRows=getPromptPreviewDisciplineNames().map((name,idx)=>({discId:idx,summary:`Preview summary for ${name}.`,terms:[{label:`${name} mechanism`,description:`${name} view on ${target}.`}],claims_or_findings:[`Preview claim from ${name}.`]}));userPrompt=buildSynthesisPrompt(target,previewRows,quality,cfg);}else if(kind==="lens_generation"){const built=buildLensGenerationPrompt(target,clampInt(document.getElementById("lens-count-input")?.value,2,12),cfg);systemPrompt=built.systemPrompt;userPrompt=built.userPrompt;}else{const built=buildPromptPreviewArtifactPrompts(kind,target,cfg);systemPrompt=built.systemPrompt;userPrompt=built.userPrompt;}return {systemPrompt,userPrompt};}
function getEffectivePromptBundle(kind,{target,cfg,quality,discName}={}){const defaults=buildDefaultPromptBundle(kind,{target,cfg,quality,discName});return resolvePromptBundleWithOverrides(kind,{discName,target,quality,cfg,defaults});}
function buildLensGenerationPrompt(target,count,cfg={}){const notes=[];if(cfg?.promptIntent) notes.push(`Run intent: ${sanitizePromptMadLib(cfg.promptIntent)}`);if(cfg?.promptLensEmphasis) notes.push(`Analytic emphasis: ${sanitizePromptMadLib(cfg.promptLensEmphasis)}`);if(cfg?.promptHardConstraints) notes.push(`Hard constraints: ${sanitizePromptMadLib(cfg.promptHardConstraints,560)}`);if(cfg?.promptOutputStyle) notes.push(`Output style: ${sanitizePromptMadLib(cfg.promptOutputStyle)}`);const notesBlock=notes.length?`\n\nPrompt controls:\n- ${notes.join("\n- ")}`:"";const userPrompt=`Target concept: "${target}"\n\nGenerate exactly ${count} disciplines/lenses that are maximally orthogonal to each other while all still useful for studying the target.\n\nRules:\n- Prioritize conceptual distance between lenses\n- Avoid synonyms or near-duplicates\n- Include diverse levels: formal, empirical, social, normative, computational, historical, systems, etc. where useful\n- Keep each lens name concise (2-5 words)${notesBlock}\n\nReturn JSON only:\n{\n  "disciplines": [\"Lens 1\", \"Lens 2\"]\n}`;return {systemPrompt:"You design research lens sets. Return only strict JSON.",userPrompt};}
function buildPromptPreviewArtifactPrompts(kind,target,cfg){const byType={convergent:TERMS.filter(t=>t.type==="convergent").map(t=>t.label),contradictory:TERMS.filter(t=>t.type==="contradictory").map(t=>t.label),emergent:TERMS.filter(t=>t.type==="emergent").map(t=>t.label)};const artifactLine=cfg?.promptArtifactFocus?`Artifact focus: ${sanitizePromptMadLib(cfg.promptArtifactFocus)}\n\n`:"";if(kind==="artifact_deep_report"){return {systemPrompt:"You are a policy analyst writing a deep-research memo from structured multi-perspective evidence.",userPrompt:`${artifactLine}Topic: ${target}\nConvergent terms: ${byType.convergent.join(", ")||"-"}\nContradictory terms: ${byType.contradictory.join(", ")||"-"}\nEmergent terms: ${byType.emergent.join(", ")||"-"}\nSource policy: ${cfg.sourcePolicy||"none specified"}\nWrite sections: executive summary, alignments, fault lines, policy options, unknowns, caveats.`};}if(kind==="artifact_claims"){return {systemPrompt:"You are an analyst creating a claims ledger. Return strict JSON only.",userPrompt:`${artifactLine}Topic: ${target}\nEmergent terms: ${byType.emergent.join(", ")||"-"}\nContradictory terms: ${byType.contradictory.join(", ")||"-"}\nReport excerpt: ${(lastReportText||"(no report yet)").slice(0,400)}\nReturn claims JSON with confidence, counterclaim, falsifiability, evidence-needed, next-action.`};}if(kind==="artifact_outline"){return {systemPrompt:"You are an editor creating a structured outline from a research map.",userPrompt:`${artifactLine}Topic: ${target}\nPick exactly 3 convergences, 2 contradictions, and 1 emergent idea.\nReturn a structured outline with headings and bullets.`};}if(kind==="artifact_red_team"){return {systemPrompt:"You are a skeptical reviewer.",userPrompt:buildRedTeamPrompt(target,RUN_STATE?.probeResults||[],RUN_STATE?.synthResult||{convergent:[],contradictory:[],emergent:[]},cfg)};}if(kind==="artifact_replication"){return {systemPrompt:"You are a replication orchestrator for multi-model synthesis.",userPrompt:`${artifactLine}Topic: ${target}\nReplication models: ${cfg.replicationModels||"(none set)"}\nRuns/model: ${clampInt(cfg.replicationRuns||1,1,5)}\nStrategy: ${cfg.replicationStrategy||"fixed"}\nCompute overlap of term, contradiction, emergent sets vs baseline.`};}return {systemPrompt:"You are a research assistant producing Substack-ready Markdown with citations and methods. Return Markdown only.",userPrompt:`${artifactLine}Topic: ${target}\nConvergent: ${byType.convergent.join(", ")||"-"}\nContradictory: ${byType.contradictory.join(", ")||"-"}\nEmergent: ${byType.emergent.join(", ")||"-"}\nMethods include model, embedding model, quality, source policy.\nReturn markdown report with thesis, map summary, claims table, citations, methods appendix.`};}
function buildPromptParameterNarrative(target,cfg,quality,discName,kind){
  const groundingPolicy=resolveGroundingPolicy(cfg||{});
  const kindMeta=getPromptKindMeta(kind);
  const lines=[
    `Target: ${target||"(not set)"}`,
    `Preview kind: ${kindMeta.label}`,
    `Prompt usage: ${kindMeta.usage}`,
    `Override scope: ${kindMeta.scope==="lens"?"lens-specific":"global"}`,
    `Research model: ${cfg?.researchModel||"(unset)"}`,
    `Embedding model: ${cfg?.embeddingModel||"(unset)"}`,
    `Quality profile: ${quality?.id||"balanced"} (terms ${quality?.probeTermMin||"-"}-${quality?.probeTermMax||"-"}; synthesis C/C/E ${quality?.synthConvergent||"-"}/${quality?.synthContradictory||"-"}/${quality?.synthEmergent||"-"})`,
    `Temperature baseline: ${Number(quality?.temperature||0).toFixed(2)} | max_tokens baseline: ${quality?.maxTokens||"-"}`,
    `Grounding: ${cfg?.wolframEntityGrounding?"enabled":"disabled"} | mode ${groundingPolicy.mode} | q_min ${Number(groundingPolicy.minQualityScore||0).toFixed(2)} | a_min ${Number(groundingPolicy.minAlignmentScore||0).toFixed(2)}${groundingPolicy.annotateOnly?" | annotate-only":""}${groundingPolicy.allowCategoryMismatch?" | category-mismatch override":""}`,
    `Web search: ${cfg?.webSearch?"on":"off"} | red-team: ${cfg?.redTeam?"on":"off"} | source policy: ${cfg?.sourcePolicy||"none"}`
  ];
  if(kindMeta.scope==="lens") lines.push(`Discipline in preview: ${discName}`);
  return lines.join("\n");
}
function refreshPromptPreview(){
  const paramsEl=document.getElementById("prompt-preview-params");
  const statusEl=document.getElementById("prompt-preview-status");
  const systemEl=document.getElementById("prompt-preview-system");
  const userEl=document.getElementById("prompt-preview-user");
  const kindEl=document.getElementById("prompt-preview-kind-select");
  const discEl=document.getElementById("prompt-preview-disc-select");
  const discWrap=document.getElementById("prompt-preview-disc-wrap");
  if(!paramsEl||!statusEl||!systemEl||!userEl||!kindEl||!discEl){
    updateRunReadinessSummary();
    return;
  }
  PROMPT_PREVIEW_RENDERING=true;
  try{
    syncPromptPreviewDiscOptions();
    const cfg=readApiConfig();
    const quality=getQualityProfile(cfg.qualityMode);
    const target=document.getElementById("target-input")?.value.trim()||"(unset target)";
    const kind=normalizePromptOverrideKind(kindEl.value||"probe_user");
    const lensScoped=kind==="probe_user";
    discEl.disabled=!lensScoped;
    if(discWrap) discWrap.classList.toggle("prompt-preview-disc-wrap-disabled",!lensScoped);
    const discName=String(discEl.value||"").trim()||getPromptPreviewDisciplineNames()[0]||"Discipline";
    const bundle=getEffectivePromptBundle(kind,{target,cfg,quality,discName});
    paramsEl.value=buildPromptParameterNarrative(target,cfg,quality,discName,kind);
    statusEl.value=bundle.status;
    systemEl.value=bundle.systemPrompt||"";
    userEl.value=bundle.userPrompt||"";
    updatePromptKindHelp(kind,discName);
    updatePromptOverrideSummary(kind,discName,bundle);
  }finally{
    PROMPT_PREVIEW_RENDERING=false;
    updateRunReadinessSummary();
  }
}
function applyPromptPreviewOverride(){
  if(PROMPT_PREVIEW_RENDERING) return;
  const kindEl=document.getElementById("prompt-preview-kind-select");
  const discEl=document.getElementById("prompt-preview-disc-select");
  const systemEl=document.getElementById("prompt-preview-system");
  const userEl=document.getElementById("prompt-preview-user");
  if(!kindEl||!discEl||!systemEl||!userEl) return;
  const kind=normalizePromptOverrideKind(kindEl.value||"probe_user");
  const discName=kind==="probe_user"?String(discEl.value||"").trim():"";
  setPromptOverride(kind,discName,systemEl.value,userEl.value);
  markArtifactsStale(["claims","outline","deep_report","red_team","replication","markdown"]);
  refreshPromptPreview();
  showToast(kind==="probe_user"?`Custom prompt override saved for ${discName||"selected probe lens"}.`:"Custom prompt override saved.");
}
function resetPromptPreviewOverride(){
  const kindEl=document.getElementById("prompt-preview-kind-select");
  const discEl=document.getElementById("prompt-preview-disc-select");
  if(!kindEl||!discEl) return;
  const kind=normalizePromptOverrideKind(kindEl.value||"probe_user");
  const discName=kind==="probe_user"?String(discEl.value||"").trim():"";
  clearPromptOverride(kind,discName);
  markArtifactsStale(["claims","outline","deep_report","red_team","replication","markdown"]);
  refreshPromptPreview();
  showToast("Prompt override reset to default.");
}
function toggleApiKey(){const input=document.getElementById("api-key-input");const btn=document.getElementById("toggle-key-btn");const show=input.type==="password";input.type=show?"text":"password";btn.textContent=show?"HIDE":"SHOW";}
function clearApiKey(){const input=document.getElementById("api-key-input");input.value="";input.focus();}
async function generateOrthogonalLenses(){const target=document.getElementById("target-input").value.trim();if(!target){showToast("Enter a target concept first.");return;}const count=clampInt(document.getElementById("lens-count-input")?.value,2,12);const cfg=readApiConfig();const cfgError=validateApiConfig(cfg);if(cfgError){showToast(cfgError);return;}const btn=document.getElementById("gen-lenses-btn");const prev=btn.textContent;btn.disabled=true;btn.textContent="GENERATING...";try{const defaults=buildLensGenerationPrompt(target,count,cfg);const built=resolvePromptBundleWithOverrides("lens_generation",{target,cfg,quality:getQualityProfile(cfg.qualityMode),defaults});const raw=await callLLMJSON(built.systemPrompt,built.userPrompt,cfg);const parsed=extractJSON(raw);let list=[];if(Array.isArray(parsed)) list=parsed;else if(Array.isArray(parsed.disciplines)) list=parsed.disciplines;else if(Array.isArray(parsed.lenses)) list=parsed.lenses;const cleaned=[];const seen=new Set();for(const item of list){const name=String(item||"").replace(/^\d+[\).\-\s]*/,"").trim();const key=name.toLowerCase();if(!name||seen.has(key)) continue;seen.add(key);cleaned.push(name);}while(cleaned.length<count){const fallback=DEFAULT_DISCS[cleaned.length%DEFAULT_DISCS.length];const key=fallback.toLowerCase();if(!seen.has(key)){seen.add(key);cleaned.push(fallback);}else{cleaned.push(`Lens ${cleaned.length+1}`);}}renderDisciplineInputs(count,cleaned.slice(0,count));showToast(`Generated ${count} orthogonal lenses.`);}catch(err){console.error("Lens generation failed:",err);showToast("Lens generation failed. Check key/model and try again.");}finally{btn.disabled=false;btn.textContent=prev;refreshPromptPreview();}}
function syncApiModeNote(){const mode=document.getElementById("api-mode").value;const note=document.getElementById("api-mode-note");if(mode==="proxy"){note.textContent="Proxy mode is backend-ready. Add server routes at /api/llm/chat/completions, /api/llm/embeddings, and /wa/normalize (or /api/wolfram/query fallback) for Wolfram grounding.";}else{note.textContent="Direct mode sends model requests from this page (tab-memory key only). Wolfram Full Results API is CORS-blocked in direct mode; CA still simulates locally, but Wolfram grounding needs proxy mode.";}}
function showToast(msg){const t=document.getElementById("toast");t.textContent=msg;t.style.display="block";setTimeout(()=>{t.style.display="none";},5000);} 
function initArtifactStore(){ARTIFACT_STORE={};for(const key of Object.keys(ARTIFACT_DEFS)){ARTIFACT_STORE[key]={status:"not_generated",stale:false,generatedAt:"",fingerprint:"",contentText:"",contentHTML:"",data:null};}refreshArtifactList();updateArtifactProgress("Idle");}
function updateArtifactProgress(text){const el=document.getElementById("artifact-progress-text");if(el) el.textContent=text||"Idle";}
function getRunFingerprint(){const target=RUN_STATE?.target||document.getElementById("target-input")?.value.trim()||"";const probes=(DISCS||[]).map(d=>d.name);const synth=RUN_STATE?.synthResult||LAST_RUN?.synthResult||{convergent:[],contradictory:[],emergent:[]};const synthLabels=[...(synth.convergent||[]).map(x=>x.label||""),...(synth.contradictory||[]).map(x=>x.label||""),...(synth.emergent||[]).map(x=>x.label||"")].filter(Boolean);return hashString(JSON.stringify({target,probes,synthLabels,citationCount:CITATIONS.length,termCount:TERMS.length}));}
function setArtifactDrawer(open){const el=document.getElementById("artifact-drawer");if(!el) return;el.classList.toggle("open",Boolean(open));if(open) refreshArtifactList();}
function toggleArtifactDrawer(){setArtifactDrawer(!document.getElementById("artifact-drawer").classList.contains("open"));}
function setExportMenu(open){const el=document.getElementById("export-menu");if(!el) return;el.classList.toggle("open",Boolean(open));}
function toggleExportMenu(){setExportMenu(!document.getElementById("export-menu").classList.contains("open"));}
function artifactStatusBadge(status,stale){if(status==="not_generated") return `<span class="badge none">not generated</span>`;if(stale) return `<span class="badge stale">stale</span>`;return `<span class="badge ready">ready</span>`;}
function markArtifactsStale(keys=[]){const list=keys.length?keys:Object.keys(ARTIFACT_STORE);for(const key of list){const item=ARTIFACT_STORE[key];if(!item) continue;if(item.status==="ready"){item.stale=true;}}refreshArtifactList();}
function setArtifactReady(key,{contentText="",contentHTML="",data=null}={}){const item=ARTIFACT_STORE[key];if(!item) return;item.status="ready";item.stale=false;item.generatedAt=new Date().toISOString();item.fingerprint=getRunFingerprint();item.contentText=String(contentText||"");item.contentHTML=String(contentHTML||"");item.data=data;refreshArtifactList();}
function updateDerivedArtifactsReady(){setArtifactReady("raw_terms",buildRawTermsArtifact());setArtifactReady("evidence",buildEvidenceArtifact());setArtifactReady("wa_grounding_graph",buildWAGroundingGraphArtifact());}
function syncArtifactStoreFromRun(){if(!LAST_RUN){initArtifactStore();return;}if(Array.isArray(LAST_RUN?.wolframGroundingDiagnostics)){WOLFRAM_GROUNDING_DIAGNOSTICS=[...LAST_RUN.wolframGroundingDiagnostics];if(RUN_STATE) RUN_STATE.wolframGroundingDiagnostics=[...WOLFRAM_GROUNDING_DIAGNOSTICS];}if(Array.isArray(LAST_RUN?.ambiguityQueue)){AMBIGUITY_QUEUE=LAST_RUN.ambiguityQueue.map(normalizeAmbiguityQueueItem).filter(item=>item?.id);rebuildAmbiguityQueueFromDiagnostics(AMBIGUITY_QUEUE);}else{rebuildAmbiguityQueueFromDiagnostics();}if(LAST_RUN?.caProbe&&typeof LAST_RUN.caProbe==="object"){CA_PROBE_OUTPUT=LAST_RUN.caProbe;}updateDerivedArtifactsReady();if(Array.isArray(LAST_RUN.claimsLedger)&&LAST_RUN.claimsLedger.length){setArtifactReady("claims",{contentText:formatClaimsLedger(LAST_RUN.claimsLedger),data:LAST_RUN.claimsLedger});}if(LAST_RUN.outline){setArtifactReady("outline",{contentText:String(LAST_RUN.outline),data:{text:String(LAST_RUN.outline)}});}if(LAST_RUN.report){setArtifactReady("deep_report",{contentText:String(LAST_RUN.report),data:{text:String(LAST_RUN.report)}});}if(LAST_RUN.redTeamCritique){setArtifactReady("red_team",{contentText:String(LAST_RUN.redTeamCritique),data:{text:String(LAST_RUN.redTeamCritique)}});}if(Array.isArray(LAST_RUN.replication)&&LAST_RUN.replication.length){const txt=LAST_RUN.replication.map(r=>r.error?`- ${r.model}: ERROR ${r.error}`:`- ${r.model}: term overlap ${(r.termOverlap*100).toFixed(1)}% | contradiction overlap ${(r.contradictionOverlap*100).toFixed(1)}% | emergent overlap ${(r.emergentOverlap*100).toFixed(1)}%`).join("\n");setArtifactReady("replication",{contentText:txt,data:LAST_RUN.replication});}if(LAST_RUN.markdown){setArtifactReady("markdown",{contentText:String(LAST_RUN.markdown),data:{text:String(LAST_RUN.markdown)}});}updateAmbiguityQueueUIState();renderCAPanel();refreshArtifactList();}
function refreshArtifactList(){const list=document.getElementById("artifact-list");if(!list) return;const fp=getRunFingerprint();list.innerHTML="";for(const [key,def] of Object.entries(ARTIFACT_DEFS)){const state=ARTIFACT_STORE[key]||{status:"not_generated",stale:false,generatedAt:""};if(state.status==="ready"&&state.fingerprint&&state.fingerprint!==fp){state.stale=true;}const row=document.createElement("div");row.className="artifact-row";const when=state.generatedAt?new Date(state.generatedAt).toLocaleString():"-";row.innerHTML=`<div class="artifact-main"><div class="artifact-name">${def.name} ${artifactStatusBadge(state.status,state.stale)}</div><div class="artifact-meta">${def.desc}</div><div class="artifact-meta">updated: ${when}</div></div><div class="artifact-actions"><button class="small-btn" data-art-open="${key}" title="Open artifact">OPEN</button><button class="small-btn" data-art-copy="${key}" title="Copy artifact content">COPY</button><button class="small-btn" data-art-download="${key}" title="Download artifact">DOWNLOAD</button><button class="small-btn" data-art-regen="${key}" title="Regenerate artifact">REGENERATE</button></div>`;list.appendChild(row);}list.querySelectorAll("[data-art-open]").forEach(btn=>btn.addEventListener("click",()=>openArtifact(btn.getAttribute("data-art-open"))));list.querySelectorAll("[data-art-copy]").forEach(btn=>btn.addEventListener("click",()=>copyArtifact(btn.getAttribute("data-art-copy"))));list.querySelectorAll("[data-art-download]").forEach(btn=>btn.addEventListener("click",()=>downloadArtifact(btn.getAttribute("data-art-download"))));list.querySelectorAll("[data-art-regen]").forEach(btn=>btn.addEventListener("click",()=>openArtifact(btn.getAttribute("data-art-regen"),{regenerate:true})));list.querySelectorAll("[data-art-regen]").forEach(btn=>btn.disabled=ARTIFACT_BUSY);}
function setArtifactBusy(busy,label=""){ARTIFACT_BUSY=Boolean(busy);updateArtifactProgress(busy?label||"Working...":"Idle");const regenBtns=document.querySelectorAll("[data-art-regen]");for(const btn of regenBtns){btn.disabled=ARTIFACT_BUSY;}}
async function withArtifactTask(label,fn){if(ARTIFACT_BUSY){showToast("Another artifact task is running.");return null;}setArtifactBusy(true,label);try{return await fn();}finally{setArtifactBusy(false);}}
function buildRawTermsArtifact(){if(!TERMS.length) return {contentText:"No plotted nodes available yet.",data:[]};const lines=[];const data=[];for(const term of TERMS){applyDisplayDescriptionForTerm(term,{fallbackDescription:term.description,fallbackSource:term.description_source});const slices=term.slices.length?term.slices.map(i=>DISCS[i]?.name||`Probe ${i+1}`).join(" | "):"Synthesis-only";const pos=[Number(term.pos?.[0]||0),Number(term.pos?.[1]||0),Number(term.pos?.[2]||0)];const reason=String(term?.descriptions?.displayDescriptionReason||"");lines.push(`[${term.type.toUpperCase()}] ${term.label}\n  Probes: ${slices}\n  Pos: (${pos[0].toFixed(3)}, ${pos[1].toFixed(3)}, ${pos[2].toFixed(3)})\n  Desc: ${term.description||"-"}\n  Desc reason: ${reason||"-"}`);data.push({label:term.label,type:term.type,slices:[...term.slices],pos,description:term.description||"",descriptions:structuredCloneSafe(term.descriptions||defaultDescriptionLayers()),centrality:term.centrality});}return {contentText:lines.join("\n\n"),data};}
function buildEvidenceArtifact(){
  if(!CITATIONS.length) return {contentText:"No citations captured yet.",contentHTML:"<div class=\"artifact-meta\">No citations captured yet.</div>",data:[]};
  const rows=CITATIONS.map(c=>{const mapBits=(Array.isArray(c.supporting_term_mappings)?c.supporting_term_mappings:[]).slice(0,4).map(m=>`${m.supporting_term} => ${m.mapped_term}`).join(" | ");const unmappedBits=(Array.isArray(c.unmapped_supporting_terms)?c.unmapped_supporting_terms:[]).slice(0,5).join(", ");return `<div class="evidence-card"><div class="evidence-top"><div class="evidence-title">${escapeHtml(c.title||c.publisher||c.url||"Untitled source")}</div><div class="evidence-meta">${escapeHtml([c.publisher,c.date].filter(Boolean).join(" | "))}</div></div><div class="tag-row"><span class="tag strong">${escapeHtml(sourceTypeLabel(c.source_type,c.publisher))}</span><span class="tag">${escapeHtml((c.supporting_terms||[]).slice(0,5).join(", ")||"no linked terms")}</span>${mapBits?`<span class="tag">${escapeHtml(`mapped: ${mapBits}`)}</span>`:""}${unmappedBits?`<span class="tag">${escapeHtml(`unmapped: ${unmappedBits}`)}</span>`:""}${c.grounding_status?`<span class="tag">${escapeHtml(`grounding: ${formatWolframGroundingStatusLabel(c.grounding_status)}`)}</span>`:""}</div><div class="evidence-meta">${escapeHtml([c.quote_or_snippet||c.relevance||"No snippet provided.",mapBits?`alias map: ${mapBits}`:"",unmappedBits?`unmapped terms: ${unmappedBits}`:"",buildWolframCitationContext(c)].filter(Boolean).join("\n"))}</div></div>`;}).join("");
  const txt=CITATIONS.map((c,i)=>`${i+1}. ${c.title||c.publisher||"Source"} | ${c.date||"n.d."} | ${c.url||"-"} | ${c.source_type||"untyped"}\n   relevance: ${c.relevance||"-"}\n   supports (mapped): ${(c.supporting_terms||[]).join(", ")||"-"}\n   supports (raw): ${(c.supporting_terms_raw||[]).join(", ")||"-"}\n   alias mappings: ${((c.supporting_term_mappings||[]).map(m=>`${m.supporting_term}=>${m.mapped_term} (${m.strategy}${Number.isFinite(Number(m.confidence))?`,${Number(m.confidence).toFixed(2)}`:""})`).join(" | "))||"-"}\n   unmapped terms: ${(c.unmapped_supporting_terms||[]).join(", ")||"-"}${buildWolframCitationContext(c)?`\n   wolfram: ${buildWolframCitationContext(c).replace(/\n/g," | ")}`:""}`).join("\n\n");
  return {contentText:txt,contentHTML:`<div class="card-list">${rows}</div>`,data:CITATIONS.map(c=>({...c}))};
}
function waGraphStatusLabel(bucket){return WA_GRAPH_STATUS_META[bucket]?.label||String(bucket||"unknown");}
function waGraphStatusColor(bucket){return WA_GRAPH_STATUS_META[bucket]?.color||"#64748b";}
function hexToRgbaColor(hex,alpha=1){const raw=String(hex||"").trim().replace(/^#/,"");const full=raw.length===3?raw.split("").map(ch=>ch+ch).join(""):raw;if(!/^[0-9a-fA-F]{6}$/.test(full)) return `rgba(100,116,139,${Math.max(0,Math.min(1,alpha))})`;const r=parseInt(full.slice(0,2),16);const g=parseInt(full.slice(2,4),16);const b=parseInt(full.slice(4,6),16);return `rgba(${r},${g},${b},${Math.max(0,Math.min(1,alpha))})`;}
function normalizeWAGraphLabel(value,fallback="(none)"){const txt=String(value||"").replace(/\s+/g," ").trim();return txt||fallback;}
function resolveWAGraphOutcomeBucket(item){
  const status=String(item?.status||"").trim().toLowerCase();
  const reasons=(Array.isArray(item?.reasons)?item.reasons:[]).map(x=>String(x||"").trim().toLowerCase()).filter(Boolean);
  if(status.includes("no_plaintext")||status==="cache_hit_term_no_match"||reasons.includes("empty")) return "no_plaintext";
  if(status==="rejected_category_mismatch"||reasons.some(reason=>reason.startsWith("category_mismatch_")||reason==="forced_metadata_only_category_mismatch")) return "rejected_category_mismatch";
  if(status==="accepted_metadata_only"||status==="accepted_annotation_only") return "metadata_only";
  if(Boolean(item?.accepted)&&item?.appliedToDescription===false) return "metadata_only";
  if(status==="accepted") return "accepted";
  if(Boolean(item?.accepted)&&status.startsWith("accepted")) return "accepted";
  return "rejected_low_confidence";
}
function buildWAGroundingGraphData(diagnostics=WOLFRAM_GROUNDING_DIAGNOSTICS){
  const statusOrder=["accepted","metadata_only","rejected_category_mismatch","rejected_low_confidence","no_plaintext"];
  const diagList=Array.isArray(diagnostics)?diagnostics.filter(item=>item&&typeof item==="object"):[];
  const statusCounts=Object.fromEntries(statusOrder.map(key=>[key,0]));
  const data={generatedAt:new Date().toISOString(),diagnosticsCount:diagList.length,statusOrder,statusCounts,nodes:[],links:[],paths:[],interpretationCollisions:[],retryHotspots:[],uniqueTerms:0,uniqueQueries:0,uniqueInterpretations:0,pathCount:0};
  if(!diagList.length) return data;
  const nodeMap=new Map();
  const linkMap=new Map();
  const pathMap=new Map();
  const termQueryCounts=new Map();
  const interpretationStats=new Map();
  const ensureNode=(kind,label)=>{
    const normalized=normalizeWAGraphLabel(label,kind==="term"?"(unknown term)":kind==="query"?"(no query)":"(no interpretation)");
    const canonical=toCanonicalKey(normalized)||hashString(`${kind}:${normalized.toLowerCase()}`);
    const id=`${kind}:${canonical}`;
    if(!nodeMap.has(id)) nodeMap.set(id,{id,kind,label:normalized,count:0});
    const node=nodeMap.get(id);
    node.count++;
    return node;
  };
  const ensureStatusNode=(bucket)=>{
    const id=`status:${bucket}`;
    if(!nodeMap.has(id)) nodeMap.set(id,{id,kind:"status",label:waGraphStatusLabel(bucket),count:0,statusBucket:bucket});
    const node=nodeMap.get(id);
    node.count++;
    return node;
  };
  const addLink=(sourceId,targetId,kind,statusBucket)=>{
    const id=`${kind}|${sourceId}|${targetId}`;
    if(!linkMap.has(id)) linkMap.set(id,{id,kind,source:sourceId,target:targetId,value:0,statusCounts:{}});
    const link=linkMap.get(id);
    link.value++;
    if(statusBucket) link.statusCounts[statusBucket]=(link.statusCounts[statusBucket]||0)+1;
    return link;
  };
  for(const diag of diagList){
    const termLabel=normalizeWAGraphLabel(diag?.termLabel,"(unknown term)");
    const queryLabel=normalizeWAGraphLabel(diag?.query,"(no query)");
    const interpretationLabel=normalizeWAGraphLabel(diag?.chosenInterpretation||diag?.inputInterpretation||diag?.bestDefinition||diag?.snippet,"(no interpretation)");
    const statusBucket=resolveWAGraphOutcomeBucket(diag);
    if(statusCounts[statusBucket]===undefined) statusCounts[statusBucket]=0;
    statusCounts[statusBucket]++;
    const termNode=ensureNode("term",termLabel);
    const queryNode=ensureNode("query",queryLabel);
    const interpretationNode=ensureNode("interpretation",interpretationLabel);
    const statusNode=ensureStatusNode(statusBucket);
    const termQueryKey=`${termNode.id}|${queryNode.id}`;
    termQueryCounts.set(termQueryKey,(termQueryCounts.get(termQueryKey)||0)+1);
    addLink(termNode.id,queryNode.id,"term_query",statusBucket);
    addLink(queryNode.id,interpretationNode.id,"query_interpretation",statusBucket);
    addLink(interpretationNode.id,statusNode.id,"interpretation_status",statusBucket);
    const pathKey=`${termNode.id}|${queryNode.id}|${interpretationNode.id}|${statusBucket}`;
    if(!pathMap.has(pathKey)) pathMap.set(pathKey,{term:termNode.label,query:queryNode.label,interpretation:interpretationNode.label,statusBucket,count:0,reasons:new Set(),rawStatuses:new Set()});
    const path=pathMap.get(pathKey);
    path.count++;
    const reasons=(Array.isArray(diag?.reasons)?diag.reasons:[]).map(x=>String(x||"").trim()).filter(Boolean);
    for(const reason of reasons){if(path.reasons.size<10) path.reasons.add(reason);}
    const rawStatus=String(diag?.status||"").trim();
    if(rawStatus) path.rawStatuses.add(rawStatus);
    if(!interpretationStats.has(interpretationNode.id)) interpretationStats.set(interpretationNode.id,{interpretation:interpretationNode.label,totalCount:0,terms:new Set(),queries:new Set(),statusCounts:{}});
    const interpStat=interpretationStats.get(interpretationNode.id);
    interpStat.totalCount++;
    interpStat.terms.add(termNode.label);
    interpStat.queries.add(queryNode.label);
    interpStat.statusCounts[statusBucket]=(interpStat.statusCounts[statusBucket]||0)+1;
  }
  const kindRank={term:1,query:2,interpretation:3,status:4};
  data.nodes=[...nodeMap.values()].sort((a,b)=>(kindRank[a.kind]||99)-(kindRank[b.kind]||99)||Number(b.count)-Number(a.count)||String(a.label).localeCompare(String(b.label)));
  data.links=[...linkMap.values()].map(link=>{
    const breakdown=Object.entries(link.statusCounts||{}).map(([bucket,count])=>({statusBucket:bucket,label:waGraphStatusLabel(bucket),count:Number(count)||0,color:waGraphStatusColor(bucket)})).sort((a,b)=>Number(b.count)-Number(a.count));
    const dominant=breakdown[0]?.statusBucket||"";
    const retryCount=link.kind==="term_query"?Math.max(0,(termQueryCounts.get(`${link.source}|${link.target}`)||link.value)-1):Math.max(0,Number(link.value)-1);
    return {id:link.id,kind:link.kind,source:link.source,target:link.target,value:Number(link.value)||0,retryCount,dominantStatusBucket:dominant,statusBreakdown:breakdown};
  }).sort((a,b)=>Number(b.value)-Number(a.value)||String(a.kind).localeCompare(String(b.kind)));
  data.paths=[...pathMap.values()].map(path=>({term:path.term,query:path.query,interpretation:path.interpretation,statusBucket:path.statusBucket,statusLabel:waGraphStatusLabel(path.statusBucket),count:path.count,retries:Math.max(0,path.count-1),reasons:[...path.reasons],statuses:[...path.rawStatuses]})).sort((a,b)=>Number(b.count)-Number(a.count)||String(a.term).localeCompare(String(b.term)));
  data.interpretationCollisions=[...interpretationStats.values()].map(item=>{const statusBreakdown=Object.entries(item.statusCounts||{}).map(([bucket,count])=>({statusBucket:bucket,label:waGraphStatusLabel(bucket),count:Number(count)||0,color:waGraphStatusColor(bucket)})).sort((a,b)=>Number(b.count)-Number(a.count));return {interpretation:item.interpretation,totalCount:item.totalCount,termCount:item.terms.size,queryCount:item.queries.size,terms:[...item.terms].sort(),queries:[...item.queries].sort(),statusBreakdown};}).filter(item=>item.termCount>=2).sort((a,b)=>Number(b.termCount)-Number(a.termCount)||Number(b.totalCount)-Number(a.totalCount)||String(a.interpretation).localeCompare(String(b.interpretation)));
  data.retryHotspots=[...termQueryCounts.entries()].filter(([,count])=>Number(count)>1).map(([pair,count])=>{const [termId,queryId]=pair.split("|");return {term:nodeMap.get(termId)?.label||"(unknown term)",query:nodeMap.get(queryId)?.label||"(no query)",count:Number(count)||0,retries:Math.max(0,(Number(count)||0)-1)};}).sort((a,b)=>Number(b.count)-Number(a.count)||String(a.term).localeCompare(String(b.term)));
  data.uniqueTerms=data.nodes.filter(node=>node.kind==="term").length;
  data.uniqueQueries=data.nodes.filter(node=>node.kind==="query").length;
  data.uniqueInterpretations=data.nodes.filter(node=>node.kind==="interpretation").length;
  data.pathCount=data.paths.length;
  return data;
}
function buildWAGroundingGraphText(data){
  if(!data?.diagnosticsCount) return "No Wolfram grounding diagnostics captured yet.";
  const lines=[
    "WA Interpretation Graph",
    `Generated: ${data.generatedAt||new Date().toISOString()}`,
    `Diagnostics: ${Number(data.diagnosticsCount)||0}`,
    `Unique terms: ${Number(data.uniqueTerms)||0} | Queries: ${Number(data.uniqueQueries)||0} | Interpretations: ${Number(data.uniqueInterpretations)||0}`,
    "",
    "Outcome buckets:"
  ];
  for(const bucket of (data.statusOrder||[])){lines.push(`- ${waGraphStatusLabel(bucket)}: ${Number(data.statusCounts?.[bucket]||0)}`);}
  lines.push("");
  lines.push("Top weighted paths (count | retries):");
  const topPaths=Array.isArray(data.paths)?data.paths.slice(0,18):[];
  if(!topPaths.length){lines.push("- none");}
  else{for(const row of topPaths){lines.push(`- ${row.count} | ${row.retries} :: ${row.term} -> ${row.query} -> ${row.interpretation} -> ${waGraphStatusLabel(row.statusBucket)}`);}}
  lines.push("");
  lines.push("Top interpretation collisions:");
  const collisions=Array.isArray(data.interpretationCollisions)?data.interpretationCollisions.slice(0,12):[];
  if(!collisions.length){lines.push("- none");}
  else{for(const row of collisions){lines.push(`- ${row.interpretation} :: terms ${row.termCount}, paths ${row.totalCount}`);}}
  return lines.join("\n");
}
function buildWAGroundingGraphHTML(data){
  if(!data?.diagnosticsCount) return `<div class="artifact-meta">No Wolfram grounding diagnostics captured yet.</div>`;
  const statusTags=(data.statusOrder||[]).map(bucket=>`<span class="tag" style="border-color:${waGraphStatusColor(bucket)};color:${waGraphStatusColor(bucket)}">${escapeHtml(waGraphStatusLabel(bucket))}: ${Number(data.statusCounts?.[bucket]||0)}</span>`).join("");
  const pathRows=(Array.isArray(data.paths)?data.paths.slice(0,22):[]).map(row=>`<tr><td>${escapeHtml(row.term)}</td><td>${escapeHtml(row.query)}</td><td>${escapeHtml(row.interpretation)}</td><td><span class="tag" style="border-color:${waGraphStatusColor(row.statusBucket)};color:${waGraphStatusColor(row.statusBucket)}">${escapeHtml(waGraphStatusLabel(row.statusBucket))}</span></td><td>${Number(row.count)||0}</td><td>${Number(row.retries)||0}</td></tr>`).join("");
  const collisionRows=(Array.isArray(data.interpretationCollisions)?data.interpretationCollisions.slice(0,14):[]).map(item=>{const terms=item.terms.slice(0,5).join(" | ");const extra=item.terms.length>5?` +${item.terms.length-5} more`:"";const status=item.statusBreakdown.slice(0,2).map(x=>`${waGraphStatusLabel(x.statusBucket)} ${x.count}`).join(" | ");return `<tr><td>${escapeHtml(item.interpretation)}</td><td>${item.termCount}</td><td>${item.totalCount}</td><td>${escapeHtml(`${terms}${extra}`)}</td><td>${escapeHtml(status||"-")}</td></tr>`;}).join("");
  const retryRows=(Array.isArray(data.retryHotspots)?data.retryHotspots.slice(0,14):[]).map(item=>`<tr><td>${escapeHtml(item.term)}</td><td>${escapeHtml(item.query)}</td><td>${item.count}</td><td>${item.retries}</td></tr>`).join("");
  return `<div style="display:flex;flex-direction:column;gap:10px"><div class="artifact-meta">Diagnostics graph: term -> query -> chosen interpretation -> outcome status.</div><div class="tag-row">${statusTags}</div><div class="artifact-meta">Weighted edges use frequency; retries are repeat traversals of the same edge path.</div><div id="wa-graph-sankey-host" style="width:100%;height:380px;border:1px solid var(--border);border-radius:8px;background:var(--panel-alt)"></div><div class="matrix-wrap"><table class="matrix-table"><thead><tr><th>Term</th><th>Query</th><th>Chosen interpretation</th><th>Outcome</th><th>Count</th><th>Retries</th></tr></thead><tbody>${pathRows||"<tr><td colspan=\"6\">No paths captured.</td></tr>"}</tbody></table></div><div class="artifact-meta">Interpretation collision hotspots (same interpretation attracting multiple terms):</div><div class="matrix-wrap"><table class="matrix-table"><thead><tr><th>Interpretation</th><th>Term count</th><th>Path count</th><th>Top terms</th><th>Dominant outcomes</th></tr></thead><tbody>${collisionRows||"<tr><td colspan=\"5\">No multi-term interpretation collisions.</td></tr>"}</tbody></table></div><div class="artifact-meta">Retry hotspots (term/query pairs with repeat attempts):</div><div class="matrix-wrap"><table class="matrix-table"><thead><tr><th>Term</th><th>Query</th><th>Attempts</th><th>Retries</th></tr></thead><tbody>${retryRows||"<tr><td colspan=\"4\">No retries detected.</td></tr>"}</tbody></table></div></div>`;
}
function buildWAGroundingGraphArtifact(){const data=buildWAGroundingGraphData(WOLFRAM_GROUNDING_DIAGNOSTICS);return {contentText:buildWAGroundingGraphText(data),contentHTML:buildWAGroundingGraphHTML(data),data};}
function escapeHtml(str){return String(str||"").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll("\"","&quot;");}
function openArtifactModal(key){const def=ARTIFACT_DEFS[key];const state=ARTIFACT_STORE[key];if(!def||!state) return;ACTIVE_ARTIFACT_KEY=key;document.getElementById("artifact-modal-title").textContent=def.name.toUpperCase();const when=state.generatedAt?new Date(state.generatedAt).toLocaleString():"-";document.getElementById("artifact-modal-meta").textContent=`Generated: ${when} | Source: ${CURRENT_RUN_ID||LAST_RUN?.runId||"-"} | Status: ${state.stale?"stale":state.status}`;const content=document.getElementById("artifact-modal-content");if(state.contentHTML){content.classList.remove("mono-block");content.classList.add("artifact-html");content.innerHTML=state.contentHTML;}else{content.classList.add("mono-block");content.classList.remove("artifact-html");content.textContent=state.contentText||"";}openModal("artifact-modal");requestAnimationFrame(()=>renderArtifactModalEnhancements(key,state));}
function renderArtifactModalEnhancements(key,state){if(key==="wa_grounding_graph") renderWAGroundingGraphSankey(state?.data);}
function renderWAGroundingGraphSankey(data){
  const host=document.getElementById("wa-graph-sankey-host");
  if(!host) return;
  if(typeof Plotly==="undefined"){host.innerHTML="<div class=\"artifact-meta\" style=\"padding:12px\">Plotly unavailable; Sankey view skipped.</div>";return;}
  const links=Array.isArray(data?.links)?data.links:[];
  const nodes=Array.isArray(data?.nodes)?data.nodes:[];
  if(!links.length||!nodes.length){host.innerHTML="<div class=\"artifact-meta\" style=\"padding:12px\">No diagnostic graph links to render yet.</div>";return;}
  const maxLinks=Math.max(40,Math.min(280,links.length));
  const keptLinks=[...links].sort((a,b)=>Number(b.value)-Number(a.value)).slice(0,maxLinks);
  const requiredNodeIds=new Set();
  for(const link of keptLinks){requiredNodeIds.add(String(link.source));requiredNodeIds.add(String(link.target));}
  const keptNodes=nodes.filter(node=>requiredNodeIds.has(String(node.id)));
  const nodeIndex=new Map();
  keptNodes.forEach((node,idx)=>nodeIndex.set(String(node.id),idx));
  const sankeyLinks=keptLinks.filter(link=>nodeIndex.has(String(link.source))&&nodeIndex.has(String(link.target)));
  if(!sankeyLinks.length){host.innerHTML="<div class=\"artifact-meta\" style=\"padding:12px\">No diagnostic graph links to render yet.</div>";return;}
  const nodeColors=keptNodes.map(node=>{if(node.kind==="status") return waGraphStatusColor(node.statusBucket||"");if(node.kind==="interpretation") return "#0f766e";if(node.kind==="query") return "#475569";return "#334155";});
  const nodeLabels=keptNodes.map(node=>String(node.label||""));
  const nodeCustom=keptNodes.map(node=>`${node.kind} node | observations: ${Number(node.count)||0}`);
  const linkSources=sankeyLinks.map(link=>nodeIndex.get(String(link.source)));
  const linkTargets=sankeyLinks.map(link=>nodeIndex.get(String(link.target)));
  const linkValues=sankeyLinks.map(link=>Math.max(1,Number(link.value)||1));
  const linkColors=sankeyLinks.map(link=>{const bucket=String(link?.dominantStatusBucket||"");if(bucket) return hexToRgbaColor(waGraphStatusColor(bucket),link.kind==="interpretation_status"?0.62:0.34);return "rgba(100,116,139,0.3)";});
  const linkCustom=sankeyLinks.map(link=>{const src=keptNodes[nodeIndex.get(String(link.source))]?.label||link.source;const dst=keptNodes[nodeIndex.get(String(link.target))]?.label||link.target;const status=String(link?.dominantStatusBucket||"");const statusPart=status?` | dominant outcome: ${waGraphStatusLabel(status)}`:"";return `${src} -> ${dst}<br>weight: ${Number(link.value)||0} | retries: ${Number(link.retryCount)||0}${statusPart}`;});
  const trace={type:"sankey",orientation:"h",arrangement:"snap",node:{label:nodeLabels,color:nodeColors,pad:12,thickness:14,line:{color:"rgba(148,163,184,0.35)",width:0.6},customdata:nodeCustom,hovertemplate:"%{label}<br>%{customdata}<extra></extra>"},link:{source:linkSources,target:linkTargets,value:linkValues,color:linkColors,customdata:linkCustom,hovertemplate:"%{customdata}<extra></extra>"}};
  const layout={paper_bgcolor:"rgba(0,0,0,0)",plot_bgcolor:"rgba(0,0,0,0)",margin:{l:8,r:8,t:8,b:8},font:{family:"Courier New, monospace",size:11,color:"#e5e7eb"}};
  Plotly.react(host,[trace],layout,{displayModeBar:false,responsive:true,staticPlot:true});
}
function artifactCanOpenWithoutRegenerate(key){const item=ARTIFACT_STORE[key];if(!item) return false;if(item.status!=="ready") return false;if(item.stale) return false;if(item.fingerprint&&item.fingerprint!==getRunFingerprint()) return false;return true;}
async function openArtifact(key,{regenerate=false,openAfter=true}={}){if(!ARTIFACT_DEFS[key]) return;const derived=ARTIFACT_DEFS[key].kind==="derived";if(derived&&!regenerate){if(key==="raw_terms") setArtifactReady(key,buildRawTermsArtifact());if(key==="evidence") setArtifactReady(key,buildEvidenceArtifact());if(key==="wa_grounding_graph") setArtifactReady(key,buildWAGroundingGraphArtifact());if(openAfter) openArtifactModal(key);return;}if(!regenerate&&artifactCanOpenWithoutRegenerate(key)){if(openAfter) openArtifactModal(key);return;}await regenerateArtifact(key,{openAfter});}
async function regenerateArtifact(key,{openAfter=true}={}){if(!ARTIFACT_DEFS[key]) return;const cfg=readApiConfig();const target=LAST_RUN?.target||RUN_STATE?.target||document.getElementById("viz-target-label").textContent||"Topic";const run=async()=>{if(key==="raw_terms"){setArtifactReady(key,buildRawTermsArtifact());return;}if(key==="evidence"){setArtifactReady(key,buildEvidenceArtifact());return;}if(key==="wa_grounding_graph"){setArtifactReady(key,buildWAGroundingGraphArtifact());return;}if(key==="claims"){const res=await generateClaimsArtifact(target,cfg);setArtifactReady(key,res);LAST_RUN={...(LAST_RUN||{}),claimsLedger:res.data||[]};return;}if(key==="outline"){const res=await generateOutlineArtifact(target,cfg);setArtifactReady(key,res);LAST_RUN={...(LAST_RUN||{}),outline:res.contentText};return;}if(key==="deep_report"){const res=await generateDeepReportArtifact(target,cfg);setArtifactReady(key,res);LAST_RUN={...(LAST_RUN||{}),report:res.contentText};return;}if(key==="red_team"){const res=await generateRedTeamArtifact(target,cfg);setArtifactReady(key,res);LAST_RUN={...(LAST_RUN||{}),redTeamCritique:res.contentText};return;}if(key==="replication"){const res=await generateReplicationArtifact(target,cfg);setArtifactReady(key,res);LAST_RUN={...(LAST_RUN||{}),replication:res.data||[]};return;}if(key==="markdown"){const res=await generateMarkdownArtifact(target,cfg);setArtifactReady(key,res);LAST_RUN={...(LAST_RUN||{}),markdown:res.contentText};return;}};await withArtifactTask(`Generating ${ARTIFACT_DEFS[key].name}...`,async()=>{try{await run();showToast(`${ARTIFACT_DEFS[key].name} ready.`);if(openAfter) openArtifactModal(key);}catch(err){console.error(`${key} artifact generation failed:`,err);showToast(`${ARTIFACT_DEFS[key].name} failed: ${err.message||err}`);}});}
function artifactToCopyText(key){const item=ARTIFACT_STORE[key];if(!item) return "";if(item.contentText) return item.contentText;return JSON.stringify(item.data||{},null,2);}
async function copyArtifact(key){if(!ARTIFACT_DEFS[key]) return;const isDerived=ARTIFACT_DEFS[key].kind==="derived";if(isDerived||!artifactCanOpenWithoutRegenerate(key)){await openArtifact(key,{regenerate:false,openAfter:false});}const text=artifactToCopyText(key);if(!text){showToast("No artifact text to copy.");return;}try{await navigator.clipboard.writeText(text);showToast(`${ARTIFACT_DEFS[key].name} copied.`);}catch{showToast("Clipboard copy failed.");}}
function downloadBlob(filename,blob){const url=URL.createObjectURL(blob);const a=document.createElement("a");a.href=url;a.download=filename;document.body.appendChild(a);a.click();a.remove();setTimeout(()=>URL.revokeObjectURL(url),250);}
function artifactFilenameBase(key){const target=(LAST_RUN?.target||RUN_STATE?.target||"run").toLowerCase().replace(/[^a-z0-9]+/g,"-").replace(/^-+|-+$/g,"")||"run";return `ruliad-${target}-${key}`;}
async function downloadArtifact(key){if(!ARTIFACT_DEFS[key]) return;const isDerived=ARTIFACT_DEFS[key].kind==="derived";if(isDerived||!artifactCanOpenWithoutRegenerate(key)){await openArtifact(key,{regenerate:false,openAfter:false});}const item=ARTIFACT_STORE[key];if(!item||item.status!=="ready"){showToast("Artifact not available yet.");return;}const base=artifactFilenameBase(key);const text=artifactToCopyText(key);if(text){downloadBlob(`${base}.md`,new Blob([text],{type:"text/markdown"}));}if(item.data!==null&&item.data!==undefined){downloadBlob(`${base}.json`,new Blob([JSON.stringify(item.data,null,2)],{type:"application/json"}));}showToast(`${ARTIFACT_DEFS[key].name} downloaded.`);}
function buildWAGraphReadyNodeExport(graphData){
  const kindLayer={term:0,query:1,interpretation:2,status:3};
  const nodes=Array.isArray(graphData?.nodes)?graphData.nodes:[];
  return nodes.map(node=>{
    const kind=String(node?.kind||"unknown");
    const statusBucket=kind==="status"?String(node?.statusBucket||""):"";
    const hasLayer=Object.prototype.hasOwnProperty.call(kindLayer,kind);
    return {
      id:String(node?.id||""),
      label:String(node?.label||""),
      kind,
      layer:hasLayer?kindLayer[kind]:99,
      observations:Number(node?.count)||0,
      statusBucket,
      statusLabel:statusBucket?waGraphStatusLabel(statusBucket):"",
      color:statusBucket?waGraphStatusColor(statusBucket):""
    };
  }).filter(node=>node.id);
}
function buildWAGraphReadyEdgeExport(graphData,nodes=[]){
  const links=Array.isArray(graphData?.links)?graphData.links:[];
  const nodeMap=new Map((Array.isArray(nodes)?nodes:[]).map(node=>[String(node.id),node]));
  return links.map(link=>{
    const source=String(link?.source||"");
    const target=String(link?.target||"");
    const dominantStatusBucket=String(link?.dominantStatusBucket||"");
    return {
      id:String(link?.id||`${source}|${target}`),
      kind:String(link?.kind||""),
      source,
      sourceLabel:nodeMap.get(source)?.label||source,
      sourceKind:nodeMap.get(source)?.kind||"",
      target,
      targetLabel:nodeMap.get(target)?.label||target,
      targetKind:nodeMap.get(target)?.kind||"",
      weight:Number(link?.value)||0,
      retryCount:Number(link?.retryCount)||0,
      dominantStatusBucket,
      dominantStatusLabel:dominantStatusBucket?waGraphStatusLabel(dominantStatusBucket):"",
      dominantStatusColor:dominantStatusBucket?waGraphStatusColor(dominantStatusBucket):"",
      statusBreakdown:Array.isArray(link?.statusBreakdown)?link.statusBreakdown.map(item=>({
        statusBucket:String(item?.statusBucket||""),
        label:String(item?.label||""),
        count:Number(item?.count)||0,
        color:String(item?.color||"")
      })):[]
    };
  }).filter(edge=>edge.source&&edge.target);
}
function buildWAGraphReadyWLSource({nodesFilename="wa_graph_nodes.json",edgesFilename="wa_graph_edges.json"}={}){
  return [
    "(* WA grounding diagnostic graph artifact *)",
    "(* Expects wa_graph_nodes.json and wa_graph_edges.json in the current directory *)",
    `nodes = Import["${String(nodesFilename||"wa_graph_nodes.json")}", "RawJSON"];`,
    `edges = Import["${String(edgesFilename||"wa_graph_edges.json")}", "RawJSON"];`,
    "",
    "statusColors = <|",
    "  \"accepted\" -> RGBColor[0.086, 0.627, 0.306],",
    "  \"metadata_only\" -> RGBColor[0.855, 0.576, 0.106],",
    "  \"rejected_category_mismatch\" -> RGBColor[0.863, 0.078, 0.235],",
    "  \"rejected_low_confidence\" -> RGBColor[0.522, 0.447, 0.702],",
    "  \"no_plaintext\" -> RGBColor[0.278, 0.565, 0.761]",
    "|>;",
    "",
    "vertexLabels = Association @ Map[#[\"id\"] -> Row[{#[\"kind\"], \": \", #[\"label\"]}] &, nodes];",
    "vertexStyles = Association @ Map[",
    "  If[StringLength @ ToString @ Lookup[#, \"statusBucket\", \"\"] > 0,",
    "    #[\"id\"] -> Lookup[statusColors, Lookup[#, \"statusBucket\", \"\"], GrayLevel[0.45]],",
    "    Nothing",
    "  ] &,",
    "  nodes",
    "];",
    "",
    "edgeRules = Map[#[\"source\"] -> #[\"target\"] &, edges];",
    "edgeWeights = Map[Max[1, Lookup[#, \"weight\", 1]] &, edges];",
    "edgeStyles = Map[",
    "  (#[\"source\"] -> #[\"target\"]) -> Directive[",
    "    Lookup[statusColors, Lookup[#, \"dominantStatusBucket\", \"\"], GrayLevel[0.6]],",
    "    Opacity[0.55]",
    "  ] &,",
    "  edges",
    "];",
    "",
    "Graph[",
    "  edgeRules,",
    "  VertexLabels -> (v_ :> Lookup[vertexLabels, v, v]),",
    "  VertexStyle -> vertexStyles,",
    "  EdgeWeight -> edgeWeights,",
    "  EdgeStyle -> edgeStyles,",
    "  GraphLayout -> \"LayeredDigraphEmbedding\",",
    "  ImageSize -> Large",
    "]"
  ].join("\n");
}
function buildWAGraphReadyExportData(diagnostics=WOLFRAM_GROUNDING_DIAGNOSTICS){
  const graphData=buildWAGroundingGraphData(diagnostics);
  const nodes=buildWAGraphReadyNodeExport(graphData);
  const edges=buildWAGraphReadyEdgeExport(graphData,nodes);
  const metadata={
    generatedAt:new Date().toISOString(),
    runId:CURRENT_RUN_ID||LAST_RUN?.runId||RUN_STATE?.runId||null,
    target:LAST_RUN?.target||RUN_STATE?.target||null,
    diagnosticsCount:Number(graphData?.diagnosticsCount)||0,
    pathCount:Number(graphData?.pathCount)||0
  };
  return {metadata,nodes,edges,wlSource:buildWAGraphReadyWLSource()};
}
async function exportWAGraphReadyArtifacts({includeWL=true}={}){
  const exportData=buildWAGraphReadyExportData(WOLFRAM_GROUNDING_DIAGNOSTICS);
  downloadBlob("wa_graph_nodes.json",new Blob([JSON.stringify(exportData.nodes,null,2)],{type:"application/json"}));
  downloadBlob("wa_graph_edges.json",new Blob([JSON.stringify(exportData.edges,null,2)],{type:"application/json"}));
  downloadBlob("wa_graph_metadata.json",new Blob([JSON.stringify(exportData.metadata,null,2)],{type:"application/json"}));
  if(includeWL){
    downloadBlob("wa_graph.wl",new Blob([exportData.wlSource],{type:"text/plain;charset=utf-8"}));
  }
  if(!exportData.metadata.diagnosticsCount){
    showToast("Graph-ready export generated (no WA diagnostics captured yet).");
    return;
  }
  showToast(`Graph-ready export downloaded (${exportData.metadata.diagnosticsCount} diagnostics).`);
}
async function copyActiveArtifact(){if(!ACTIVE_ARTIFACT_KEY) return;await copyArtifact(ACTIVE_ARTIFACT_KEY);}
async function downloadActiveArtifact(){if(!ACTIVE_ARTIFACT_KEY) return;await downloadArtifact(ACTIVE_ARTIFACT_KEY);}
async function generateDeepReportArtifact(target,cfg){const byType={unique:TERMS.filter(t=>t.type==="unique"),convergent:TERMS.filter(t=>t.type==="convergent"),contradictory:TERMS.filter(t=>t.type==="contradictory"),emergent:TERMS.filter(t=>t.type==="emergent")};const partySummaries=DISCS.map(d=>{const terms=TERMS.filter(t=>t.slices.includes(d.id)).map(t=>t.label);return `${d.name}: ${terms.slice(0,18).join(", ")}`;}).join("\n");const contras=byType.contradictory.map(t=>`${t.label} :: ${(t.slices||[]).map(i=>DISCS[i]?.name||`Probe ${i+1}`).join(" vs ")}`).join("\n");const emers=byType.emergent.map(t=>t.label).join(", ");const converg=byType.convergent.map(t=>`${t.label} (${t.slices.length} probes)`).join(", ");const citationLines=CITATIONS.map(c=>`- ${c.title||c.publisher||"Source"} (${c.date||"n.d."}) ${c.url} :: ${c.relevance||"supporting evidence"} [${c.source_type||"untyped"}]`).join("\n");const defaultSystemPrompt="You are a policy analyst writing a deep-research memo from structured multi-perspective evidence.";const userPromptBase=`Topic: ${target}\n\nSource policy: ${cfg.sourcePolicy||"none specified"}\n\nProbe specifications:\n${DISCS.map((d,i)=>`${i+1}. ${d.name}`).join("\n")}\n\nPer-probe key terms:\n${partySummaries}\n\nConvergent terms:\n${converg}\n\nContradictory terms:\n${contras}\n\nEmergent terms:\n${emers}\n\nEvidence sources:\n${citationLines||"- none captured"}\n\nWrite a concise but substantive report with sections:\n1) Executive Summary\n2) Major Alignments\n3) Major Fault Lines\n4) Integrative Policy Options\n5) Key Unknowns and Research Priorities\n6) Caveats\n\nUse clear, non-inflammatory language and cite terms from the map explicitly.`;const defaultUserPrompt=appendPromptMadLibBlock(userPromptBase,cfg,{includeArtifact:true});const promptBundle=resolvePromptBundleWithOverrides("artifact_deep_report",{target,cfg,quality:getQualityProfile(cfg.qualityMode),defaults:{systemPrompt:defaultSystemPrompt,userPrompt:defaultUserPrompt}});const cfgBudget=withArtifactTokenBudget(cfg,{minTokens:3200,multiplier:2.4,maxTokens:12000});const text=await callLLM(promptBundle.systemPrompt,promptBundle.userPrompt,cfgBudget);lastReportText=text;return {contentText:text,data:{text}};}
async function generateClaimsArtifact(target,cfg){const emergent=TERMS.filter(t=>t.type==="emergent").map(t=>t.label);const contradictory=TERMS.filter(t=>t.type==="contradictory").map(t=>t.label);const reportText=lastReportText||LAST_RUN?.report||"";const defaultSystemPrompt="You are an analyst creating a claims ledger. Return strict JSON only.";const userPromptBase=`Topic: ${target}\n\nEmergent terms:\n${emergent.join(", ")||"-"}\n\nContradictory terms:\n${contradictory.join(", ")||"-"}\n\nReport excerpt:\n${reportText.slice(0,2000)||"(no report yet)"}\n\nReturn JSON only:\n{\n  "claims":[\n    {\n      "claim":"",\n      "confidence":"low|medium|high",\n      "claim_type":"empirical|normative|methodological|forecast",\n      "scope":"where it applies and does not apply",\n      "linked_nodes":["term label"],\n      "linked_evidence_ids":[0],\n      "evidence_status":"unverified|partial|verified",\n      "counterclaim":"best opposing formulation",\n      "what_would_change_mind":"",\n      "evidence_needed":"what kind of source would count",\n      "next_action":"one concrete verification step"\n    }\n  ]\n}\n\nRules:\n- Use concise, non-inflammatory language\n- If confidence is high, you must provide a falsifiable what_would_change_mind; otherwise set confidence to medium\n- Link claims to emergent or contradictory terms when possible`;const defaultUserPrompt=appendPromptMadLibBlock(userPromptBase,cfg,{includeArtifact:true});const promptBundle=resolvePromptBundleWithOverrides("artifact_claims",{target,cfg,quality:getQualityProfile(cfg.qualityMode),defaults:{systemPrompt:defaultSystemPrompt,userPrompt:defaultUserPrompt}});const cfgBudget=withArtifactTokenBudget(cfg,{minTokens:2200,multiplier:1.8,maxTokens:9000});const raw=await callLLMJSON(promptBundle.systemPrompt,promptBundle.userPrompt,cfgBudget);const parsed=extractJSON(raw);const claims=Array.isArray(parsed.claims)?parsed.claims:[];for(const c of claims){const conf=String(c.confidence||"").toLowerCase();const wcm=String(c.what_would_change_mind||"").trim();if(conf==="high"&&!wcm){c.confidence="medium";c.what_would_change_mind="Not specified; requires falsifiability.";}if(!c.evidence_status) c.evidence_status="unverified";if(!Array.isArray(c.linked_evidence_ids)) c.linked_evidence_ids=[];}const text=formatClaimsLedger(claims);lastClaimsText=text;return {contentText:text,data:claims};}
async function generateOutlineArtifact(target,cfg){const converg=TERMS.filter(t=>t.type==="convergent").map(t=>t.label);const contras=TERMS.filter(t=>t.type==="contradictory").map(t=>t.label);const emergent=TERMS.filter(t=>t.type==="emergent").map(t=>t.label);const defaultSystemPrompt="You are an editor creating a structured outline from a research map.";const userPromptBase=`Topic: ${target}\n\nPick exactly 3 convergences, 2 fault lines (contradictions), and 1 emergent idea to anchor the outline.\nConvergences: ${converg.join(", ")}\nFault lines: ${contras.join(", ")}\nEmergent: ${emergent.join(", ")}\n\nReturn a structured outline with headings and bullet points, explicitly referencing the chosen nodes.`;const defaultUserPrompt=appendPromptMadLibBlock(userPromptBase,cfg,{includeArtifact:true});const promptBundle=resolvePromptBundleWithOverrides("artifact_outline",{target,cfg,quality:getQualityProfile(cfg.qualityMode),defaults:{systemPrompt:defaultSystemPrompt,userPrompt:defaultUserPrompt}});const cfgBudget=withArtifactTokenBudget(cfg,{minTokens:2200,multiplier:1.9,maxTokens:9000});const text=await callLLM(promptBundle.systemPrompt,promptBundle.userPrompt,cfgBudget);lastOutlineText=text;return {contentText:text,data:{text}};}
async function generateRedTeamArtifact(target,cfg){const defaults={systemPrompt:"You are a skeptical reviewer.",userPrompt:buildRedTeamPrompt(target,RUN_STATE?.probeResults||[],RUN_STATE?.synthResult||{convergent:[],contradictory:[],emergent:[]},cfg)};const promptBundle=resolvePromptBundleWithOverrides("artifact_red_team",{target,cfg,quality:getQualityProfile(cfg.qualityMode),defaults});const cfgBudget=withArtifactTokenBudget(cfg,{minTokens:2400,multiplier:2.0,maxTokens:10000});const text=await callLLM(promptBundle.systemPrompt,promptBundle.userPrompt,cfgBudget);lastCritiqueText=text;return {contentText:text,data:{text}};}
async function generateReplicationArtifact(target,cfg){const models=(cfg.replicationModels||"").split(",").map(s=>s.trim()).filter(Boolean);if(!models.length) throw new Error("Add replication models (comma-separated) first.");if(!RUN_STATE?.probeResults?.length) throw new Error("Run a baseline expedition first.");const runCount=clampInt(cfg.replicationRuns||1,1,5);const strategy=cfg.replicationStrategy||"fixed";const quality=getQualityProfile(cfg.qualityMode);const baseTerms=RUN_STATE.probeResults.flatMap(r=>(r.terms||[]).map(t=>String(t.label||"").trim()).filter(Boolean));const baseTermSet=new Set(baseTerms);const baseContras=new Set((RUN_STATE.synthResult?.contradictory||[]).map(t=>String(t.label||"").trim()).filter(Boolean));const baseEmerg=new Set((RUN_STATE.synthResult?.emergent||[]).map(t=>String(t.label||"").trim()).filter(Boolean));const overlap=(a,b)=>{const union=new Set([...a,...b]);if(!union.size) return 0;let inter=0;for(const v of a){if(b.has(v)) inter++;}return inter/union.size;};const termMissCounts=new Map();const results=[];const priorCA=CA_PROBE_OUTPUT;for(const model of models){for(let runNo=1;runNo<=runCount;runNo++){try{const cfg2={...cfg,researchModel:model};if(strategy==="jitter"){const q=getQualityProfile(cfg.qualityMode);const jitter=((runNo%2===0)?0.04:-0.04);cfg2.qualityMode="balanced";cfg2.__tempOverride=Math.max(0,Math.min(1,q.temperature+jitter));}const probeSystemDefault=buildProbeSystemPrompt(cfg2);const probeSystemBundle=resolvePromptBundleWithOverrides("probe_system",{target,cfg:cfg2,quality,defaults:{systemPrompt:probeSystemDefault,userPrompt:""}});const probeResults=await Promise.all(DISCS.map(async(d)=>{if(d.kind==="ca"){const simNorm=await runComputationalIrreducibilityProbe(target,cfg2);return {discId:d.id,summary:simNorm.summary,terms:Array.isArray(simNorm.terms)?simNorm.terms:[]};}const probeDefaults={systemPrompt:probeSystemBundle.systemPrompt||probeSystemDefault,userPrompt:buildProbeUserPrompt(target,d.name,quality,cfg2)};const probeBundle=resolvePromptBundleWithOverrides("probe_user",{discName:d.name,target,cfg:cfg2,quality,defaults:probeDefaults});let norm=await getProbeResultWithRecovery({target,discName:d.name,probeSystem:probeBundle.systemPrompt||probeSystemBundle.systemPrompt||probeSystemDefault,userMsg:probeBundle.userPrompt,cfg:cfg2});norm=await groundProbeTermsWithWolfram(norm,target,d.name,cfg2);return {discId:d.id,summary:norm.summary,terms:Array.isArray(norm.terms)?norm.terms:[]};}));const synthResult=await getSynthesisResultWithRecovery(target,probeResults,quality,cfg2,{contextLabel:`replication_artifact_${model}_run_${runNo}`});const termSet=new Set(probeResults.flatMap(r=>(r.terms||[]).map(t=>String(t.label||"").trim()).filter(Boolean)));const contraSet=new Set((synthResult.contradictory||[]).map(t=>String(t.label||"").trim()).filter(Boolean));const emergSet=new Set((synthResult.emergent||[]).map(t=>String(t.label||"").trim()).filter(Boolean));for(const base of baseTermSet){if(!termSet.has(base)){termMissCounts.set(base,(termMissCounts.get(base)||0)+1);}}results.push({model,run:runNo,termOverlap:overlap(baseTermSet,termSet),contradictionOverlap:overlap(baseContras,contraSet),emergentOverlap:overlap(baseEmerg,emergSet),synthCounts:{convergent:(synthResult.convergent||[]).length,contradictory:(synthResult.contradictory||[]).length,emergent:(synthResult.emergent||[]).length}});}catch(err){results.push({model,run:runNo,error:err.message||String(err)});}}}const ok=results.filter(r=>!r.error);const stability=ok.length?ok.reduce((s,r)=>s+((r.termOverlap+r.contradictionOverlap+r.emergentOverlap)/3),0)/ok.length:0;const unstable=[...termMissCounts.entries()].filter(([,c])=>c>=Math.ceil((models.length*runCount)/2)).sort((a,b)=>b[1]-a[1]).slice(0,12).map(([term,count])=>`${term} (${count}/${models.length*runCount} misses)`);const lines=results.map(r=>r.error?`- ${r.model} [run ${r.run}]: ERROR ${r.error}`:`- ${r.model} [run ${r.run}]: term overlap ${(r.termOverlap*100).toFixed(1)}% | contradiction overlap ${(r.contradictionOverlap*100).toFixed(1)}% | emergent overlap ${(r.emergentOverlap*100).toFixed(1)}% | synth C/C/E ${r.synthCounts?.convergent||0}/${r.synthCounts?.contradictory||0}/${r.synthCounts?.emergent||0}`).join("\n");const text=`Replication summary for ${target}:\n\nStrategy: ${strategy} | Runs/model: ${runCount}\nStability score: ${(stability*100).toFixed(1)}%\n\n${lines}\n\nUnstable terms:\n${unstable.length?unstable.map(x=>`- ${x}`).join("\n"):"- none flagged"}`;CA_PROBE_OUTPUT=priorCA;return {contentText:text,data:results};}
async function generateMarkdownArtifact(target,cfg){const byType={convergent:TERMS.filter(t=>t.type==="convergent"),contradictory:TERMS.filter(t=>t.type==="contradictory"),emergent:TERMS.filter(t=>t.type==="emergent")};const citationLines=CITATIONS.map((c,i)=>`${i+1}. ${c.title||c.publisher||"Source"} (${c.date||"n.d."}) ${c.url}`).join("\n");const method=`Model: ${cfg.researchModel}\nEmbeddings: ${cfg.embeddingModel}\nQuality: ${cfg.qualityMode}\nWeb search: ${cfg.webSearch?"on":"off"}\nSource policy: ${cfg.sourcePolicy||"none"}`;const defaultSystemPrompt="You are a research assistant producing Substack-ready Markdown with citations and methods. Return Markdown only.";const userPromptBase=`Topic: ${target}\n\nConvergent terms:\n${byType.convergent.map(t=>t.label).join(", ")}\n\nContradictory terms:\n${byType.contradictory.map(t=>t.label).join(", ")}\n\nEmergent terms:\n${byType.emergent.map(t=>t.label).join(", ")}\n\nClaims ledger:\n${lastClaimsText||"(not generated)"}\n\nCitations:\n${citationLines||"(none)"}\n\nMethods:\n${method}\n\nReturn Markdown with:\n- Title + hook\n- Thesis\n- Map summary (convergent / contradictory / emergent)\n- Claims ledger table (if available)\n- Footnoted citations list\n- Methods appendix`;const defaultUserPrompt=appendPromptMadLibBlock(userPromptBase,cfg,{includeArtifact:true});const promptBundle=resolvePromptBundleWithOverrides("artifact_markdown",{target,cfg,quality:getQualityProfile(cfg.qualityMode),defaults:{systemPrompt:defaultSystemPrompt,userPrompt:defaultUserPrompt}});const cfgBudget=withArtifactTokenBudget(cfg,{minTokens:3000,multiplier:2.3,maxTokens:12000});const text=await callLLM(promptBundle.systemPrompt,promptBundle.userPrompt,cfgBudget);lastMarkdownText=text;return {contentText:text,data:{text}};}
async function exportArtifactBundle(){
  if(!TERMS.length){showToast("No plotted data available yet.");return;}
  if(typeof JSZip==="undefined"){showToast("Bundle export unavailable: JSZip not loaded.");return;}
  await withArtifactTask("Building artifact bundle...",async()=>{
    for(const key of ["raw_terms","evidence","wa_grounding_graph","claims","outline","deep_report","red_team","replication","markdown"]){
      if(key==="claims"||key==="outline"||key==="deep_report"||key==="red_team"||key==="replication"||key==="markdown"){
        if(!artifactCanOpenWithoutRegenerate(key)) await openArtifact(key,{regenerate:false,openAfter:false});
      }else{
        await openArtifact(key,{regenerate:false,openAfter:false});
      }
    }
    const zip=new JSZip();
    const cfg=RUN_STATE?.config||readApiConfig();
    const runPayload=buildRunSnapshot(LAST_RUN?.target||RUN_STATE?.target||"run",RUN_STATE?.probeResults||LAST_RUN?.probeResults||[],RUN_STATE?.synthResult||LAST_RUN?.synthResult||{convergent:[],contradictory:[],emergent:[]},cfg);
    zip.file("run.json",JSON.stringify(runPayload,null,2));
    zip.file("raw_nodes.json",JSON.stringify((ARTIFACT_STORE.raw_terms?.data)||[],null,2));
    zip.file("evidence.json",JSON.stringify((ARTIFACT_STORE.evidence?.data)||[],null,2));
    zip.file("wa_interpretation_graph.json",JSON.stringify((ARTIFACT_STORE.wa_grounding_graph?.data)||{},null,2));
    zip.file("wa_interpretation_graph.md",ARTIFACT_STORE.wa_grounding_graph?.contentText||"");
    const waGraphReady=buildWAGraphReadyExportData(WOLFRAM_GROUNDING_DIAGNOSTICS);
    zip.file("wa_graph_nodes.json",JSON.stringify(waGraphReady.nodes,null,2));
    zip.file("wa_graph_edges.json",JSON.stringify(waGraphReady.edges,null,2));
    zip.file("wa_graph_metadata.json",JSON.stringify(waGraphReady.metadata,null,2));
    zip.file("wa_graph.wl",waGraphReady.wlSource);
    zip.file("claims.json",JSON.stringify((ARTIFACT_STORE.claims?.data)||[],null,2));
    zip.file("claims.md",ARTIFACT_STORE.claims?.contentText||"");
    zip.file("outline.json",JSON.stringify((ARTIFACT_STORE.outline?.data)||{},null,2));
    zip.file("outline.md",ARTIFACT_STORE.outline?.contentText||"");
    zip.file("deep_report.md",ARTIFACT_STORE.deep_report?.contentText||"");
    zip.file("critique.md",ARTIFACT_STORE.red_team?.contentText||"");
    zip.file("replication.md",ARTIFACT_STORE.replication?.contentText||"");
    zip.file("report.md",ARTIFACT_STORE.markdown?.contentText||"");
    if(plotInited){
      try{
        const dataUrl=await Plotly.toImage("plot",{format:"png",width:1600,height:1000});
        const b64=dataUrl.split(",")[1]||"";
        zip.file("figure.png",b64,{base64:true});
      }catch(err){console.warn("Could not export figure for bundle:",err);}
    }
    const blob=await zip.generateAsync({type:"blob"});
    const base=(LAST_RUN?.target||RUN_STATE?.target||"run").toLowerCase().replace(/[^a-z0-9]+/g,"-").replace(/^-+|-+$/g,"")||"run";
    downloadBlob(`ruliad-bundle-${base}.zip`,blob);
    showToast("Artifact bundle exported.");
  });
}
function hashString(str){let h=2166136261;for(let i=0;i<str.length;i++){h^=str.charCodeAt(i);h=Math.imul(h,16777619)>>>0;}return h.toString(16).padStart(8,"0");}
const GROUNDING_MODE_DEFAULTS={
  conservative:{minQualityScore:0.8,minAlignmentScore:0.7,minApplyConfidence:"high"},
  balanced:{minQualityScore:0.58,minAlignmentScore:0.55,minApplyConfidence:"medium"},
  aggressive:{minQualityScore:0.5,minAlignmentScore:0.45,minApplyConfidence:"low"}
};
const NAME_LIKE_METADATA_ALIGNMENT_MIN=0.92;
const NAME_LIKE_OVERRIDE_ALIGNMENT_MIN=0.97;
const NAME_LIKE_OVERRIDE_QUALITY_MIN=0.8;
function normalizeGroundingAggressiveness(value){const mode=String(value||"").trim().toLowerCase();if(mode==="conservative"||mode==="aggressive"||mode==="balanced") return mode;return "balanced";}
function clampGroundingSnippetScore(value,fallback=0.58){if(value===null||value===undefined||String(value).trim()===""){const f=Number(fallback);return Number.isFinite(f)?Math.max(0,Math.min(1,f)):0.58;}const n=Number(value);if(!Number.isFinite(n)){const f=Number(fallback);return Number.isFinite(f)?Math.max(0,Math.min(1,f)):0.58;}return Math.max(0,Math.min(1,n));}
function parseGroundingSnippetScoreInput(raw){const txt=String(raw??"").trim();if(!txt) return null;const n=Number(txt);if(!Number.isFinite(n)) return null;return clampGroundingSnippetScore(n,0.58);}
function resolveGroundingPolicy(cfg){
  const mode=normalizeGroundingAggressiveness(cfg?.groundingMode);
  const defaultsByMode={
    conservative:{minQualityScore:0.8,minAlignmentScore:0.7,minApplyConfidence:"high"},
    balanced:{minQualityScore:0.58,minAlignmentScore:0.55,minApplyConfidence:"medium"},
    aggressive:{minQualityScore:0.5,minAlignmentScore:0.45,minApplyConfidence:"low"}
  };
  const defaults=defaultsByMode[mode]||defaultsByMode.balanced;
  const minQualityScore=clampGroundingSnippetScore(cfg?.groundingMinSnippetScore,defaults.minQualityScore);
  const minAlignmentScore=clampGroundingSnippetScore(cfg?.groundingMinAlignmentScore,defaults.minAlignmentScore);
  const annotateOnly=Boolean(cfg?.groundingAnnotateOnly);
  const allowCategoryMismatch=Boolean(cfg?.allowGroundingCategoryMismatch);
  return {mode,minSnippetScore:minQualityScore,minQualityScore,minAlignmentScore,annotateOnly,allowCategoryMismatch,minApplyConfidence:String(defaults.minApplyConfidence||"medium")};
}
function evaluateGroundingApplication(scoring,policy){const qualityScore=Number.isFinite(Number(scoring?.snippet_quality_score))?Number(scoring.snippet_quality_score):Number.isFinite(Number(scoring?.score))?Number(scoring.score):0;const alignmentScore=Number.isFinite(Number(scoring?.semantic_alignment_score))?Number(scoring.semantic_alignment_score):Number.isFinite(Number(scoring?.score))?Number(scoring.score):0;const qualityMin=Number(policy?.minQualityScore??policy?.minSnippetScore??0.58);const alignmentMin=Number(policy?.minAlignmentScore??0.55);const qualityOk=qualityScore>=qualityMin;const alignmentOk=alignmentScore>=alignmentMin;const confidence=String(scoring?.confidence||"low").toLowerCase();const accepted=qualityOk&&alignmentOk;const reasons=[];let status=accepted?"accepted":"rejected_low_confidence";let applyToDescription=false;if(!qualityOk) reasons.push(`quality_below_threshold_${qualityMin.toFixed(2)}`);if(!alignmentOk) reasons.push(`alignment_below_threshold_${alignmentMin.toFixed(2)}`);if(!accepted) return {accepted,applyToDescription,status,reasons};if(policy?.annotateOnly){status="accepted_annotation_only";reasons.push("annotate_only_policy");return {accepted,applyToDescription,status,reasons};}const strictAppendMin=0.8;const mismatchFlags=Boolean(scoring?.single_word_drift)||Boolean(scoring?.single_word_drift_warning_signal)||Boolean(scoring?.closest_interpretation_type_mismatch)||Boolean(scoring?.assumption_clash_generic_token);if(qualityScore<strictAppendMin||alignmentScore<strictAppendMin||mismatchFlags){status="accepted_metadata_only";if(qualityScore<strictAppendMin) reasons.push(`append_quality_below_strict_${strictAppendMin.toFixed(2)}`);if(alignmentScore<strictAppendMin) reasons.push(`append_alignment_below_strict_${strictAppendMin.toFixed(2)}`);if(mismatchFlags) reasons.push("append_blocked_mismatch_flags");return {accepted,applyToDescription,status,reasons};}const required=String(policy?.minApplyConfidence||"medium").toLowerCase();if(confidenceRank(confidence)<confidenceRank(required)){status="accepted_metadata_only";reasons.push(`mode_requires_${required}_confidence`);return {accepted,applyToDescription,status,reasons};}applyToDescription=true;return {accepted,applyToDescription,status,reasons};}
function isAbstractConceptPhrase(label){
  const text=String(label||"").replace(/\s+/g," ").trim();
  if(!text) return false;
  const canonical=toCanonicalKey(text);
  if(!canonical) return false;
  if(/^[A-Z]{2,}$/.test(text)) return false;
  if(/[\d]/.test(text)) return false;
  const tokens=canonical.split(" ").filter(Boolean);
  if(!tokens.length) return false;
  const abstractLexicon=new Set(["abstraction","agency","attention","belief","causality","chaos","coherence","complexity","consciousness","culture","democracy","dynamics","economics","emergence","entropy","ethics","fairness","freedom","identity","information","inference","innovation","intelligence","justice","knowledge","language","learning","legitimacy","logic","meaning","memory","money","morality","norms","optimization","order","perception","philosophy","policy","power","probability","reasoning","resilience","risk","security","semantics","society","stability","strategy","systems","theory","time","trust","uncertainty","value"]);
  if(tokens.some(tok=>abstractLexicon.has(tok)||/(?:ness|tion|sion|ity|ism|hood|ship|ment|ance|ence|ology|ics|acy|tude)$/.test(tok))) return true;
  return tokens.length>=2;
}
function isAbstractNameCollisionTarget(label){
  if(isAbstractConceptPhrase(label)) return true;
  const text=String(label||"").replace(/\s+/g," ").trim();
  const canonical=toCanonicalKey(text);
  if(!canonical) return false;
  const tokens=canonical.split(" ").filter(Boolean);
  if(tokens.length!==1) return false;
  const abstractSingles=new Set(["hope","faith","grace","charity","mercy","truth","beauty","love","peace","virtue","justice","freedom","destiny","meaning","reason","harmony","order","purpose"]);
  return abstractSingles.has(tokens[0]);
}
function looksNameLikeInterpretation({entityType="",chosenInterpretation="",definition="",parsed={},chosenPod=""}={}){
  const entityRaw=String(entityType||"").replace(/([a-z])([A-Z])/g,"$1 $2").toLowerCase();
  const blob=[chosenInterpretation,definition,parsed?.bestDefinition,parsed?.inputInterpretation,chosenPod,entityRaw,...(Array.isArray(parsed?.didYouMeans)?parsed.didYouMeans:[]),...(Array.isArray(parsed?.altFacts)?parsed.altFacts:[]),...(Array.isArray(parsed?.warnings)?parsed.warnings:[])].map(x=>String(x||"")).join(" ").toLowerCase();
  if(!blob.trim()) return false;
  const strongPatterns=[
    /\bgiven name\b/,
    /\bsurname\b/,
    /\bfamily name\b/,
    /\bforename\b/,
    /\bfirst name\b/,
    /\blast name\b/,
    /\bpersonal name\b/,
    /\bproper name\b/,
    /\bmasculine given name\b/,
    /\bfeminine given name\b/
  ];
  if(strongPatterns.some(re=>re.test(blob))) return true;
  const genericNameSignal=/\bname\b/.test(blob);
  const contextualSignal=/\b(?:baby names?|name origin|name meaning|name statistics|name rank|popular names?|namesake)\b/.test(blob);
  return genericNameSignal&&contextualSignal;
}
function resolveScoringComponent(scoring,keyA,keyB){
  const first=Number(scoring?.[keyA]);
  if(Number.isFinite(first)) return first;
  const second=Number(scoring?.[keyB]);
  if(Number.isFinite(second)) return second;
  return null;
}
function classifyWolframResolvedCategory({entityType="",chosenInterpretation="",definition="",parsed={},chosenPod=""}={}){
  const textBlob=[chosenInterpretation,definition,parsed?.bestDefinition,parsed?.inputInterpretation,chosenPod,...(Array.isArray(parsed?.didYouMeans)?parsed.didYouMeans:[]),...(Array.isArray(parsed?.altFacts)?parsed.altFacts:[]),...(Array.isArray(parsed?.warnings)?parsed.warnings:[])].map(x=>String(x||"")).join(" ").toLowerCase();
  const typeKey=String(entityType||"").replace(/([a-z])([A-Z])/g,"$1 $2").toLowerCase().replace(/[^a-z0-9]+/g," ");
  const has=(re)=>re.test(textBlob)||re.test(typeKey);
  if(looksNameLikeInterpretation({entityType,chosenInterpretation,definition,parsed,chosenPod})) return "name_like";
  if(has(/\bairport\b|\bairfield\b/)) return "airport";
  if(has(/\bperiodical\b|\bjournal\b|\bmagazine\b|\bnewspaper\b|\bpublication\b/)) return "periodical";
  if(has(/\bchemical\b|\bcompound\b|\bmolecule\b|\bmolecular formula\b|\biupac\b|\bpesticide\b|\borganophosphate\b/)) return "chemical_compound";
  if(has(/\bperson\b|\bhuman\b|\bbiography\b|\bborn\b|\bdied\b/)) return "person";
  if(has(/\bplace\b|\blocation\b|\bcity\b|\bcountry\b|\bstate\b|\bprovince\b|\bcounty\b|\bmunicipality\b|\bcapital\b|\briver\b|\bmountain\b|\bvillage\b/)) return "place";
  return "";
}
function evaluateGroundingCategoryMismatch({termLabel="",entityType="",chosenInterpretation="",definition="",parsed={},chosenPod="",policy={},scoring=null}={}){
  if(Boolean(policy?.allowCategoryMismatch)) return {blocked:false,forceMetadataOnly:false,category:"",reasons:[]};
  const abstractTarget=isAbstractNameCollisionTarget(termLabel);
  if(!abstractTarget) return {blocked:false,forceMetadataOnly:false,category:"",reasons:[]};
  const category=classifyWolframResolvedCategory({entityType,chosenInterpretation,definition,parsed,chosenPod});
  if(!category) return {blocked:false,forceMetadataOnly:false,category:"",reasons:[]};
  if(category==="name_like"){
    const alignment=resolveScoringComponent(scoring,"semantic_alignment_score","semanticAlignmentScore");
    const quality=resolveScoringComponent(scoring,"snippet_quality_score","snippetQualityScore");
    const baseReasons=["name_like_interpretation"];
    const mismatchReasons=[...baseReasons,"category_mismatch_name_like"];
    const overrideAllowed=Number.isFinite(alignment)&&alignment>=NAME_LIKE_OVERRIDE_ALIGNMENT_MIN&&(!Number.isFinite(quality)||quality>=NAME_LIKE_OVERRIDE_QUALITY_MIN);
    if(overrideAllowed){
      return {blocked:false,forceMetadataOnly:false,category,reasons:[...baseReasons,"name_like_interpretation_high_alignment_override"]};
    }
    const demoteOnly=Number.isFinite(alignment)&&alignment>=NAME_LIKE_METADATA_ALIGNMENT_MIN;
    if(demoteOnly){
      return {blocked:false,forceMetadataOnly:true,category,reasons:[...mismatchReasons,"forced_metadata_only_name_like_interpretation"]};
    }
    return {blocked:true,forceMetadataOnly:false,category,reasons:[...mismatchReasons,"forced_metadata_only_category_mismatch"]};
  }
  if(!["airport","periodical","chemical_compound","person","place"].includes(category)){
    return {blocked:false,forceMetadataOnly:false,category,reasons:[]};
  }
  return {blocked:true,forceMetadataOnly:false,category,reasons:[`category_mismatch_${category}`,"forced_metadata_only_category_mismatch"]};
}
function labelContentTokens(label){const stopWords=new Set(["a","an","the","of","for","to","in","on","at","by","with","from","and","or","as","via","into","is","are","be","this","that","these","those"]);return String(label||"").toLowerCase().split(/[^a-z0-9]+/g).map(tok=>tok.trim()).filter(tok=>tok&&tok.length>1&&!stopWords.has(tok));}
function isTitleCaseCompositeLabel(label){const words=String(label||"").replace(/\s+/g," ").trim().split(" ").map(part=>part.trim()).filter(Boolean);if(words.length<2) return false;const alphaWords=words.map(word=>word.replace(/[^A-Za-z]/g,"")).filter(Boolean);if(alphaWords.length<2) return false;const titleCount=alphaWords.filter(word=>/^[A-Z][a-z]+$/.test(word)).length;return titleCount>=Math.max(2,Math.ceil(alphaWords.length*0.67));}
function isCompositeSyntheticTermLabel(label){const contentCount=labelContentTokens(label).length;if(contentCount<2) return false;return isAbstractConceptPhrase(label)||isTitleCaseCompositeLabel(label);}
function hasExactConceptPhraseMatch(label,texts=[]){const labelKey=toCanonicalKey(label||"");if(!labelKey) return false;for(const text of (Array.isArray(texts)?texts:[texts])){const key=toCanonicalKey(text||"");if(!key) continue;if(key===labelKey||key.includes(labelKey)) return true;}return false;}
function hasHighAlignmentConceptMatch(scoring){const semantic=Number(scoring?.semantic_alignment_score);const quality=Number(scoring?.snippet_quality_score);const highSemantic=Number.isFinite(semantic)&&semantic>=0.86;const qualityOk=Number.isFinite(quality)&&quality>=0.62;const mismatchSignals=Boolean(scoring?.single_word_drift)||Boolean(scoring?.closest_interpretation_type_mismatch)||Boolean(scoring?.assumption_clash_generic_token);return highSemantic&&qualityOk&&!mismatchSignals;}
function applySingleWordDriftGuard(decision,scoring){const base=decision&&typeof decision==="object"?decision:{accepted:false,applyToDescription:false,status:"rejected_low_confidence",reasons:[]};if(!Boolean(scoring?.single_word_drift)) return base;if(!base.accepted) return {...base,reasons:[...(Array.isArray(base.reasons)?base.reasons:[]),"single_word_drift"]};if(base.applyToDescription){return {...base,applyToDescription:false,status:"accepted_metadata_only",reasons:[...(Array.isArray(base.reasons)?base.reasons:[]),"single_word_drift_metadata_only",Boolean(scoring?.single_word_drift_warning_signal)?"single_word_drift_warning_signal":""] .filter(Boolean)};}return {...base,reasons:[...(Array.isArray(base.reasons)?base.reasons:[]),"single_word_drift"]};}
function applyWarningAssumptionRiskGuard(decision,scoring){const base=decision&&typeof decision==="object"?decision:{accepted:false,applyToDescription:false,status:"rejected_low_confidence",reasons:[]};const closestMismatch=Boolean(scoring?.closest_interpretation_type_mismatch);const assumptionClash=Boolean(scoring?.assumption_clash_generic_token);if(!closestMismatch&&!assumptionClash) return base;const confidence=String(scoring?.confidence||"low").toLowerCase();const closestLowMedium=closestMismatch&&confidenceRank(confidence)<=confidenceRank("medium");const reasons=[...(Array.isArray(base.reasons)?base.reasons:[])];if(closestMismatch) reasons.push(closestLowMedium?"closest_interpretation_type_mismatch_forced_metadata_only":"closest_interpretation_type_mismatch");if(assumptionClash) reasons.push("assumption_clash_generic_token");if(!base.accepted) return {...base,reasons:[...new Set(reasons)]};if(base.applyToDescription&&(closestLowMedium||assumptionClash)){reasons.push(closestLowMedium?"warning_signal_forced_metadata_only":"assumption_clash_forced_metadata_only");return {...base,applyToDescription:false,status:"accepted_metadata_only",reasons:[...new Set(reasons)]};}return {...base,reasons:[...new Set(reasons)]};}
function applyCompositeTermAppendGuard(decision,scoring,{termLabel="",definition="",chosenInterpretation="",parsed={}}={}){const base=decision&&typeof decision==="object"?decision:{accepted:false,applyToDescription:false,status:"rejected_low_confidence",reasons:[]};if(!isCompositeSyntheticTermLabel(termLabel)) return base;const exactMatch=hasExactConceptPhraseMatch(termLabel,[definition,chosenInterpretation,parsed?.inputInterpretation,parsed?.bestDefinition]);const highAlignment=hasHighAlignmentConceptMatch(scoring);if(exactMatch||highAlignment) return base;if(!base.accepted) return {...base,reasons:[...(Array.isArray(base.reasons)?base.reasons:[]),"composite_term_default_metadata_only"]};if(base.applyToDescription){return {...base,applyToDescription:false,status:"accepted_metadata_only",reasons:[...(Array.isArray(base.reasons)?base.reasons:[]),"composite_term_default_metadata_only"]};}return {...base,reasons:[...(Array.isArray(base.reasons)?base.reasons:[]),"composite_term_default_metadata_only"]};}
function expectedCategoriesForEntityType(entityType=""){const t=String(entityType||"").replace(/([a-z])([A-Z])/g,"$1 $2").toLowerCase();if(!t) return [];if(/given name|surname|family name|forename|first name|last name|personal name|proper name|\bname\b/.test(t)) return ["name_like","person"];if(/airport|airfield/.test(t)) return ["airport","place"];if(/periodical|journal|magazine|newspaper|publication/.test(t)) return ["periodical"];if(/chemical|compound|molecule|drug|protein|gene|enzyme|substance/.test(t)) return ["chemical_compound"];if(/person|people|human|biography/.test(t)) return ["person"];if(/city|country|state|province|county|location|place|geographic/.test(t)) return ["place","airport"];return [];}
function interpretationTypeLooksUnrelated(entityType="",chosenInterpretation="",definition="",parsed={},chosenPod=""){const entityTypeRaw=String(entityType||"").trim();if(!entityTypeRaw) return false;const expected=expectedCategoriesForEntityType(entityTypeRaw);if(!expected.length) return false;const category=classifyWolframResolvedCategory({entityType:"",chosenInterpretation,definition,parsed,chosenPod});if(category&&!expected.includes(category)) return true;const entityTokens=entityTypeRaw.toLowerCase().replace(/([a-z])([A-Z])/g,"$1 $2").split(/[^a-z0-9]+/g).map(x=>x.trim()).filter(Boolean);const blob=[chosenInterpretation,definition,String(parsed?.bestDefinition||""),String(parsed?.inputInterpretation||""),String(chosenPod||"")].join(" ").toLowerCase();const tokenOverlap=entityTokens.filter(tok=>blob.includes(tok)).length;return Boolean(category)&&tokenOverlap===0&&!expected.includes(category);}
function hasSuspiciousDomainMarkerMismatch(termLabel="",chosenInterpretation="",definition="",warnings=[]){if(!isAbstractNameCollisionTarget(termLabel)) return false;const blob=[chosenInterpretation,definition,...(Array.isArray(warnings)?warnings:[])].join(" ").toLowerCase();return /\b(?:airport|runway|terminal|iata|icao|airfield|journal|periodical|publisher|impact factor|issn|molar mass|molecular formula|iupac|cas number|chemical formula|organophosphate|chemical compound|given name|surname|family name|forename|first name|last name|personal name|proper name)\b/i.test(blob);}
function evaluateSuspiciousAcceptedGrounding({termLabel="",entityType="",chosenInterpretation="",definition="",warnings=[],confidence="low",parsed={},chosenPod=""}={}){const reasons=[];if(interpretationTypeLooksUnrelated(entityType,chosenInterpretation,definition,parsed,chosenPod)) reasons.push("suspicious_acceptance_unrelated_interpretation_type");if(isAbstractNameCollisionTarget(termLabel)&&looksNameLikeInterpretation({entityType,chosenInterpretation,definition,parsed,chosenPod})) reasons.push("suspicious_acceptance_name_like_interpretation");const warningText=(Array.isArray(warnings)?warnings:[]).map(x=>String(x||"")).join(" ").toLowerCase();const closestWarning=/(?:closest\s+wolfram\|alpha\s+interpretation|closest\s+interpretation|closest\s+match)/i.test(warningText);if(closestWarning&&confidenceRank(String(confidence||"low").toLowerCase())<=confidenceRank("medium")) reasons.push("suspicious_acceptance_closest_interpretation_low_medium");const labelTokens=[...new Set(labelContentTokens(termLabel))];const interpretationTokens=new Set(labelContentTokens(`${chosenInterpretation||""} ${definition||""}`));const overlapCount=labelTokens.filter(tok=>interpretationTokens.has(tok)).length;if(labelTokens.length>=2&&overlapCount<=1) reasons.push("suspicious_acceptance_low_token_overlap");if(hasSuspiciousDomainMarkerMismatch(termLabel,chosenInterpretation,definition,warnings)) reasons.push("suspicious_acceptance_domain_marker_mismatch");return {suspicious:reasons.length>0,reasons,labelTokenCount:labelTokens.length,overlapCount};}
function applyGroundingCategoryMismatchGuard(decision,gate){
  const base=decision&&typeof decision==="object"?decision:{accepted:false,applyToDescription:false,status:"rejected_low_confidence",reasons:[]};
  const gateReasons=[...(Array.isArray(gate?.reasons)?gate.reasons:[])];
  if(gate?.forceMetadataOnly){
    if(base.accepted){
      return {...base,applyToDescription:false,status:"accepted_metadata_only",reasons:[...(Array.isArray(base.reasons)?base.reasons:[]),...gateReasons]};
    }
    return {...base,reasons:[...(Array.isArray(base.reasons)?base.reasons:[]),...gateReasons]};
  }
  if(!gate?.blocked) return base;
  return {...base,accepted:false,applyToDescription:false,status:"rejected_category_mismatch",reasons:[...(Array.isArray(base.reasons)?base.reasons:[]),...gateReasons]};
}
function safeConfigForRun(cfg){return {
  mode:cfg.mode,
  researchModel:cfg.researchModel,
  embeddingModel:cfg.embeddingModel,
  qualityMode:cfg.qualityMode,
  webSearch:Boolean(cfg.webSearch),
  sourcePolicy:cfg.sourcePolicy||"",
  redTeam:Boolean(cfg.redTeam),
  replicationModels:cfg.replicationModels||"",
  replicationRuns:clampInt(cfg.replicationRuns||1,1,5),
  replicationStrategy:cfg.replicationStrategy||"fixed",
  wolframEntityGrounding:Boolean(cfg.wolframEntityGrounding),
  wolframAppIdPresent:Boolean(cfg.wolframAppId),
  groundingMode:normalizeGroundingAggressiveness(cfg.groundingMode),
  groundingMinSnippetScore:(cfg.groundingMinSnippetScore===null||cfg.groundingMinSnippetScore===undefined||String(cfg.groundingMinSnippetScore).trim()==="")?null:clampGroundingSnippetScore(cfg.groundingMinSnippetScore,0.58),
  groundingMinAlignmentScore:(cfg.groundingMinAlignmentScore===null||cfg.groundingMinAlignmentScore===undefined||String(cfg.groundingMinAlignmentScore).trim()==="")?null:clampGroundingSnippetScore(cfg.groundingMinAlignmentScore,0.55),
  groundingAnnotateOnly:Boolean(cfg.groundingAnnotateOnly),
  allowGroundingCategoryMismatch:Boolean(cfg.allowGroundingCategoryMismatch),
  enableComputationalIrreducibility:Boolean(cfg.enableComputationalIrreducibility),
  caRule:clampInt(cfg.caRule||30,0,255),
  caSteps:clampInt(cfg.caSteps||96,16,240),
  caWidth:clampInt(cfg.caWidth||151,31,401),
  promptTemplateOverrides:structuredCloneSafe(PROMPT_TEMPLATE_OVERRIDES),
  promptIntent:String(cfg.promptIntent||"").trim(),
  promptLensEmphasis:String(cfg.promptLensEmphasis||"").trim(),
  promptHardConstraints:String(cfg.promptHardConstraints||"").trim(),
  promptOutputStyle:String(cfg.promptOutputStyle||"").trim(),
  promptArtifactFocus:String(cfg.promptArtifactFocus||"").trim()
};}
function computeRunId(payload){return `run_${hashString(JSON.stringify(payload))}`;}
function recordCall(entry){const payload={runId:CURRENT_RUN_ID||null,timestamp:entry?.timestamp||new Date().toISOString(),...entry};CALL_LOGS.push(payload);}
function normalizeWolframCacheStatus(value){
  const raw=String(value||"").trim().toLowerCase();
  if(!raw) return "unknown";
  if(raw==="hit"||raw==="miss") return `proxy_${raw}`;
  if(raw.includes("memory")) return raw;
  if(raw.includes("proxy")) return raw;
  return raw;
}
function recordWolframAuditEvent(entry){
  const cacheStatus=normalizeWolframCacheStatus(entry?.cacheStatus);
  const durationMs=Number(entry?.durationMs);
  const statusCode=Number(entry?.statusCode);
  const assumptionsCount=Number(entry?.assumptionsCount);
  const snippetScore=Number(entry?.snippetScore);
  const appliedFlag=typeof entry?.appliedToDescription==="boolean"?entry.appliedToDescription:null;
  const successFlag=typeof entry?.success==="boolean"?entry.success:(String(entry?.status||"").toLowerCase()!=="error");
  recordCall({
    kind:"wolfram_query",
    stage:String(entry?.stage||"").trim()||"decision",
    query:String(entry?.query||"").trim(),
    mode:String(entry?.mode||"").trim()||"proxy",
    duration_ms:Number.isFinite(durationMs)?Math.max(0,Math.round(durationMs)):null,
    status_code:Number.isFinite(statusCode)?Math.max(0,Math.round(statusCode)):null,
    success:Boolean(successFlag),
    assumptions_count:Number.isFinite(assumptionsCount)?Math.max(0,Math.round(assumptionsCount)):0,
    chosen_pod:String(entry?.chosenPod||"").trim(),
    snippet_score:Number.isFinite(snippetScore)?Math.max(0,Math.min(1,snippetScore)):null,
    applied_to_description:appliedFlag,
    cache:cacheStatus,
    target:String(entry?.target||"").trim(),
    discName:String(entry?.discName||"").trim(),
    termLabel:String(entry?.termLabel||"").trim(),
    attempt_rank:Number.isFinite(Number(entry?.attemptRank))?Number(entry.attemptRank):null,
    attempt_strategy:String(entry?.attemptStrategy||"").trim(),
    resolution_label:String(entry?.resolutionLabel||"").trim(),
    status:String(entry?.status||"").trim(),
    confidence:String(entry?.confidence||"").trim(),
    reasons:Array.isArray(entry?.reasons)?entry.reasons.map(r=>String(r||"").trim()).filter(Boolean):[],
    note:String(entry?.note||"").trim()
  });
}
function getQualityProfile(mode){const key=(mode||"").toLowerCase();return QUALITY_PROFILES[key]||QUALITY_PROFILES.balanced;}
function withArtifactTokenBudget(cfg,{minTokens=2800,multiplier=2,maxTokens=12000}={}){const base=getQualityProfile(cfg?.qualityMode).maxTokens;const requested=Math.max(minTokens,Math.round(base*multiplier));return {...cfg,__maxTokens:clampInt(requested,128,maxTokens)};}
function readApiConfig(){return {
  mode:document.getElementById("api-mode").value,
  apiKey:document.getElementById("api-key-input").value.trim(),
  researchModel:document.getElementById("research-model-input").value.trim(),
  embeddingModel:document.getElementById("embedding-model-input").value.trim(),
  webSearch:Boolean(document.getElementById("web-search-check")?.checked),
  qualityMode:document.getElementById("quality-mode-select")?.value||"balanced",
  sourcePolicy:document.getElementById("source-policy-input")?.value.trim()||"",
  redTeam:Boolean(document.getElementById("redteam-check")?.checked),
  replicationModels:document.getElementById("replication-models-input")?.value.trim()||"",
  replicationRuns:clampInt(document.getElementById("replication-runs-input")?.value||1,1,5),
  replicationStrategy:document.getElementById("replication-strategy-select")?.value||"fixed",
  wolframEntityGrounding:Boolean(document.getElementById("wolfram-grounding-check")?.checked),
  wolframAppId:document.getElementById("wolfram-appid-input")?.value.trim()||"",
  groundingMode:normalizeGroundingAggressiveness(document.getElementById("grounding-mode-select")?.value||"balanced"),
  groundingMinSnippetScore:parseGroundingSnippetScoreInput(document.getElementById("grounding-min-score-input")?.value),
  groundingMinAlignmentScore:parseGroundingSnippetScoreInput(document.getElementById("grounding-min-alignment-score-input")?.value),
  groundingAnnotateOnly:Boolean(document.getElementById("grounding-annotate-only-check")?.checked),
  allowGroundingCategoryMismatch:Boolean(document.getElementById("grounding-allow-category-mismatch-check")?.checked),
  enableComputationalIrreducibility:Boolean(document.getElementById("ca-probe-check")?.checked),
  caRule:clampInt(document.getElementById("ca-rule-input")?.value||30,0,255),
  caSteps:clampInt(document.getElementById("ca-steps-input")?.value||96,16,240),
  caWidth:clampInt(document.getElementById("ca-width-input")?.value||151,31,401),
  promptTemplateOverrides:structuredCloneSafe(PROMPT_TEMPLATE_OVERRIDES),
  promptIntent:document.getElementById("prompt-intent-input")?.value.trim()||"",
  promptLensEmphasis:document.getElementById("prompt-lens-emphasis-input")?.value.trim()||"",
  promptHardConstraints:document.getElementById("prompt-hard-constraints-input")?.value.trim()||"",
  promptOutputStyle:document.getElementById("prompt-output-style-input")?.value.trim()||"",
  promptArtifactFocus:document.getElementById("prompt-artifact-focus-input")?.value.trim()||""
};}
function normalizeMode(cfg){return cfg?.mode==="proxy"?"proxy":"direct";}
function validateApiConfig(cfg){if(!cfg.researchModel) return "Please enter a research model id.";if(!cfg.embeddingModel) return "Please enter an embedding model id.";if(normalizeMode(cfg)==="direct"&&!cfg.apiKey) return "Please enter an API key for direct mode.";if(normalizeMode(cfg)==="direct"&&cfg.apiKey&&!cfg.apiKey.startsWith("sk-or-")) return "Expected an OpenRouter key (starts with sk-or-).";if(cfg.wolframEntityGrounding&&normalizeMode(cfg)!=="proxy") return "Wolfram entity grounding requires proxy mode (CORS blocks browser-direct calls).";if(cfg.wolframEntityGrounding&&!cfg.wolframAppId) return "Please enter a Wolfram AppID to enable entity grounding.";if(cfg.groundingMinSnippetScore!==null&&(!Number.isFinite(Number(cfg.groundingMinSnippetScore))||Number(cfg.groundingMinSnippetScore)<0||Number(cfg.groundingMinSnippetScore)>1)) return "Grounding min snippet quality must be between 0 and 1.";if(cfg.groundingMinAlignmentScore!==null&&(!Number.isFinite(Number(cfg.groundingMinAlignmentScore))||Number(cfg.groundingMinAlignmentScore)<0||Number(cfg.groundingMinAlignmentScore)>1)) return "Grounding min semantic alignment must be between 0 and 1.";return "";}
function sanitizePromptMadLib(value,maxLen=420){const txt=String(value||"").replace(/\s+/g," ").trim();return txt.length>maxLen?`${txt.slice(0,maxLen-3)}...`:txt;}
function buildPromptMadLibNotes(cfg,{includeArtifact=true}={}){
  const notes=[];
  if(cfg?.promptIntent) notes.push(`Run intent: ${sanitizePromptMadLib(cfg.promptIntent)}`);
  if(cfg?.promptLensEmphasis) notes.push(`Analytic emphasis: ${sanitizePromptMadLib(cfg.promptLensEmphasis)}`);
  if(cfg?.promptHardConstraints) notes.push(`Hard constraints: ${sanitizePromptMadLib(cfg.promptHardConstraints,560)}`);
  if(cfg?.promptOutputStyle) notes.push(`Output style: ${sanitizePromptMadLib(cfg.promptOutputStyle)}`);
  if(includeArtifact&&cfg?.promptArtifactFocus) notes.push(`Artifact focus: ${sanitizePromptMadLib(cfg.promptArtifactFocus)}`);
  return notes;
}
function appendPromptMadLibBlock(base,cfg,{includeArtifact=true}={}){
  const notes=buildPromptMadLibNotes(cfg,{includeArtifact});
  if(!notes.length) return base;
  return `${String(base||"").trim()}\n\nPrompt controls:\n- ${notes.join("\n- ")}`;
}
function endpointFor(kind,cfg){const modeCfg=API_ENDPOINTS[normalizeMode(cfg)]||API_ENDPOINTS.direct;return modeCfg[kind];}
async function providerFetch(kind,body,cfg){const headers={"Content-Type":"application/json"};const mode=normalizeMode(cfg);if(cfg.apiKey){headers["Authorization"]=`Bearer ${cfg.apiKey}`;}if(mode==="direct"){headers["HTTP-Referer"]=location.origin&&location.origin!=="null"?location.origin:"https://ruliad-expedition.local";headers["X-Title"]="Ruliad Expedition Tool";}const response=await fetch(endpointFor(kind,cfg),{method:"POST",headers,body:JSON.stringify(body)});if(!response.ok){const raw=(await response.text()).slice(0,500);if(response.status===401&&raw.includes("No cookie auth credentials found")){throw new Error(`${kind} request failed (401): OpenRouter did not receive Authorization. Paste a valid OpenRouter key (sk-or-...), keep mode = direct, and if this page is opened as file:// run it via localhost instead. Raw: ${raw}`);}throw new Error(`${kind} request failed (${response.status}): ${raw}`);}return response.json();}
function flattenContent(content){if(typeof content==="string") return content;if(Array.isArray(content)){return content.map(part=>{if(typeof part==="string") return part;if(part&&typeof part.text==="string") return part.text;return "";}).join("\n");}return "";}
async function callLLMFull(systemPrompt,userPrompt,cfg){const quality=getQualityProfile(cfg.qualityMode);const requestedMax=Number(cfg?.__maxTokens??cfg?.maxTokens);const resolvedMax=Number.isFinite(requestedMax)?clampInt(requestedMax,128,12000):quality.maxTokens;const body={model:cfg.researchModel,max_tokens:resolvedMax,temperature:Number.isFinite(Number(cfg.__tempOverride))?Number(cfg.__tempOverride):quality.temperature,messages:[{role:"system",content:systemPrompt},{role:"user",content:userPrompt}]};if(cfg.webSearch){body.plugins=[{id:"web"}];}if(Boolean(cfg?.__jsonMode)){body.response_format={type:"json_object"};}const startedAt=new Date().toISOString();let data=null;try{data=await providerFetch("chat",body,cfg);}catch(err){const msg=String(err?.message||err||"");if(body.response_format&&/response[_\s-]?format|unsupported|not supported|invalid request|unknown parameter/i.test(msg)){delete body.response_format;data=await providerFetch("chat",body,cfg);}else{throw err;}}const text=flattenContent(data.choices?.[0]?.message?.content);recordCall({kind:"chat",timestamp:startedAt,model:body.model,temperature:body.temperature,max_tokens:body.max_tokens,webSearch:Boolean(cfg.webSearch),jsonMode:Boolean(cfg?.__jsonMode),systemPrompt,userPrompt,request:body,response:data});if(!text) throw new Error("Model returned no text content.");return {text,raw:data,request:body};}
async function callLLM(systemPrompt,userPrompt,cfg){const out=await callLLMFull(systemPrompt,userPrompt,cfg);return out.text;}
async function callLLMJSON(systemPrompt,userPrompt,cfg){return callLLM(systemPrompt,userPrompt,{...(cfg||{}),__jsonMode:true});}
async function callEmbeddings(inputs,cfg,onBatch){const quality=getQualityProfile(cfg.qualityMode);const batchSize=quality.embedBatchSize;const out=[];const totalBatches=Math.max(1,Math.ceil(inputs.length/batchSize));for(let i=0;i<inputs.length;i+=batchSize){const batchNo=Math.floor(i/batchSize)+1;if(onBatch) onBatch(batchNo,totalBatches);const chunk=inputs.slice(i,i+batchSize);const body={model:cfg.embeddingModel,input:chunk,encoding_format:"float"};const startedAt=new Date().toISOString();const data=await providerFetch("embeddings",body,cfg);const vectors=(data.data||[]).map(row=>row.embedding).filter(v=>Array.isArray(v));if(vectors.length!==chunk.length){throw new Error(`Embedding batch mismatch (${vectors.length}/${chunk.length}).`);}recordCall({kind:"embeddings",timestamp:startedAt,model:cfg.embeddingModel,batch:batchNo,totalBatches,input_count:chunk.length,vector_dimensions:Array.isArray(vectors[0])?vectors[0].length:null,request:{model:cfg.embeddingModel,encoding_format:"float",input_count:chunk.length},response_meta:{object:String(data?.object||""),usage:data?.usage||null,data_count:Array.isArray(data?.data)?data.data.length:0}});out.push(...vectors);}return out;}
function stripJsonCodeFences(text){const src=String(text||"");const matches=[...src.matchAll(/```(?:[a-z0-9_-]+)?\s*([\s\S]*?)```/ig)].map(m=>String(m?.[1]||"").trim()).filter(Boolean);if(!matches.length) return src;const preferred=[...matches].sort((a,b)=>b.length-a.length).find(chunk=>/[{\[]/.test(chunk));return preferred||matches[0]||src;}
function findBalancedJsonCandidates(text){const src=String(text||"");const out=[];const stack=[];let start=-1;let quote="";let escape=false;for(let i=0;i<src.length;i++){const ch=src[i];if(escape){escape=false;continue;}if(quote){if(ch==="\\"){escape=true;continue;}if(ch===quote){quote="";}continue;}if(ch==="\""||ch==="'"){quote=ch;continue;}if(ch==="{"||ch==="["){if(stack.length===0) start=i;stack.push(ch);continue;}if(ch==="}"||ch==="]"){if(!stack.length) continue;const top=stack[stack.length-1];const ok=(top==="{"&&ch==="}")||(top==="["&&ch==="]");if(!ok){stack.length=0;start=-1;continue;}stack.pop();if(stack.length===0&&start!==-1){const piece=src.slice(start,i+1).trim();if(piece) out.push(piece);start=-1;}}}return out;}
function escapeNewlinesInsideJsonStrings(text){const src=String(text||"");let out="";let quote="";let escape=false;for(let i=0;i<src.length;i++){const ch=src[i];if(escape){out+=ch;escape=false;continue;}if(quote){if(ch==="\\"){out+=ch;escape=true;continue;}if(ch===quote){out+=ch;quote="";continue;}if(ch==="\r") continue;if(ch==="\n"){out+="\\n";continue;}out+=ch;continue;}if(ch==="\""||ch==="'"){quote=ch;out+=ch;continue;}out+=ch;}return out;}
function sanitizeJsonCandidate(text){let out=String(text||"").trim();out=out.replace(/^\uFEFF/,"").replace(/[\u201C\u201D]/g,"\"").replace(/[\u2018\u2019]/g,"'");out=out.replace(/\/\*[\s\S]*?\*\//g,"").replace(/^\s*\/\/.*$/gm,"");out=escapeNewlinesInsideJsonStrings(out);out=out.replace(/,\s*([}\]])/g,"$1").replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F]/g," ");return out.trim();}
function buildJsonParseCandidates(text){const raw=String(text||"");const stripped=stripJsonCodeFences(raw);const out=[];const push=(value)=>{const val=String(value||"").trim();if(!val) return;if(!out.includes(val)) out.push(val);};for(const variant of [raw,stripped]){push(variant);const firstObj=variant.indexOf("{");const lastObj=variant.lastIndexOf("}");if(firstObj!==-1&&lastObj!==-1&&lastObj>firstObj) push(variant.slice(firstObj,lastObj+1));const firstArr=variant.indexOf("[");const lastArr=variant.lastIndexOf("]");if(firstArr!==-1&&lastArr!==-1&&lastArr>firstArr) push(variant.slice(firstArr,lastArr+1));for(const chunk of findBalancedJsonCandidates(variant)){push(chunk);}}for(const candidate of [...out]){push(sanitizeJsonCandidate(candidate));}return out.sort((a,b)=>b.length-a.length);}
function parseJsonFromModelText(text){const candidates=buildJsonParseCandidates(text);let lastErr=null;for(const candidate of candidates){try{return JSON.parse(candidate);}catch(err){lastErr=err;}}throw new Error(`Could not parse JSON from model response${lastErr?`: ${lastErr.message||lastErr}`:"."}`);}
function extractJSON(text){if(typeof text!=="string") throw new Error("Expected model response text.");return parseJsonFromModelText(text);}
function extractJSONLenient(text){if(typeof text!=="string") throw new Error("Expected model response text.");return parseJsonFromModelText(text);}
async function repairJSONWithModel(rawText,contextLabel,cfg){const repairSystem="You repair malformed JSON. Return only valid JSON.";const repairPrompt=`Task context: ${contextLabel}\n\nRepair the malformed JSON below. Preserve meaning and fields. Do not add markdown.\nReturn strict JSON only.\nExpected top-level object keys: summary, terms, claims_or_findings, citations, confidence_notes.\n\nMalformed text:\n${String(rawText||"").slice(0,24000)}`;return callLLMJSON(repairSystem,repairPrompt,{...cfg,__tempOverride:0,maxTokens:Math.max(900,Math.floor(getQualityProfile(cfg.qualityMode).maxTokens*0.9))});}
function buildProbeCompactFallbackPrompt(target,discName){return `Generate strict JSON only for this research probe.\n\nTopic: "${target}"\nDiscipline: "${discName}"\n\nReturn exactly:\n{\n  "summary": "2-3 concise sentences",\n  "terms": [\n    {"label":"term","centrality":0.7,"description":"one-sentence definition"}\n  ],\n  "claims_or_findings": ["claim"],\n  "citations": [],\n  "confidence_notes": "brief limits"\n}\n\nRules:\n- 6-8 terms\n- 3-4 claims_or_findings\n- citations must be []\n- no markdown, no prose before/after JSON`; }
function decodeLooseJsonString(value){return String(value||"").replace(/\\"/g,"\"").replace(/\\\\/g,"\\").replace(/\\n/g," ").replace(/\s+/g," ").trim();}
function extractLooseJsonFieldValues(raw,field,maxItems=12){const src=String(raw||"");const safeField=String(field||"").replace(/[.*+?^${}()|[\]\\]/g,"\\$&");const re=new RegExp(`"${safeField}"\\s*:\\s*"((?:\\\\.|[^"\\\\])*)"`,`gi`);const out=[];let match=null;while((match=re.exec(src))&&out.length<maxItems){const val=decodeLooseJsonString(match[1]);if(val&&!out.includes(val)) out.push(val);}return out;}
function buildProbeRescueResult({target,discName,rawTexts=[],parseAttempts=[]}={}){const allRaw=(Array.isArray(rawTexts)?rawTexts:[rawTexts]).map(x=>String(x||"")).filter(Boolean);const merged=allRaw.join("\n\n");const cleaned=stripJsonCodeFences(merged).replace(/```+/g," ").replace(/\s+/g," ").trim();const summaryPrefix=`Fallback parse recovery for ${String(discName||"this probe").trim()}`;const summaryBody=cleaned?`${cleaned.slice(0,260)}${cleaned.length>260?"...":""}`:"model output was not valid JSON after retries";const labels=extractLooseJsonFieldValues(merged,"label",10).filter(x=>x.length>=2&&x.length<=120);const descriptions=extractLooseJsonFieldValues(merged,"description",12);const claims=extractLooseJsonFieldValues(merged,"claim",6);const targetLabel=String(target||"Topic").trim()||"Topic";const discLabel=String(discName||"Lens").trim()||"Lens";const defaultLabels=[`${targetLabel} framing`,`${discLabel} constraints`,`${discLabel} dynamics`,`${discLabel} trade-offs`,`${discLabel} risk surface`,`${discLabel} adaptation pathways`].map(x=>x.replace(/\s+/g," ").trim());const chosenLabels=[...new Set([...(labels.length?labels:[]),...defaultLabels])].slice(0,8);const terms=chosenLabels.map((label,idx)=>({label,centrality:Math.max(0.42,0.86-idx*0.06),description:descriptions[idx]||`Recovered fallback term from ${discLabel} parse failure; verify manually.`}));const claimLines=(claims.length?claims:[`Parser fallback used for ${discLabel}; validate this lens manually.`]).slice(0,4);const confidenceNotes=`Structured JSON parse failed across retries. ${parseAttempts.slice(0,4).join(" | ")||"No parse diagnostics captured."}`;return normalizeProbeResult({summary:`${summaryPrefix}: ${summaryBody}`,terms,claims_or_findings:claimLines,citations:[],confidence_notes:confidenceNotes});}
async function getProbeResultWithRecovery({target,discName,probeSystem,userMsg,cfg}){const parseAttempts=[];const rawSamples=[];const parseTry=(label,text)=>{try{return extractJSON(text);}catch(err1){try{return extractJSONLenient(text);}catch(err2){parseAttempts.push(`${label}: ${err1.message||err1}; lenient: ${err2.message||err2}`);return null;}}};const raw1=await callLLMJSON(probeSystem,userMsg,cfg);rawSamples.push(raw1);const parsed1=parseTry("initial",raw1);if(parsed1) return normalizeProbeResult(parsed1);try{const repaired=await repairJSONWithModel(raw1,`Probe ${discName} on ${target}`,cfg);rawSamples.push(repaired);const parsedRepair=parseTry("repair",repaired);if(parsedRepair) return normalizeProbeResult(parsedRepair);}catch(err){parseAttempts.push(`repair call failed: ${err.message||err}`);}const retryCfg={...cfg,__tempOverride:Math.max(0,Number(getQualityProfile(cfg.qualityMode).temperature||0.15)-0.08)};const raw2=await callLLMJSON(probeSystem,userMsg,retryCfg);rawSamples.push(raw2);const parsed2=parseTry("retry",raw2);if(parsed2) return normalizeProbeResult(parsed2);try{const repaired2=await repairJSONWithModel(raw2,`Probe retry ${discName} on ${target}`,cfg);rawSamples.push(repaired2);const parsedRepair2=parseTry("retry-repair",repaired2);if(parsedRepair2) return normalizeProbeResult(parsedRepair2);}catch(err){parseAttempts.push(`retry-repair call failed: ${err.message||err}`);}try{const fallbackPrompt=buildProbeCompactFallbackPrompt(target,discName);const fallbackRaw=await callLLMJSON("You are a research expert. Return strict valid JSON only.",fallbackPrompt,{...cfg,__tempOverride:0,maxTokens:Math.min(getQualityProfile(cfg.qualityMode).maxTokens,1200)});rawSamples.push(fallbackRaw);const parsedFallback=parseTry("compact-fallback",fallbackRaw);if(parsedFallback){const norm=normalizeProbeResult(parsedFallback);if(norm.summary&&norm.terms?.length) return norm;}}catch(err){parseAttempts.push(`compact-fallback call failed: ${err.message||err}`);}const rescue=buildProbeRescueResult({target,discName,rawTexts:rawSamples,parseAttempts});console.warn(`Probe ${discName} JSON parse failed; using fallback recovery.`,parseAttempts);return rescue;}
function buildProbeSystemPrompt(cfg={}){const base="You are a research expert. Respond only with valid JSON.";const notes=buildPromptMadLibNotes(cfg,{includeArtifact:false});if(!notes.length) return base;return `${base}\n${notes.map(line=>`- ${line}`).join("\n")}`;}
function buildProbeUserPrompt(target,discName,quality,cfg){
  const sourcePolicy=cfg.sourcePolicy?`Source policy: ${cfg.sourcePolicy}\n\n`:"";
  const intentBlock=cfg?.promptIntent?`Run intent: ${sanitizePromptMadLib(cfg.promptIntent)}\n\n`:"";
  const emphasisBlock=cfg?.promptLensEmphasis?`Analytic emphasis: ${sanitizePromptMadLib(cfg.promptLensEmphasis)}\n\n`:"";
  const styleBlock=cfg?.promptOutputStyle?`Output style: ${sanitizePromptMadLib(cfg.promptOutputStyle)}\n\n`:"";
  const hardConstraintRule=cfg?.promptHardConstraints?`\n- Additional hard constraints: ${sanitizePromptMadLib(cfg.promptHardConstraints,560)}`:"";
  const entityField=cfg.wolframEntityGrounding?`, "wolfram_entity": {"type": "Entity domain (e.g. MedicalCondition, Chemical, AnatomicalStructure)", "id_or_name": "canonical Wolfram id/name", "query": "Entity[...] or other Wolfram query string"}`:"";
  const entityRules=cfg.wolframEntityGrounding?`\n- For every term include wolfram_entity with your best canonical Wolfram entity candidate\n- Prefer precise scientific entities over broad labels\n- If uncertain, still provide a best-effort query string in wolfram_entity.query`:"";
  return `Research the concept of "${target}" from the perspective of ${discName}.\n\n${intentBlock}${emphasisBlock}${styleBlock}${sourcePolicy}Return a JSON object with this exact structure:\n{\n  "summary": "2-3 sentence summary of how this field understands ${target}",\n  "terms": [\n    {"label": "key term or concept", "centrality": 0.9, "description": "one-sentence definition in context of ${target}"${entityField}}\n  ],\n  "claims_or_findings": ["concise finding or claim"],\n  "citations": [\n    {\n      "url": "https://...",\n      "title": "source title",\n      "publisher": "publisher or outlet",\n      "date": "YYYY-MM-DD or YYYY",\n      "quote_or_snippet": "short quote or paraphrase (<=25 words if quote)",\n      "relevance": "why this supports a claim or term",\n      "source_type": "peer-reviewed|preprint|gov/ngo|major journalism|blog/opinion|social|reference|computational|api|wolfram",\n      "supporting_terms": ["term label 1", "term label 2"]\n    }\n  ],\n  "confidence_notes": "brief notes on uncertainty and limits"\n}\n\nRules:\n- Include ${quality.probeTermMin}-${quality.probeTermMax} terms directly relevant to "${target}" as understood by ${discName}\n- "centrality" is 0.0-1.0, where 1.0 means absolutely central\n- Provide 3-6 claims_or_findings\n- If web grounding is OFF, return an empty citations array and note limitations in confidence_notes\n- Keep citations concise; do not fabricate URLs${entityRules}${hardConstraintRule}\n- Respond with only the JSON object`;
}
const SOURCE_TYPE_LABELS={
  "peer-reviewed":"Peer-reviewed",
  "preprint":"Preprint",
  "gov/ngo":"Government/NGO",
  "major journalism":"Major journalism",
  "blog/opinion":"Blog/opinion",
  "social":"Social",
  "reference":"Reference",
  "computational":"Computational",
  "api":"API",
  "wolfram":"Wolfram|Alpha (reference)",
  "untyped":"Untyped"
};
function normalizeSourceType(value,publisher){
  const publisherText=String(publisher||"").trim().toLowerCase();
  if(/wolfram/.test(publisherText)) return "wolfram";
  const raw=String(value||"").trim().toLowerCase();
  if(!raw) return "";
  const norm=raw.replace(/_/g," ").replace(/\s+/g," ").trim();
  if(/wolfram/.test(norm)) return "wolfram";
  if(norm==="peer reviewed"||norm==="peer-review"||norm==="peer review") return "peer-reviewed";
  if(norm==="major journalistic") return "major journalism";
  if(norm==="blog"||norm==="opinion") return "blog/opinion";
  if(norm==="gov"||norm==="government"||norm==="ngo"||norm==="nonprofit") return "gov/ngo";
  if(norm in SOURCE_TYPE_LABELS) return norm;
  return "reference";
}
function sourceTypeLabel(sourceType,publisher){
  const key=normalizeSourceType(sourceType,publisher)||"untyped";
  return SOURCE_TYPE_LABELS[key]||SOURCE_TYPE_LABELS.reference;
}
function normalizeAliasMappingEntry(item){if(!item||typeof item!=="object") return null;const supportingTerm=String(item.supporting_term||item.from||"").trim();const mappedTerm=String(item.mapped_term||item.to||"").trim();const viaAlias=String(item.via_alias||item.alias||"").trim();const strategy=String(item.strategy||"").trim()||"unknown";const confidence=Number(item.confidence);if(!supportingTerm||!mappedTerm) return null;return {supporting_term:supportingTerm,mapped_term:mappedTerm,via_alias:viaAlias||mappedTerm,strategy,confidence:Number.isFinite(confidence)?Math.max(0,Math.min(1,confidence)):null};}
function normalizeCitation(item){
  const publisher=String(item?.publisher||"").trim();
  const supportingTerms=Array.isArray(item?.supporting_terms)?item.supporting_terms.map(t=>String(t||"").trim()).filter(Boolean):[];
  const supportingTermsRaw=Array.isArray(item?.supporting_terms_raw)?item.supporting_terms_raw.map(t=>String(t||"").trim()).filter(Boolean):supportingTerms.slice();
  const mappings=Array.isArray(item?.supporting_term_mappings)?item.supporting_term_mappings.map(normalizeAliasMappingEntry).filter(Boolean):[];
  const unmapped=Array.isArray(item?.unmapped_supporting_terms)?item.unmapped_supporting_terms.map(t=>String(t||"").trim()).filter(Boolean):[];
  return {
    url:String(item?.url||"").trim(),
    title:String(item?.title||"").trim(),
    publisher,
    date:String(item?.date||"").trim(),
    quote_or_snippet:String(item?.quote_or_snippet||"").trim(),
    relevance:String(item?.relevance||"").trim(),
    source_type:normalizeSourceType(item?.source_type,publisher),
    supporting_terms:supportingTerms,
    supporting_terms_raw:supportingTermsRaw,
    supporting_term_mappings:mappings,
    unmapped_supporting_terms:unmapped,
    grounding_status:String(item?.grounding_status||"").trim(),
    grounding_confidence:String(item?.grounding_confidence||"").trim(),
    grounding_score:Number.isFinite(Number(item?.grounding_score))?Number(item.grounding_score):null,
    grounding_reasons:Array.isArray(item?.grounding_reasons)?item.grounding_reasons.map(r=>String(r||"").trim()).filter(Boolean):[],
    wolfram_input_interpretation:String(item?.wolfram_input_interpretation||"").trim(),
    wolfram_best_definition:String(item?.wolfram_best_definition||"").trim(),
    wolfram_alt_facts:Array.isArray(item?.wolfram_alt_facts)?item.wolfram_alt_facts.map(x=>String(x||"").trim()).filter(Boolean):[],
    wolfram_assumptions:Array.isArray(item?.wolfram_assumptions)?item.wolfram_assumptions.map(x=>normalizeWolframAssumptionText(x,{})).filter(Boolean):[],
    wolfram_did_you_means:Array.isArray(item?.wolfram_did_you_means)?item.wolfram_did_you_means.map(x=>String(x||"").trim()).filter(Boolean):[],
    wolfram_warnings:Array.isArray(item?.wolfram_warnings)?item.wolfram_warnings.map(x=>String(x||"").trim()).filter(Boolean):[]
  };
}
function dedupeCasefold(values,maxItems=40){const out=[];const seen=new Set();for(const raw of (values||[])){const value=String(raw||"").trim();if(!value) continue;const key=value.toLowerCase();if(seen.has(key)) continue;seen.add(key);out.push(value);if(out.length>=maxItems) break;}return out;}
function confidenceRank(level){const v=String(level||"").trim().toLowerCase();if(v==="high") return 3;if(v==="medium") return 2;if(v==="low") return 1;return 0;}
function normalizeConfidenceLevel(level){const v=String(level||"").trim().toLowerCase();if(v==="high"||v==="medium"||v==="low") return v;return "none";}
function betterConfidence(a,b){const left=normalizeConfidenceLevel(a);const right=normalizeConfidenceLevel(b);return confidenceRank(right)>confidenceRank(left)?right:left;}
function buildWolframEntityRef(entity){if(!entity||typeof entity!=="object") return "";const type=String(entity.type||"").trim();const idOrName=String(entity.idOrName||entity.id_or_name||entity.id||entity.name||"").trim();if(type&&idOrName) return `${type}:${idOrName}`;if(idOrName) return idOrName;if(type) return type;return String(entity.query||"").trim();}
const GROUNDING_ELIGIBILITY_VALUES=new Set(["eligible","synthetic_local","skipped_budget","ca_bypassed","missing_api"]);
function normalizeGroundingEligibility(value){const v=String(value||"").trim().toLowerCase();if(GROUNDING_ELIGIBILITY_VALUES.has(v)) return v;return "eligible";}
function defaultGroundingBlock(){return {wolframQueriesTried:[],wolframInterpretations:[],wolframEntities:[],wolframConfidence:{level:"none",score:null},groundingStatus:"not_attempted",wolframResolution:"",wolframChosenInterpretation:"",groundingEligibility:"eligible",groundingSkipReason:""};}
function normalizeGroundingStatus(status){const s=String(status||"").trim().toLowerCase();if(s==="grounded"||s==="partial"||s==="failed"||s==="not_attempted") return s;return "not_attempted";}
function normalizeGroundingBlock(block,{entityRef="",defaultStatus="not_attempted"}={}){const raw=block&&typeof block==="object"?block:{};const confObj=raw.wolframConfidence&&typeof raw.wolframConfidence==="object"?raw.wolframConfidence:{};const confLevel=normalizeConfidenceLevel(confObj.level||raw.wolframConfidenceLevel||raw.grounding_confidence||"none");const confScore=Number.isFinite(Number(confObj.score))?Number(confObj.score):Number.isFinite(Number(raw.grounding_score))?Number(raw.grounding_score):null;const legacyOutcome=String(raw.termOutcome||raw.term_outcome||"").trim().toLowerCase();const fallbackEligibility=legacyOutcome==="local_defined"?"synthetic_local":"";const out={wolframQueriesTried:dedupeCasefold(raw.wolframQueriesTried||raw.wolfram_queries_tried||[]),wolframInterpretations:dedupeCasefold(raw.wolframInterpretations||raw.wolfram_interpretations||[]),wolframEntities:dedupeCasefold([...(raw.wolframEntities||raw.wolfram_entities||[]),entityRef]),wolframConfidence:{level:confLevel,score:confScore},groundingStatus:normalizeGroundingStatus(raw.groundingStatus||raw.grounding_status||defaultStatus),wolframResolution:String(raw.wolframResolution||raw.wolfram_resolution||"").trim(),wolframChosenInterpretation:String(raw.wolframChosenInterpretation||raw.wolfram_chosen_interpretation||"").trim(),groundingEligibility:normalizeGroundingEligibility(raw.groundingEligibility||raw.grounding_eligibility||fallbackEligibility),groundingSkipReason:String(raw.groundingSkipReason||raw.grounding_skip_reason||"").trim()};if(out.groundingStatus==="not_attempted"&&out.wolframQueriesTried.length){out.groundingStatus="failed";}if(out.groundingStatus!=="not_attempted"){out.groundingEligibility="eligible";out.groundingSkipReason="";}return out;}
function mergeGroundingBlocks(left,right){const a=normalizeGroundingBlock(left||{});const b=normalizeGroundingBlock(right||{});const statuses=[a.groundingStatus,b.groundingStatus];let status="not_attempted";if(statuses.includes("grounded")) status="grounded";else if(statuses.includes("partial")) status="partial";else if(statuses.includes("failed")) status="failed";const level=betterConfidence(a.wolframConfidence?.level,b.wolframConfidence?.level);const scoreA=Number.isFinite(Number(a.wolframConfidence?.score))?Number(a.wolframConfidence.score):null;const scoreB=Number.isFinite(Number(b.wolframConfidence?.score))?Number(b.wolframConfidence.score):null;const score=scoreA!==null&&scoreB!==null?Math.max(scoreA,scoreB):(scoreA!==null?scoreA:scoreB);const resolution=(a.wolframResolution&&b.wolframResolution&&a.wolframResolution!==b.wolframResolution)?`${a.wolframResolution} || ${b.wolframResolution}`:(b.wolframResolution||a.wolframResolution||"");const chosenInterpretation=b.wolframChosenInterpretation||a.wolframChosenInterpretation||"";const attempted=status!=="not_attempted";const eligibilityPriority=["missing_api","skipped_budget","ca_bypassed","synthetic_local","eligible"];let eligibility="eligible";if(!attempted){for(const key of eligibilityPriority){if(a.groundingEligibility===key||b.groundingEligibility===key){eligibility=key;break;}}}const skipReason=attempted?"":(String(b.groundingSkipReason||"").trim()||String(a.groundingSkipReason||"").trim());return {wolframQueriesTried:dedupeCasefold([...(a.wolframQueriesTried||[]),...(b.wolframQueriesTried||[])]),wolframInterpretations:dedupeCasefold([...(a.wolframInterpretations||[]),...(b.wolframInterpretations||[])]),wolframEntities:dedupeCasefold([...(a.wolframEntities||[]),...(b.wolframEntities||[])]),wolframConfidence:{level,score},groundingStatus:status,wolframResolution:resolution,wolframChosenInterpretation:chosenInterpretation,groundingEligibility:eligibility,groundingSkipReason:skipReason};}
function normalizeProvenanceEntry(entry){if(!entry||typeof entry!=="object") return null;const source=String(entry.source||"").trim().toLowerCase();const stage=String(entry.stage||"").trim().toLowerCase();const note=String(entry.note||"").trim();const query=String(entry.query||"").trim();const impact=String(entry.impact||"").trim();const status=String(entry.status||"").trim();const discName=String(entry.discName||"").trim();const discId=Number.isInteger(entry.discId)?entry.discId:null;if(!source&&!stage&&!note&&!query&&!impact&&!status&&discId===null&&!discName) return null;return {source:source||"unknown",stage:stage||"unspecified",discId,discName,status,impact,query,note};}
function mergeDescriptionProvenance(left,right){const out=[];const seen=new Set();for(const item of [...(left||[]),...(right||[])]){const norm=normalizeProvenanceEntry(item);if(!norm) continue;const key=JSON.stringify(norm);if(seen.has(key)) continue;seen.add(key);out.push(norm);}return out;}
function mergeDescriptionSource(left,right){const a=String(left||"").trim().toLowerCase();const b=String(right||"").trim().toLowerCase();if(!a) return b||"";if(!b) return a;if(a===b) return a;return "mixed";}
function normalizeWolframEntityCandidate(entity){if(!entity||typeof entity!=="object") return null;const type=String(entity.type||"").trim();const idOrName=String(entity.id_or_name||entity.id||entity.name||"").trim();const query=String(entity.query||"").trim();if(!type&&!idOrName&&!query) return null;return {type,idOrName,query};}
function normalizeProbeTerm(item){
  const label=String(item?.label||"").trim();
  if(!label) return null;
  const description=String(item?.description||"").trim();
  const source=String(item?.description_source||"").trim().toLowerCase()||"llm";
  const descriptions=normalizeTermDescriptions(item?.descriptions,{fallbackDescription:description,fallbackSource:source,label});
  const centrality=clamp01(Number(item?.centrality??0.5));
  const wolfram_entity=normalizeWolframEntityCandidate(item?.wolfram_entity);
  const entityRef=buildWolframEntityRef(wolfram_entity);
  return {
    label,
    centrality,
    descriptions,
    description:String(descriptions.displayDescription||description).trim(),
    wolfram_entity,
    description_source:inferDescriptionSourceFromLayers(descriptions,source),
    description_provenance:[{source:source||"llm",stage:"probe",note:"Original probe model description"}],
    grounding:normalizeGroundingBlock(item?.grounding,{entityRef,defaultStatus:"not_attempted"})
  };
}
function normalizeProbeResult(parsed){return {summary:String(parsed?.summary||"").trim(),terms:Array.isArray(parsed?.terms)?parsed.terms.map(normalizeProbeTerm).filter(Boolean):[],claims_or_findings:Array.isArray(parsed?.claims_or_findings)?parsed.claims_or_findings.map(t=>String(t||"").trim()).filter(Boolean):[],citations:Array.isArray(parsed?.citations)?parsed.citations.map(normalizeCitation).filter(c=>c.url||c.title||c.publisher||c.quote_or_snippet):[],confidence_notes:String(parsed?.confidence_notes||"").trim()};}
function wolframPublicInputUrl(query){return `https://www.wolframalpha.com/input?i=${encodeURIComponent(String(query||""))}`;}
function sanitizeWolframToken(value){return String(value||"").replace(/[\r\n\t]+/g," ").replace(/\s+/g," ").replace(/"/g,"").trim();}
function canonicalizeWolframLabelForQuery(label){
  const clean=sanitizeWolframToken(label);
  if(!clean) return "";
  const canonical=toCanonicalKey(clean);
  return sanitizeWolframToken(canonical);
}
function deriveWolframDomainHintFromDiscName(discName){
  const raw=sanitizeWolframToken(discName).toLowerCase();
  if(!raw) return "";
  if(/\b(?:computer|computational|algorithm|software|information|data|machine learning|ai|artificial intelligence)\b/.test(raw)) return "computer science";
  if(/\b(?:math|mathematics|algebra|geometry|topology|calculus|probability|statistics|statistical)\b/.test(raw)) return "mathematics";
  if(/\b(?:physics|thermodynamics|quantum|mechanics)\b/.test(raw)) return "physics";
  if(/\b(?:chemistry|chemical|biochemistry)\b/.test(raw)) return "chemistry";
  if(/\b(?:biology|biological|genetic|genomics|neuroscience|cognitive|medical|medicine|health)\b/.test(raw)) return "biology";
  if(/\b(?:economics|economic|finance|financial|market)\b/.test(raw)) return "economics";
  if(/\b(?:policy|governance|government|law|legal|regulation|regulatory)\b/.test(raw)) return "public policy";
  if(/\b(?:philosophy|ethics|epistemology|metaphysics|normative)\b/.test(raw)) return "philosophy";
  if(/\b(?:sociology|social|anthropology|cultural|political science)\b/.test(raw)) return "social science";
  return "";
}
function isComputationalMathLikeTerm(label,discName){
  const blob=`${sanitizeWolframToken(label)} ${sanitizeWolframToken(discName)}`.toLowerCase();
  if(!blob.trim()) return false;
  return /\b(?:computational|algorithm|algorithmic|complexity|irreducibility|automata|cellular automaton|turing|lambda calculus|graph|network|matrix|tensor|stochastic|probability|bayesian|prior|posterior|optimization|topology|algebra|calculus|theorem|proof|formal)\b/.test(blob);
}
function buildWolframEntityQueryAttempts(term,target,discName){
  const attempts=[];
  const seen=new Set();
  const addAttempt=(rank,strategy,query)=>{
    const clean=String(query||"").trim();
    if(!clean) return;
    const key=clean.toLowerCase();
    if(seen.has(key)) return;
    seen.add(key);
    attempts.push({rank,strategy,query:clean,resolutionLabel:`fallback #${rank} (${strategy})`});
  };
  const hint=term?.wolfram_entity||null;
  const hintType=sanitizeWolframToken(hint?.type);
  const hintId=sanitizeWolframToken(hint?.idOrName||hint?.id_or_name||hint?.id||hint?.name);
  const hintQuery=sanitizeWolframToken(hint?.query);
  if(hintQuery){
    addAttempt(1,"entity_candidate",hintQuery);
  }else if(hintType&&hintId){
    addAttempt(1,"entity_candidate",`Entity["${hintType}","${hintId}"]["Definitions"]`);
  }else if(hintId){
    addAttempt(1,"entity_candidate",hintId);
  }
  const label=sanitizeWolframToken(term?.label);
  const minimalContext=sanitizeWolframToken(discName);
  const targetContext=sanitizeWolframToken(target);
  const canonicalLabel=canonicalizeWolframLabelForQuery(label);
  const domainHint=deriveWolframDomainHintFromDiscName(discName);
  const abstractLabel=isAbstractConceptPhrase(label);
  const computationalLike=isComputationalMathLikeTerm(label,discName);
  let rank=2;
  addAttempt(rank++,"plain_label",label);
  addAttempt(rank++,"quoted_label",label?`"${label}"`:"");
  addAttempt(rank++,"canonicalized_label",canonicalLabel);
  if(abstractLabel){
    addAttempt(rank++,"abstract_concept_hint",`${label} concept`.trim());
    addAttempt(rank++,"abstract_definition_hint",`${label} definition`.trim());
  }
  if(domainHint){
    addAttempt(rank++,"domain_hint",`${label} ${domainHint}`.trim());
  }
  if(computationalLike){
    addAttempt(rank++,"wolfram_language_hint",`${label} Wolfram Language`.trim());
  }
  addAttempt(rank++,"minimal_context",`${label} ${minimalContext}`.trim());
  addAttempt(rank++,"target_context",`${label} ${targetContext}`.trim());
  return attempts;
}
async function fetchWolframJSON(query,cfg,auditContext={}){
  const normalizedQuery=String(query||"").trim();
  const mode=normalizeMode(cfg);
  const ctx={
    target:String(auditContext?.target||"").trim(),
    discName:String(auditContext?.discName||"").trim(),
    termLabel:String(auditContext?.termLabel||"").trim(),
    attemptRank:Number.isFinite(Number(auditContext?.attemptRank))?Number(auditContext.attemptRank):null,
    attemptStrategy:String(auditContext?.attemptStrategy||"").trim(),
    resolutionLabel:String(auditContext?.resolutionLabel||"").trim()
  };
  const started=Date.now();
  const cached=getWolframQueryCache(normalizedQuery);
  if(cached){
    const durationMs=Date.now()-started;
    const cacheStatus="memory_hit";
    recordWolframAuditEvent({...ctx,stage:"fetch",query:normalizedQuery,mode,statusCode:200,success:true,durationMs,cacheStatus,note:"Browser query cache hit"});
    if(cached&&typeof cached==="object"){
      Object.defineProperty(cached,"__waAudit",{value:{mode,cacheStatus,statusCode:200,durationMs},enumerable:false,configurable:true});
    }
    return cached;
  }
  const appid=String(cfg?.wolframAppId||"").trim();
  if(!appid){
    recordWolframAuditEvent({...ctx,stage:"fetch",query:normalizedQuery,mode,statusCode:401,success:false,durationMs:Date.now()-started,cacheStatus:"memory_miss",status:"error",note:"Missing Wolfram AppID"});
    throw new Error("Missing Wolfram AppID.");
  }
  if(mode!=="proxy"){
    recordWolframAuditEvent({...ctx,stage:"fetch",query:normalizedQuery,mode,statusCode:0,success:false,durationMs:Date.now()-started,cacheStatus:"memory_miss",status:"error",note:"Direct mode blocked by CORS"});
    throw new Error("Wolfram Full Results API is blocked by browser CORS in direct mode. Switch to proxy mode.");
  }
  let res=null;
  try{
    res=await fetch("/wa/normalize",{
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body:JSON.stringify({appid,input:normalizedQuery,output:"json",format:"plaintext",reinterpret:true})
    });
    const proxyCacheRaw=res.headers?.get("X-Wolfram-Cache")||"";
    const cacheStatus=proxyCacheRaw?`proxy_${String(proxyCacheRaw).trim().toLowerCase()}`:"memory_miss";
    if(!res.ok){
      const raw=(await res.text()).slice(0,240);
      if(res.status===404||res.status===405){
        res=await fetch("/api/wolfram/query",{
          method:"POST",
          headers:{"Content-Type":"application/json"},
          body:JSON.stringify({appid,input:normalizedQuery,output:"json",format:"plaintext",reinterpret:true})
        });
      }else{
        recordWolframAuditEvent({...ctx,stage:"fetch",query:normalizedQuery,mode,statusCode:res.status,success:false,durationMs:Date.now()-started,cacheStatus,status:"error",note:raw});
        throw new Error(`Wolfram normalize proxy request failed (${res.status}): ${raw}`);
      }
    }
    const proxyCacheRawFinal=res.headers?.get("X-Wolfram-Cache")||"";
    const cacheStatusFinal=proxyCacheRawFinal?`proxy_${String(proxyCacheRawFinal).trim().toLowerCase()}`:"memory_miss";
    if(!res.ok){
      const raw=(await res.text()).slice(0,240);
      recordWolframAuditEvent({...ctx,stage:"fetch",query:normalizedQuery,mode,statusCode:res.status,success:false,durationMs:Date.now()-started,cacheStatus:cacheStatusFinal,status:"error",note:raw});
      throw new Error(`Wolfram proxy request failed (${res.status}): ${raw}`);
    }
    const data=await res.json();
    setWolframQueryCache(normalizedQuery,data);
    const durationMs=Date.now()-started;
    recordWolframAuditEvent({...ctx,stage:"fetch",query:normalizedQuery,mode,statusCode:res.status,success:true,durationMs,cacheStatus:cacheStatusFinal});
    if(data&&typeof data==="object"){
      Object.defineProperty(data,"__waAudit",{value:{mode,cacheStatus:cacheStatusFinal,statusCode:res.status,durationMs},enumerable:false,configurable:true});
    }
    return data;
  }catch(err){
    if(!res){
      recordWolframAuditEvent({...ctx,stage:"fetch",query:normalizedQuery,mode,statusCode:0,success:false,durationMs:Date.now()-started,cacheStatus:"memory_miss",status:"error",note:String(err?.message||err)});
    }
    throw err;
  }
}
function compactWolframText(text,maxLen=420){return String(text||"").replace(/\s+/g," ").trim().slice(0,maxLen);}
function resolveWolframTemplateToken(values,key){
  const raw=String(key||"").trim();
  if(!raw) return "";
  const candidates=[raw,raw.toLowerCase(),raw.replace(/[^a-z0-9]+/gi,""),raw.replace(/[^a-z0-9]+/gi,"").toLowerCase()];
  for(const candidate of candidates){
    if(!candidate) continue;
    const hit=values?.[candidate];
    if(hit!==undefined&&hit!==null&&String(hit).trim()) return compactWolframText(String(hit),120);
  }
  return "";
}
function normalizeWolframAssumptionText(text,context={}){
  const raw=compactWolframText(text,220);
  if(!raw) return "";
  const values={};
  const ctx=context&&typeof context==="object"?context:{};
  for(const [k,v] of Object.entries(ctx)){
    if(v===null||v===undefined) continue;
    if(typeof v!=="string"&&typeof v!=="number"&&typeof v!=="boolean") continue;
    const key=String(k||"").trim();
    const value=compactWolframText(String(v),120);
    if(!key||!value) continue;
    values[key]=value;
    values[key.toLowerCase()]=value;
    const slim=key.replace(/[^a-z0-9]+/gi,"");
    if(slim){
      values[slim]=value;
      values[slim.toLowerCase()]=value;
    }
  }
  if(values.value&&!values["1"]) values["1"]=values.value;
  if(values.word&&!values.term) values.term=values.word;
  if(values.desc&&!values.description) values.description=values.desc;
  let unresolved=false;
  let out=raw.replace(/\$\{([^}]+)\}/g,(_,token)=>{
    const resolved=resolveWolframTemplateToken(values,token);
    if(resolved) return resolved;
    unresolved=true;
    return "";
  });
  out=out.replace(/`(\d+)`/g,(_,idx)=>{
    const resolved=resolveWolframTemplateToken(values,idx)||resolveWolframTemplateToken(values,`arg${idx}`)||resolveWolframTemplateToken(values,`value${idx}`)||resolveWolframTemplateToken(values,"value");
    if(resolved) return resolved;
    unresolved=true;
    return "";
  });
  out=compactWolframText(out,220).replace(/\s+([,.;:!?])/g,"$1");
  if(/\$\{[^}]+\}|`[0-9]+`/.test(out)) unresolved=true;
  if(!out) unresolved=true;
  return unresolved?"Assumption clash (template unresolved)":out;
}
function isWolframLowSignalText(text){
  const t=compactWolframText(text,320);
  if(!t) return true;
  if(/^(?:none|n\/a|null|unknown|not available|not applicable)$/i.test(t)) return true;
  const canon=t.toLowerCase().replace(/[^a-z0-9]+/g," ").trim();
  if(/^(?:entity|person|location|place|thing|object|item|concept|term|image)$/i.test(canon)) return true;
  if(/^\(?image\)?$/i.test(canon)) return true;
  return false;
}
function wolframPodTitleScore(title){
  const t=String(title||"").toLowerCase();
  if(/input interpretation/.test(t)) return 120;
  if(/definition|definitions/.test(t)) return 112;
  if(/basic information/.test(t)) return 102;
  if(/^result$|result /.test(t)) return 98;
  if(/properties/.test(t)) return 92;
  if(/assumption|possible interpretation/.test(t)) return 46;
  if(/name|identity|identification|wikipedia/.test(t)) return 18;
  return 54;
}
function extractWolframListValues(value,maxItems=8){
  const out=[];
  const pushIf=(v)=>{const t=compactWolframText(v,220);if(t&&!out.includes(t)) out.push(t);};
  const walk=(node)=>{
    if(out.length>=maxItems||node===null||node===undefined) return;
    if(typeof node==="string"){pushIf(node);return;}
    if(Array.isArray(node)){for(const x of node){walk(x);if(out.length>=maxItems) break;}return;}
    if(typeof node==="object"){
      if(typeof node.plaintext==="string") pushIf(node.plaintext);
      if(typeof node.text==="string") pushIf(node.text);
      if(typeof node.desc==="string") pushIf(node.desc);
      if(typeof node.word==="string"&&typeof node.desc==="string") pushIf(`${node.word}: ${node.desc}`);
      if(typeof node.value==="string") pushIf(node.value);
      if(typeof node.name==="string"&&!node.desc&&!node.text) pushIf(node.name);
      if(typeof node["#text"]==="string") pushIf(node["#text"]);
      for(const key of Object.keys(node)){walk(node[key]);if(out.length>=maxItems) break;}
    }
  };
  walk(value);
  return out.filter(x=>!isWolframLowSignalText(x)).slice(0,maxItems);
}
function extractWolframStructured(data){
  const normalized=data?.normalized&&typeof data.normalized==="object"?data.normalized:(data&&typeof data==="object"?data:null);
  if(normalized&&("bestPlaintext" in normalized||"candidateFacts" in normalized||"inputInterpretation" in normalized)){
    const bestDefinition=compactWolframText(normalized.bestPlaintext||"",420);
    const inputInterpretation=compactWolframText(normalized.inputInterpretation||"",320);
    const altFacts=Array.isArray(normalized.candidateFacts)?normalized.candidateFacts.map(x=>compactWolframText(x,320)).filter(Boolean):[];
    const assumptions=Array.isArray(normalized.assumptions)?normalized.assumptions.map(x=>normalizeWolframAssumptionText(x,{})).filter(Boolean):[];
    const didYouMeans=Array.isArray(normalized.didYouMeans)?normalized.didYouMeans.map(x=>compactWolframText(x,200)).filter(Boolean):[];
    const warnings=Array.isArray(normalized.warnings)?normalized.warnings.map(x=>compactWolframText(x,220)).filter(Boolean):[];
    const chosenPod=String(normalized.chosenPod||"").trim();
    const candidates=[bestDefinition,...altFacts].filter(Boolean).map((text,idx)=>({title:idx===0?(chosenPod||"Result"):"Alternative fact",text,score:idx===0?120:80,podId:"normalized",subpodIndex:idx}));
    return {
      inputInterpretation,
      bestDefinition,
      altFacts:[...new Set(altFacts)].slice(0,6),
      assumptions:[...new Set(assumptions)].slice(0,6),
      didYouMeans:[...new Set(didYouMeans)].slice(0,6),
      warnings:[...new Set(warnings)].slice(0,6),
      candidates:candidates.slice(0,12)
    };
  }
  const queryresult=data?.queryresult&&typeof data.queryresult==="object"?data.queryresult:{};
  const pods=Array.isArray(queryresult.pods)?queryresult.pods:[];
  const candidates=[];
  for(const pod of pods){
    const title=String(pod?.title||"").trim();
    const base=wolframPodTitleScore(title);
    const subpods=Array.isArray(pod?.subpods)?pod.subpods:[];
    for(let i=0;i<subpods.length;i++){
      const sub=subpods[i];
      const textCandidates=[];
      const seenTexts=new Set();
      const pushText=(raw)=>{
        const text=compactWolframText(raw,420);
        if(!text) return;
        const key=toCanonicalKey(text)||text.toLowerCase();
        if(seenTexts.has(key)) return;
        seenTexts.add(key);
        textCandidates.push(text);
      };
      pushText(sub?.plaintext);
      for(const fallbackText of extractWolframListValues(sub,4)){
        pushText(fallbackText);
        if(textCandidates.length>=3) break;
      }
      for(let textIdx=0;textIdx<textCandidates.length;textIdx++){
        const text=textCandidates[textIdx];
        if(!text||isWolframLowSignalText(text)) continue;
        let score=base;
        if(text.length<24) score-=16;
        if(text.length>=40&&text.length<=240) score+=9;
        if(/(?:assuming|assumptions?)/i.test(text)) score-=8;
        if(/^\d+(?:\.\d+)?$/.test(text)) score-=18;
        if(textIdx>0) score-=6;
        candidates.push({title,text,score,podId:String(pod?.id||""),subpodIndex:i});
      }
    }
  }
  candidates.sort((a,b)=>b.score-a.score);
  const inputInterpretation=(candidates.find(c=>/input interpretation/i.test(c.title))?.text)||"";
  const defCandidates=candidates.filter(c=>/definition|basic information|result|properties/i.test(c.title));
  const bestDefinition=(defCandidates[0]?.text)||(candidates[0]?.text)||"";
  const altFacts=[];
  for(const c of candidates){
    if(c.text===bestDefinition||c.text===inputInterpretation) continue;
    if(altFacts.includes(c.text)) continue;
    altFacts.push(c.text);
    if(altFacts.length>=4) break;
  }
  const assumptionsRaw=queryresult.assumptions??queryresult.assumption??null;
  const assumptions=[];
  const pushAssumption=(text,context={})=>{const t=normalizeWolframAssumptionText(text,context);if(t&&!assumptions.includes(t)) assumptions.push(t);};
  const assumptionTemplateContext=(node)=>{
    if(!node||typeof node!=="object") return {};
    const ctx={};
    for(const [k,v] of Object.entries(node)){
      if(v===null||v===undefined) continue;
      if(typeof v==="string"||typeof v==="number"||typeof v==="boolean") ctx[k]=String(v);
      if(Array.isArray(v)&&v.length&&v.every(x=>typeof x==="string"||typeof x==="number"||typeof x==="boolean")) ctx[k]=v.map(x=>String(x)).join(" | ");
    }
    return ctx;
  };
  const readAssumptions=(node)=>{
    if(!node) return;
    if(Array.isArray(node)){for(const n of node){readAssumptions(n);}return;}
    if(typeof node==="object"){
      if(Array.isArray(node.assumption)){for(const a of node.assumption){readAssumptions(a);}return;}
      const templateCtx=assumptionTemplateContext(node);
      const word=typeof node.word==="string"?node.word.trim():"";
      const desc=typeof node.desc==="string"?node.desc.trim():"";
      const value=typeof node.value==="string"?node.value.trim():"";
      if(word&&desc) pushAssumption(`${word}: ${desc}`,templateCtx);
      if(desc&&!word) pushAssumption(desc,templateCtx);
      if(value&&word) pushAssumption(`${word} -> ${value}`,templateCtx);
      if(typeof node.template==="string") pushAssumption(node.template,templateCtx);
      if(typeof node.plaintext==="string") pushAssumption(node.plaintext,templateCtx);
    }
  };
  readAssumptions(assumptionsRaw);
  const didYouRaw=queryresult.didyoumeans??queryresult.didyoumean??null;
  const didYouMeans=[];
  const pushDidYou=(text)=>{const t=compactWolframText(text,140);if(t&&!didYouMeans.includes(t)) didYouMeans.push(t);};
  const readDidYou=(node)=>{
    if(!node) return;
    if(Array.isArray(node)){for(const n of node){readDidYou(n);}return;}
    if(typeof node==="object"){
      if(Array.isArray(node.didyoumean)){for(const d of node.didyoumean){readDidYou(d);}return;}
      if(typeof node["#text"]==="string") pushDidYou(node["#text"]);
      if(typeof node.text==="string") pushDidYou(node.text);
      if(typeof node.word==="string") pushDidYou(node.word);
      return;
    }
    if(typeof node==="string") pushDidYou(node);
  };
  readDidYou(didYouRaw);
  const warningsRaw=queryresult.warnings??queryresult.warning??null;
  const warnings=[...extractWolframListValues(warningsRaw,4)];
  if(queryresult.timedout) warnings.push(`Timed out pods: ${String(queryresult.timedout)}`);
  if(queryresult.error===true) warnings.push("Wolfram queryresult.error=true");
  return {
    inputInterpretation,
    bestDefinition,
    altFacts,
    assumptions:assumptions.filter(x=>!isWolframLowSignalText(x)).slice(0,6),
    didYouMeans:didYouMeans.filter(x=>!isWolframLowSignalText(x)).slice(0,6),
    warnings:[...new Set(warnings.map(x=>compactWolframText(x,220)).filter(Boolean))].slice(0,6),
    candidates:candidates.slice(0,12)
  };
}
function selectWolframSnippetFromParsed(parsed){
  const clean=(value,maxLen=420)=>compactWolframText(value,maxLen);
  const valid=(value)=>{const text=clean(value);return text&&!isWolframLowSignalText(text);};
  const normalized=parsed&&typeof parsed==="object"?parsed:{};
  const candidateTexts=Array.isArray(normalized.candidates)?normalized.candidates.slice().sort((a,b)=>(Number(b?.score)||0)-(Number(a?.score)||0)).map(item=>clean(item?.text,420)).filter(valid):[];
  const altFacts=Array.isArray(normalized.altFacts)?normalized.altFacts.map(x=>clean(x,420)).filter(valid):[];
  const assumptions=Array.isArray(normalized.assumptions)?normalized.assumptions.map(x=>clean(x,320)).filter(x=>valid(x)&&!/^assumption clash/i.test(x)):[];
  const didYouMeans=Array.isArray(normalized.didYouMeans)?normalized.didYouMeans.map(x=>clean(x,220)).filter(valid):[];
  const inputInterpretation=clean(normalized.inputInterpretation,320);
  const bestDefinition=clean(normalized.bestDefinition,420);
  const ordered=[
    {source:"best_definition",text:bestDefinition},
    {source:"candidate_fact",text:candidateTexts[0]||""},
    {source:"input_interpretation",text:inputInterpretation},
    {source:"alt_fact",text:altFacts[0]||""},
    {source:"assumption_fallback",text:assumptions[0]||""},
    {source:"didyoumean_fallback",text:didYouMeans[0]||""}
  ];
  const picked=ordered.find(item=>valid(item.text))||null;
  const snippet=picked?clean(picked.text,420):"";
  const chosenInterpretation=clean(inputInterpretation||bestDefinition||didYouMeans[0]||snippet,320);
  return {snippet,source:picked?.source||"",chosenInterpretation};
}
function buildNoPlaintextReasons(parsed){
  const base=["empty","parser_selection_exhausted"];
  const hasStructuredSignal=Boolean(
    String(parsed?.inputInterpretation||"").trim()||
    String(parsed?.bestDefinition||"").trim()||
    (Array.isArray(parsed?.altFacts)&&parsed.altFacts.length)||
    (Array.isArray(parsed?.assumptions)&&parsed.assumptions.length)||
    (Array.isArray(parsed?.didYouMeans)&&parsed.didYouMeans.length)||
    (Array.isArray(parsed?.candidates)&&parsed.candidates.length)
  );
  if(hasStructuredSignal) base.push("structured_response_present");
  return base;
}
function extractWolframPlaintext(data){
  const parsed=extractWolframStructured(data);
  const selected=selectWolframSnippetFromParsed(parsed);
  return selected.snippet||"";
}
function resolveWolframChosenPod(parsed,snippet){
  const candidates=Array.isArray(parsed?.candidates)?parsed.candidates:[];
  const snippetKey=toCanonicalKey(snippet||"");
  if(snippetKey){
    const exact=candidates.find(c=>toCanonicalKey(c?.text||"")===snippetKey);
    if(exact?.title) return String(exact.title||"").trim();
  }
  if(Array.isArray(candidates)&&candidates[0]?.title){
    return String(candidates[0].title||"").trim();
  }
  if(String(parsed?.bestDefinition||"").trim()) return "Definition";
  if(String(parsed?.inputInterpretation||"").trim()) return "Input interpretation";
  return "";
}
function scoreWolframSnippet(snippet,termLabel,minQualityScore=0.58,minAlignmentScore=0.55,context={}){
  const text=String(snippet||"").replace(/\s+/g," ").trim();
  const normalized=text.toLowerCase();
  const labelNorm=String(termLabel||"").replace(/\s+/g," ").trim().toLowerCase();
  const reasons=[];
  const qualityThreshold=clampGroundingSnippetScore(minQualityScore,0.58);
  const alignmentThreshold=clampGroundingSnippetScore(minAlignmentScore,0.55);
  if(!text){
    return {score:0,accept:false,confidence:"low",reasons:["empty"],length:0,wordCount:0,threshold:qualityThreshold,quality_threshold:qualityThreshold,alignment_threshold:alignmentThreshold,snippet_quality_score:0,semantic_alignment_score:0,quality_accept:false,alignment_accept:false,single_word_drift:false,single_word_drift_warning_signal:false,closest_interpretation_type_mismatch:false,assumption_clash_generic_token:false};
  }
  let qualityScore=1;
  const words=text.split(" ").filter(Boolean);
  const genericTokens=new Set(["entity","entities","person","people","location","place","concept","thing","object","item","term","idea","category","unknown","n/a","na","none","null"]);
  const normalizedWords=words.map(w=>w.toLowerCase().replace(/[^a-z0-9]/g,"")).filter(Boolean);
  if(text.length<24||normalizedWords.length<4){
    qualityScore-=0.45;
    reasons.push("too_short");
  }
  const genericOnly=normalizedWords.length>0&&normalizedWords.every(w=>genericTokens.has(w));
  if(genericOnly||genericTokens.has(normalized.replace(/[^a-z0-9]/g,""))){
    qualityScore-=0.7;
    reasons.push("generic_placeholder");
  }
  const canonText=toCanonicalKey(text);
  const canonLabel=toCanonicalKey(termLabel||"");
  if((canonText&&canonLabel&&canonText===canonLabel)||normalized===labelNorm){
    qualityScore-=0.8;
    reasons.push("same_as_label");
  }
  const digitCount=(text.match(/[0-9]/g)||[]).length;
  const alphaCount=(text.match(/[A-Za-z]/g)||[]).length;
  const semanticCue=/(?:\bis\b|\bare\b|\brefers to\b|\bdefined\b|\bmeans\b|\btype\b|\bclass\b|\bprocess\b|\btheory\b|\bcondition\b|\bsyndrome\b|\bprinciple\b)/i.test(text);
  if(digitCount>0){
    const total=digitCount+alphaCount;
    const numericRatio=total?digitCount/total:1;
    if((alphaCount===0||numericRatio>=0.52)&&!semanticCue){
      qualityScore-=0.55;
      reasons.push("mostly_numeric");
    }
  }
  qualityScore=Math.max(0,Math.min(1,qualityScore));
  const stopWords=new Set(["a","an","the","of","for","to","in","on","at","by","with","from","and","or","as","via","into","is","are","be","this","that","these","those"]);
  const tokenize=(value)=>String(value||"").toLowerCase().split(/[^a-z0-9]+/g).map(tok=>tok.trim()).filter(tok=>tok&&tok.length>1&&!stopWords.has(tok));
  const labelTokens=[...new Set(tokenize(termLabel||""))];
  const snippetTokenSet=new Set(tokenize(text));
  const overlapCount=labelTokens.filter(tok=>snippetTokenSet.has(tok)).length;
  const overlapRatio=labelTokens.length?overlapCount/labelTokens.length:0;
  const phraseMatch=Boolean(canonLabel&&canonText&&canonText.includes(canonLabel));
  let semanticAlignmentScore=labelTokens.length?0.35+Math.min(0.6,overlapRatio*0.62):0.55;
  if(phraseMatch) semanticAlignmentScore=Math.max(semanticAlignmentScore,0.92);
  if(labelTokens.length&&overlapCount===0){
    semanticAlignmentScore-=0.2;
    reasons.push("label_tokens_missing");
  }
  if(genericOnly) semanticAlignmentScore-=0.2;
  if((canonText&&canonLabel&&canonText===canonLabel)||normalized===labelNorm) semanticAlignmentScore-=0.15;
  const entityTypeRaw=String(context?.entityType||"").trim();
  const entityTypePresent=Boolean(entityTypeRaw);
  const interpretationText=String(context?.chosenInterpretation||context?.parsed?.inputInterpretation||context?.parsed?.bestDefinition||text).replace(/\s+/g," ").trim();
  const interpretationTokens=new Set(tokenize(interpretationText));
  const interpretationMatchCount=labelTokens.filter(tok=>interpretationTokens.has(tok)).length;
  const warningsList=[...(Array.isArray(context?.warnings)?context.warnings:[]),...(Array.isArray(context?.parsed?.warnings)?context.parsed.warnings:[])].map(x=>String(x||"").trim()).filter(Boolean);
  const warningText=warningsList.join(" ").toLowerCase();
  const warningSignal=/(?:closest\s+wolfram\|alpha\s+interpretation|closest\s+interpretation|closest\s+match|clash)/i.test(warningText);
  const entityTypeTokens=entityTypeRaw.toLowerCase().replace(/([a-z])([A-Z])/g,"$1 $2").split(/[^a-z0-9]+/g).map(x=>x.trim()).filter(Boolean);
  const interpretationBlob=[interpretationText,text,String(context?.chosenPod||""),String(context?.parsed?.bestDefinition||""),String(context?.parsed?.inputInterpretation||"")].join(" ").toLowerCase();
  const categoryFromInterpretation=classifyWolframResolvedCategory({entityType:"",chosenInterpretation:interpretationText,definition:text,parsed:context?.parsed||{},chosenPod:String(context?.chosenPod||"")});
  const expectedCategories=(()=>{const t=entityTypeRaw.toLowerCase();if(/airport|airfield/.test(t)) return ["airport","place"];if(/periodical|journal|magazine|newspaper|publication/.test(t)) return ["periodical"];if(/chemical|compound|molecule|drug|protein|gene|enzyme|substance/.test(t)) return ["chemical_compound"];if(/person|people|human|biography/.test(t)) return ["person"];if(/city|country|state|province|county|location|place|geographic|airport/.test(t)) return ["place","airport"];return [];})();
  const typeTokenOverlap=entityTypeTokens.filter(tok=>interpretationBlob.includes(tok)).length;
  const interpretationTypeMatch=!entityTypePresent||Boolean((expectedCategories.length&&expectedCategories.includes(categoryFromInterpretation))||typeTokenOverlap>0);
  const closestInterpretationWarning=/(?:closest\s+wolfram\|alpha\s+interpretation|closest\s+interpretation|closest\s+match)/i.test(warningText);
  if(closestInterpretationWarning&&!interpretationTypeMatch){
    semanticAlignmentScore-=0.34;
    qualityScore-=0.12;
    reasons.push("closest_interpretation_type_mismatch");
  }
  const assumptionsList=[...(Array.isArray(context?.assumptions)?context.assumptions:[]),...(Array.isArray(context?.parsed?.assumptions)?context.parsed.assumptions:[])].map(x=>String(x||"").trim()).filter(Boolean);
  const assumptionClashLines=assumptionsList.filter(line=>/\bclash\b/i.test(line));
  const genericAssumptionTokens=new Set(["counter","imperative","structure","interactional","interaction","asymmetry","system","model","process","method","rule","law","principle","theory","framework","network","signal","state","value","class","type","function","logic"]);
  const genericLabelTokenHit=labelTokens.find(tok=>genericAssumptionTokens.has(tok)&&assumptionClashLines.some(line=>new RegExp(`\\b${tok.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}\\b`,"i").test(line)));
  if(genericLabelTokenHit){
    semanticAlignmentScore-=0.24;
    qualityScore-=0.08;
    reasons.push("assumption_clash_generic_token");
  }
  const singleWordDrift=labelTokens.length>=2&&interpretationMatchCount===1;
  if(singleWordDrift){
    semanticAlignmentScore-=0.2;
    reasons.push("single_word_drift");
    if(warningSignal){
      semanticAlignmentScore-=0.12;
      reasons.push("single_word_drift_warning_signal");
    }
  }
  qualityScore=Math.max(0,Math.min(1,qualityScore));
  semanticAlignmentScore=Math.max(0,Math.min(1,semanticAlignmentScore));
  const qualityAccept=qualityScore>=qualityThreshold;
  const alignmentAccept=semanticAlignmentScore>=alignmentThreshold;
  const accept=qualityAccept&&alignmentAccept;
  const combinedScore=Math.max(0,Math.min(1,(qualityScore*0.55)+(semanticAlignmentScore*0.45)));
  const minComponent=Math.min(qualityScore,semanticAlignmentScore);
  const confidence=!accept?"low":minComponent>=0.82?"high":"medium";
  return {score:Number(combinedScore.toFixed(3)),accept,confidence,reasons,length:text.length,wordCount:normalizedWords.length,threshold:qualityThreshold,quality_threshold:qualityThreshold,alignment_threshold:alignmentThreshold,snippet_quality_score:Number(qualityScore.toFixed(3)),semantic_alignment_score:Number(semanticAlignmentScore.toFixed(3)),quality_accept:qualityAccept,alignment_accept:alignmentAccept,single_word_drift:singleWordDrift,single_word_drift_warning_signal:Boolean(singleWordDrift&&warningSignal),closest_interpretation_type_mismatch:Boolean(closestInterpretationWarning&&!interpretationTypeMatch),assumption_clash_generic_token:Boolean(genericLabelTokenHit)};
}
function recordWolframGroundingDiagnostic(entry){
  const item={
    runId:CURRENT_RUN_ID||null,
    timestamp:new Date().toISOString(),
    target:String(entry?.target||"").trim(),
    discName:String(entry?.discName||"").trim(),
    termLabel:String(entry?.termLabel||"").trim(),
    attemptRank:Number.isFinite(Number(entry?.attemptRank))?Number(entry.attemptRank):null,
    attemptStrategy:String(entry?.attemptStrategy||"").trim(),
    resolutionLabel:String(entry?.resolutionLabel||"").trim(),
    stopReason:String(entry?.stopReason||"").trim(),
    query:String(entry?.query||"").trim(),
    snippet:String(entry?.snippet||"").trim(),
    accepted:Boolean(entry?.accepted),
    score:Number.isFinite(Number(entry?.score))?Number(entry.score):null,
    snippetQualityScore:Number.isFinite(Number(entry?.snippetQualityScore))?Number(entry.snippetQualityScore):Number.isFinite(Number(entry?.snippet_quality_score))?Number(entry.snippet_quality_score):null,
    semanticAlignmentScore:Number.isFinite(Number(entry?.semanticAlignmentScore))?Number(entry.semanticAlignmentScore):Number.isFinite(Number(entry?.semantic_alignment_score))?Number(entry.semantic_alignment_score):null,
    confidence:String(entry?.confidence||"").trim(),
    reasons:Array.isArray(entry?.reasons)?entry.reasons.map(r=>String(r||"").trim()).filter(Boolean):[],
    inputInterpretation:String(entry?.inputInterpretation||"").trim(),
    bestDefinition:String(entry?.bestDefinition||"").trim(),
    altFacts:Array.isArray(entry?.altFacts)?entry.altFacts.map(x=>String(x||"").trim()).filter(Boolean):[],
    assumptions:Array.isArray(entry?.assumptions)?entry.assumptions.map(x=>normalizeWolframAssumptionText(x,{})).filter(Boolean):[],
    didYouMeans:Array.isArray(entry?.didYouMeans)?entry.didYouMeans.map(x=>String(x||"").trim()).filter(Boolean):[],
    warnings:Array.isArray(entry?.warnings)?entry.warnings.map(x=>String(x||"").trim()).filter(Boolean):[],
    chosenInterpretation:String(entry?.chosenInterpretation||"").trim(),
    status:String(entry?.status||"").trim(),
    error:String(entry?.error||"").trim(),
    mode:String(entry?.mode||"").trim(),
    durationMs:Number.isFinite(Number(entry?.durationMs))?Number(entry.durationMs):null,
    statusCode:Number.isFinite(Number(entry?.statusCode))?Number(entry.statusCode):null,
    cacheStatus:normalizeWolframCacheStatus(entry?.cacheStatus),
    chosenPod:String(entry?.chosenPod||"").trim(),
    appliedToDescription:typeof entry?.appliedToDescription==="boolean"?entry.appliedToDescription:null
  };
  const success=typeof entry?.success==="boolean"?Boolean(entry.success):item.status!=="error";
  recordWolframAuditEvent({
    stage:"grounding_decision",
    target:item.target,
    discName:item.discName,
    termLabel:item.termLabel,
    query:item.query,
    mode:item.mode||"proxy",
    durationMs:item.durationMs,
    statusCode:item.statusCode,
    success,
    assumptionsCount:item.assumptions.length,
    chosenPod:item.chosenPod,
    snippetScore:item.score,
    snippetQualityScore:item.snippetQualityScore,
    semanticAlignmentScore:item.semanticAlignmentScore,
    appliedToDescription:item.appliedToDescription,
    cacheStatus:item.cacheStatus,
    attemptRank:item.attemptRank,
    attemptStrategy:item.attemptStrategy,
    resolutionLabel:item.resolutionLabel,
    status:item.status,
    confidence:item.confidence,
    reasons:item.reasons,
    note:item.error
  });
  WOLFRAM_GROUNDING_DIAGNOSTICS.push(item);
  upsertAmbiguityFromDiagnostic(item);
  if(WOLFRAM_GROUNDING_DIAGNOSTICS.length>4000){
    WOLFRAM_GROUNDING_DIAGNOSTICS=WOLFRAM_GROUNDING_DIAGNOSTICS.slice(-4000);
  }
  if(RUN_STATE){
    RUN_STATE.wolframGroundingDiagnostics=[...WOLFRAM_GROUNDING_DIAGNOSTICS];
  }
}
function serializeWolframParsed(parsed){return {inputInterpretation:String(parsed?.inputInterpretation||""),bestDefinition:String(parsed?.bestDefinition||""),altFacts:Array.isArray(parsed?.altFacts)?parsed.altFacts.map(x=>String(x||"")).filter(Boolean):[],assumptions:Array.isArray(parsed?.assumptions)?parsed.assumptions.map(x=>normalizeWolframAssumptionText(x,{})).filter(Boolean):[],didYouMeans:Array.isArray(parsed?.didYouMeans)?parsed.didYouMeans.map(x=>String(x||"")).filter(Boolean):[],warnings:Array.isArray(parsed?.warnings)?parsed.warnings.map(x=>String(x||"")).filter(Boolean):[]};}
function buildWolframGroundingCitation(termLabel,chosen,accepted,resolutionText,{appliedToDescription=false,policyMode="balanced"}={}){if(!chosen?.query) return null;const parsed=chosen.parsed||{};const relevance=accepted?(appliedToDescription?`Definition grounding applied for ${termLabel} (${resolutionText}; mode ${policyMode})`:`Definition grounding captured as annotation for ${termLabel} (${resolutionText}; mode ${policyMode})`):`Definition grounding captured but not applied to ${termLabel} (${resolutionText}; low confidence)`;const groundingStatus=accepted?(appliedToDescription?"accepted":"accepted_metadata_only"):"rejected_low_confidence";return normalizeCitation({url:wolframPublicInputUrl(chosen.query),title:`Wolfram definition: ${termLabel}`,publisher:"Wolfram|Alpha",date:new Date().toISOString().slice(0,10),quote_or_snippet:String(chosen.definition||"").slice(0,140),relevance,source_type:"wolfram",supporting_terms:[termLabel],grounding_status:groundingStatus,grounding_confidence:chosen.scoring?.confidence||"low",grounding_score:Number.isFinite(Number(chosen.scoring?.score))?Number(chosen.scoring.score):0,grounding_reasons:Array.isArray(chosen.scoring?.reasons)?chosen.scoring.reasons:[],wolfram_input_interpretation:String(parsed.inputInterpretation||""),wolfram_best_definition:String(parsed.bestDefinition||""),wolfram_alt_facts:Array.isArray(parsed.altFacts)?parsed.altFacts:[],wolfram_assumptions:Array.isArray(parsed.assumptions)?parsed.assumptions:[],wolfram_did_you_means:Array.isArray(parsed.didYouMeans)?parsed.didYouMeans:[],wolfram_warnings:Array.isArray(parsed.warnings)?parsed.warnings:[]});}
function setTermGroundingEligibility(term,eligibility,skipReason=""){
  if(!term||typeof term!=="object") return;
  const base=normalizeGroundingBlock(term.grounding||{},{defaultStatus:"not_attempted"});
  const next=normalizeGroundingBlock({...base,groundingEligibility:normalizeGroundingEligibility(eligibility),groundingSkipReason:String(skipReason||"").trim()},{defaultStatus:base.groundingStatus||"not_attempted"});
  term.grounding=next;
}
function dedupeCitations(citations){const out=[];const seen=new Set();for(const cite of (citations||[])){const key=(cite?.url||`${cite?.title}|${cite?.publisher}|${cite?.date}`).toLowerCase();if(!key||seen.has(key)) continue;seen.add(key);out.push(cite);}return out;}
function buildWolframLayerTextForPolicy(chosen,policy,termLabel){
  const base=String(chosen?.definition||"").trim();
  if(!base) return "";
  if(String(policy?.mode||"balanced")!=="aggressive") return base;
  const labelKey=toCanonicalKey(termLabel||"");
  const baseKey=toCanonicalKey(base);
  const altFacts=Array.isArray(chosen?.parsed?.altFacts)?chosen.parsed.altFacts:[];
  const extra=altFacts.map(x=>String(x||"").trim()).find(text=>{
    if(!text||isWolframLowSignalText(text)) return false;
    const key=toCanonicalKey(text);
    if(!key||key===baseKey||key===labelKey) return false;
    return !baseKey.includes(key)&&!key.includes(baseKey);
  });
  if(!extra) return base;
  return mergeDescription(base,extra);
}
async function groundProbeTermsWithWolfram(norm,target,discName,cfg){
  const terms=Array.isArray(norm?.terms)?norm.terms:[];
  if(!cfg?.wolframEntityGrounding){
    for(const term of terms){setTermGroundingEligibility(term,"eligible","Wolfram grounding disabled in run configuration.");}
    return norm;
  }
  if(!cfg?.wolframAppId){
    const msg="Wolfram grounding skipped: missing Wolfram AppID.";
    for(const term of terms){setTermGroundingEligibility(term,"missing_api",msg);}
    norm.confidence_notes=norm.confidence_notes?`${norm.confidence_notes} ${msg}`:msg;
    return norm;
  }
  if(normalizeMode(cfg)!=="proxy"){
    const msg="Wolfram grounding skipped: proxy mode required due CORS.";
    for(const term of terms){setTermGroundingEligibility(term,"eligible",msg);}
    norm.confidence_notes=norm.confidence_notes?`${norm.confidence_notes} ${msg}`:msg;
    return norm;
  }
  const mode=normalizeMode(cfg);
  const groundingPolicy=resolveGroundingPolicy(cfg);
  const groundingTermBudget=(()=>{const raw=Number(cfg?.groundingTermBudget);if(!Number.isFinite(raw)||raw<0) return Number.POSITIVE_INFINITY;return Math.floor(raw);})();
  let groundedTermAttempts=0;
  const notes=[`mode ${groundingPolicy.mode}; q_min ${groundingPolicy.minQualityScore.toFixed(2)}; a_min ${groundingPolicy.minAlignmentScore.toFixed(2)}${groundingPolicy.annotateOnly?"; annotate-only":""}${groundingPolicy.allowCategoryMismatch?"; category-guard override":""}`];
  const citations=[...(norm.citations||[])];
  for(const term of terms){
    if(!term?.label) continue;
    if(Number.isFinite(groundingTermBudget)&&groundingTermBudget!==Number.POSITIVE_INFINITY&&groundedTermAttempts>=groundingTermBudget){
      setTermGroundingEligibility(term,"skipped_budget",`Grounding term budget reached (${groundingTermBudget}).`);
      notes.push(`${term.label}: skipped by grounding budget (${groundingTermBudget})`);
      continue;
    }
    setTermGroundingEligibility(term,"eligible","");
    groundedTermAttempts++;
    applyDisplayDescriptionForTerm(term,{fallbackDescription:term.description,fallbackSource:term.description_source||"llm"});
    const termCacheKey=buildWolframTermCacheKey(term,target,discName);
    const cachedTerm=getWolframTermCache(termCacheKey);
    if(cachedTerm&&typeof cachedTerm==="object"){
      const entityRefCached=buildWolframEntityRef(term.wolfram_entity);
      const queriesTried=Array.isArray(cachedTerm.queriesTried)?cachedTerm.queriesTried.map(x=>String(x||"").trim()).filter(Boolean):[];
      const interpretations=Array.isArray(cachedTerm.interpretations)?cachedTerm.interpretations.map(x=>String(x||"").trim()).filter(Boolean):[];
      const resolutionText=String(cachedTerm.resolutionText||"").trim();
      const chosenInterpretation=String(cachedTerm.chosenInterpretation||"").trim();
      const chosen=cachedTerm.chosen&&typeof cachedTerm.chosen==="object"?cachedTerm.chosen:null;
      const stopReason=String(cachedTerm.stopReason||"").trim();
      term.description_source=String(term.description_source||"").trim().toLowerCase()||"llm";
      term.description_provenance=mergeDescriptionProvenance(term.description_provenance,[{source:term.description_source,stage:"probe",discName,note:term.description_source==="wolfram"?"Wolfram text present before grounding pass":"Probe model description"}]);
      if(chosen){
        const scoring=scoreWolframSnippet(String(chosen.definition||""),term.label,groundingPolicy.minQualityScore,groundingPolicy.minAlignmentScore,{chosenInterpretation:chosenInterpretation||String(chosen?.chosenInterpretation||""),parsed:chosen?.parsed||{},entityType:term?.wolfram_entity?.type||"",chosenPod:String(chosen?.chosenPod||resolveWolframChosenPod(chosen?.parsed,chosen?.definition)||"")});
        const categoryGate=evaluateGroundingCategoryMismatch({termLabel:term.label,entityType:term?.wolfram_entity?.type||"",chosenInterpretation:chosenInterpretation||String(chosen?.chosenInterpretation||""),definition:String(chosen.definition||""),parsed:chosen?.parsed||{},chosenPod:String(chosen?.chosenPod||resolveWolframChosenPod(chosen?.parsed,chosen?.definition)||""),policy:groundingPolicy,scoring});
        const baseDecision=evaluateGroundingApplication(scoring,groundingPolicy);
        const driftDecision=applySingleWordDriftGuard(baseDecision,scoring);
        const warningDecision=applyWarningAssumptionRiskGuard(driftDecision,scoring);
        const compositeDecision=applyCompositeTermAppendGuard(warningDecision,scoring,{termLabel:term.label,definition:String(chosen.definition||""),chosenInterpretation:chosenInterpretation||String(chosen?.chosenInterpretation||""),parsed:chosen?.parsed||{}});
        const decision=applyGroundingCategoryMismatchGuard(compositeDecision,categoryGate);
        const accepted=Boolean(decision.accepted);
        const appliedToDescription=Boolean(decision.applyToDescription);
        const status=String(decision.status||"rejected_low_confidence");
        const decisionReasons=[...(Array.isArray(scoring.reasons)?scoring.reasons:[]),...(Array.isArray(decision.reasons)?decision.reasons:[])];
        const groundingStatus=appliedToDescription?"grounded":accepted?"partial":"failed";
        term.grounding=mergeGroundingBlocks(term.grounding,normalizeGroundingBlock({wolframQueriesTried:queriesTried,wolframInterpretations:interpretations,wolframEntities:[entityRefCached],wolframResolution:resolutionText,wolframChosenInterpretation:chosenInterpretation,groundingStatus,wolframConfidence:{level:String(scoring.confidence||"none"),score:Number.isFinite(Number(scoring.score))?Number(scoring.score):null}}));
        term.descriptions=normalizeTermDescriptions(term.descriptions,{label:term.label});
        if(accepted){
          const layerText=buildWolframLayerTextForPolicy({...chosen,scoring},groundingPolicy,term.label);
          term.descriptions.wolframGrounding=mergeDescription(term.descriptions.wolframGrounding,layerText);
        }
        term.descriptions.wolframDisplayMode=appliedToDescription?"append":"metadata_only";
        term.descriptions.wolframMinScore=groundingPolicy.minQualityScore;
        term.descriptions.wolframMinAlignmentScore=groundingPolicy.minAlignmentScore;
        applyDisplayDescriptionForTerm(term,{fallbackSource:term.description_source});
        const displayUsesWolfram=appliedToDescription&&String(term?.descriptions?.displayDescriptionReason||"").includes("wolframGrounding");
        if(accepted){
          const impact=displayUsesWolfram?"display_description_enriched":"metadata_only";
          term.description_provenance=mergeDescriptionProvenance(term.description_provenance,[{source:"wolfram",stage:"grounding",discName,status,impact,query:String(chosen.query||""),note:`Cache hit. ${resolutionText}${stopReason?`; ${stopReason}`:""}`}]);
        }else{
          const rejectNote=status==="rejected_category_mismatch"?`Cache hit. Category mismatch guard retained snippet as metadata. ${resolutionText}`:`Cache hit. Low confidence snippet retained as metadata. ${resolutionText}`;
          term.description_provenance=mergeDescriptionProvenance(term.description_provenance,[{source:"wolfram",stage:"grounding",discName,status,impact:"metadata_only",query:String(chosen.query||""),note:rejectNote}]);
        }
        const chosenForCache={query:chosen.query,rank:chosen.rank,strategy:chosen.strategy,resolutionLabel:chosen.resolutionLabel,definition:chosen.definition,chosenInterpretation:chosen.chosenInterpretation,chosenPod:String(chosen?.chosenPod||resolveWolframChosenPod(chosen?.parsed,chosen?.definition)||""),accepted,appliedToDescription,status,scoring:{score:scoring.score,snippet_quality_score:scoring.snippet_quality_score,semantic_alignment_score:scoring.semantic_alignment_score,confidence:scoring.confidence,reasons:decisionReasons},parsed:serializeWolframParsed(chosen.parsed)};
        const cite=buildWolframGroundingCitation(term.label,chosenForCache,accepted,resolutionText||"resolved from cache",{appliedToDescription,policyMode:groundingPolicy.mode});
        if(cite) citations.push(cite);
        recordWolframGroundingDiagnostic({target,discName,termLabel:term.label,attemptRank:Number.isFinite(Number(chosen.rank))?Number(chosen.rank):null,attemptStrategy:String(chosen.strategy||""),resolutionLabel:String(chosen.resolutionLabel||""),stopReason:stopReason||"cache_hit_term",query:String(chosen.query||""),snippet:String(chosen.definition||""),accepted,status,score:Number.isFinite(Number(scoring.score))?Number(scoring.score):0,snippetQualityScore:Number.isFinite(Number(scoring?.snippet_quality_score))?Number(scoring.snippet_quality_score):null,semanticAlignmentScore:Number.isFinite(Number(scoring?.semantic_alignment_score))?Number(scoring.semantic_alignment_score):null,confidence:String(scoring.confidence||"low"),reasons:decisionReasons,inputInterpretation:String(chosen?.parsed?.inputInterpretation||""),bestDefinition:String(chosen?.parsed?.bestDefinition||""),altFacts:Array.isArray(chosen?.parsed?.altFacts)?chosen.parsed.altFacts:[],assumptions:Array.isArray(chosen?.parsed?.assumptions)?chosen.parsed.assumptions:[],didYouMeans:Array.isArray(chosen?.parsed?.didYouMeans)?chosen.parsed.didYouMeans:[],warnings:Array.isArray(chosen?.parsed?.warnings)?chosen.parsed.warnings:[],chosenInterpretation:chosenInterpretation,mode,cacheStatus:"term_hit",statusCode:200,durationMs:0,chosenPod:String(chosenForCache.chosenPod||""),appliedToDescription:displayUsesWolfram,success:true});
        notes.push(`${term.label}: term-cache hit (${resolutionText||"resolved from cache"})`);
      }else{
        term.grounding=mergeGroundingBlocks(term.grounding,normalizeGroundingBlock({wolframQueriesTried:queriesTried,wolframInterpretations:interpretations,wolframEntities:[entityRefCached],wolframResolution:resolutionText,groundingStatus:"failed",wolframConfidence:{level:"low",score:0}}));
        term.description_provenance=mergeDescriptionProvenance(term.description_provenance,[{source:"wolfram",stage:"grounding",discName,status:"no_plaintext",impact:"metadata_only",query:queriesTried.join(" || "),note:`Cache hit: no usable plaintext across prior attempts`}]);
        recordWolframGroundingDiagnostic({target,discName,termLabel:term.label,status:"cache_hit_term_no_match",accepted:false,score:0,confidence:"low",reasons:["empty","parser_selection_exhausted"],query:queriesTried[0]||"",stopReason:"cache_hit_term",mode,cacheStatus:"term_hit",statusCode:200,durationMs:0,chosenPod:"",appliedToDescription:false,success:true});
        notes.push(`${term.label}: term-cache hit (no prior usable match)`);
      }
      continue;
    }
    const attempts=buildWolframEntityQueryAttempts(term,target,discName);
    if(!attempts.length){
      setTermGroundingEligibility(term,"eligible","No Wolfram query attempts generated for this term.");
      notes.push(`${term.label}: no Wolfram query attempts available`);
      continue;
    }
    const entityRef=buildWolframEntityRef(term.wolfram_entity);
    term.description_source=String(term.description_source||"").trim().toLowerCase()||"llm";
    term.description_provenance=mergeDescriptionProvenance(term.description_provenance,[{source:term.description_source,stage:"probe",discName,note:term.description_source==="wolfram"?"Wolfram text present before grounding pass":"Probe model description"}]);
    term.grounding=mergeGroundingBlocks(term.grounding,normalizeGroundingBlock({wolframQueriesTried:attempts.map(a=>a.query),wolframEntities:[entityRef],groundingStatus:"failed"}));
    let bestAccepted=null;
    let bestObserved=null;
    let stopReason="";
    const attemptRecords=[];
    const interpretationPool=[];
    for(const attempt of attempts){
      const {rank,strategy,query,resolutionLabel}=attempt;
      const attemptStarted=Date.now();
      try{
        const data=await fetchWolframJSON(query,cfg,{target,discName,termLabel:term.label,attemptRank:rank,attemptStrategy:strategy,resolutionLabel});
        const fetchAudit=(data&&typeof data==="object"&&data.__waAudit&&typeof data.__waAudit==="object")?data.__waAudit:{};
        const attemptDuration=Number.isFinite(Number(fetchAudit?.durationMs))?Number(fetchAudit.durationMs):Date.now()-attemptStarted;
        const attemptStatusCode=Number.isFinite(Number(fetchAudit?.statusCode))?Number(fetchAudit.statusCode):200;
        const attemptCacheStatus=normalizeWolframCacheStatus(fetchAudit?.cacheStatus||"memory_miss");
        const parsed=extractWolframStructured(data);
        const selected=selectWolframSnippetFromParsed(parsed);
        const definition=String(selected?.snippet||"").trim();
        const chosenInterpretation=String(selected?.chosenInterpretation||parsed.inputInterpretation||parsed.bestDefinition||"").trim();
        const chosenPod=resolveWolframChosenPod(parsed,definition);
        const interpretations=[parsed.inputInterpretation,...(parsed.didYouMeans||[]),...(parsed.altFacts||[])].filter(Boolean);
        for(const text of interpretations){if(text) interpretationPool.push(String(text));}
        term.grounding=mergeGroundingBlocks(term.grounding,normalizeGroundingBlock({wolframInterpretations:interpretations,wolframEntities:[entityRef],groundingStatus:"failed",wolframChosenInterpretation:chosenInterpretation}));
        if(Array.isArray(parsed.didYouMeans)&&parsed.didYouMeans.length){
          notes.push(`${term.label}: ${resolutionLabel} alternatives -> ${parsed.didYouMeans.slice(0,3).join(", ")}`);
        }
        if(Array.isArray(parsed.warnings)&&parsed.warnings.length){
          notes.push(`${term.label}: ${resolutionLabel} warnings -> ${parsed.warnings.slice(0,2).join(" | ")}`);
        }
        if(!definition){
          const noPlaintextReasons=buildNoPlaintextReasons(parsed);
          attemptRecords.push({rank,strategy,query,resolutionLabel,status:"no_plaintext",accepted:false,score:0,confidence:"low",reasons:noPlaintextReasons,definition:"",chosenInterpretation,chosenPod,parsed:serializeWolframParsed(parsed)});
          recordWolframGroundingDiagnostic({target,discName,termLabel:term.label,attemptRank:rank,attemptStrategy:strategy,resolutionLabel,query,snippet:"",accepted:false,status:"no_plaintext",score:0,confidence:"low",reasons:noPlaintextReasons,inputInterpretation:parsed.inputInterpretation,bestDefinition:parsed.bestDefinition,altFacts:parsed.altFacts,assumptions:parsed.assumptions,didYouMeans:parsed.didYouMeans,warnings:parsed.warnings,chosenInterpretation,mode,durationMs:attemptDuration,statusCode:attemptStatusCode,cacheStatus:attemptCacheStatus,chosenPod,appliedToDescription:false,success:true});
          continue;
        }
        const scoring=scoreWolframSnippet(definition,term.label,groundingPolicy.minQualityScore,groundingPolicy.minAlignmentScore,{chosenInterpretation,parsed,entityType:term?.wolfram_entity?.type||"",chosenPod});
        const categoryGate=evaluateGroundingCategoryMismatch({termLabel:term.label,entityType:term?.wolfram_entity?.type||"",chosenInterpretation,definition,parsed,chosenPod,policy:groundingPolicy,scoring});
        const baseDecision=evaluateGroundingApplication(scoring,groundingPolicy);
        const driftDecision=applySingleWordDriftGuard(baseDecision,scoring);
        const warningDecision=applyWarningAssumptionRiskGuard(driftDecision,scoring);
        const compositeDecision=applyCompositeTermAppendGuard(warningDecision,scoring,{termLabel:term.label,definition,chosenInterpretation,parsed});
        const decision=applyGroundingCategoryMismatchGuard(compositeDecision,categoryGate);
        const accepted=Boolean(decision.accepted);
        const status=String(decision.status||"rejected_low_confidence");
        const attemptReasons=[...(Array.isArray(scoring.reasons)?scoring.reasons:[]),...(Array.isArray(decision.reasons)?decision.reasons:[])];
        const candidate={query,rank,strategy,resolutionLabel,parsed:serializeWolframParsed(parsed),definition,chosenInterpretation,chosenPod,scoring,decision,status,cacheStatus:attemptCacheStatus,statusCode:attemptStatusCode,durationMs:attemptDuration};
        attemptRecords.push({rank,strategy,query,resolutionLabel,status,accepted,appliedToDescription:Boolean(decision.applyToDescription),score:scoring.score,confidence:scoring.confidence,reasons:attemptReasons,definition,chosenInterpretation,chosenPod,cacheStatus:attemptCacheStatus,statusCode:attemptStatusCode,durationMs:attemptDuration,parsed:candidate.parsed});
        if(!bestObserved||Number(candidate.scoring.score)>Number(bestObserved.scoring.score)) bestObserved=candidate;
        if(accepted&&(!bestAccepted||Number(candidate.scoring.score)>Number(bestAccepted.scoring.score))) bestAccepted=candidate;
        if(accepted&&scoring.confidence==="high"){
          stopReason=`stopped after high-confidence match at ${resolutionLabel}`;
          recordWolframGroundingDiagnostic({target,discName,termLabel:term.label,attemptRank:rank,attemptStrategy:strategy,resolutionLabel,stopReason,query,snippet:definition,accepted,status,score:scoring.score,snippetQualityScore:Number.isFinite(Number(scoring?.snippet_quality_score))?Number(scoring.snippet_quality_score):null,semanticAlignmentScore:Number.isFinite(Number(scoring?.semantic_alignment_score))?Number(scoring.semantic_alignment_score):null,confidence:scoring.confidence,reasons:attemptReasons,inputInterpretation:candidate.parsed.inputInterpretation,bestDefinition:candidate.parsed.bestDefinition,altFacts:candidate.parsed.altFacts,assumptions:candidate.parsed.assumptions,didYouMeans:candidate.parsed.didYouMeans,warnings:candidate.parsed.warnings,chosenInterpretation,mode,durationMs:attemptDuration,statusCode:attemptStatusCode,cacheStatus:attemptCacheStatus,chosenPod,appliedToDescription:false,success:true});
          break;
        }
        recordWolframGroundingDiagnostic({target,discName,termLabel:term.label,attemptRank:rank,attemptStrategy:strategy,resolutionLabel,query,snippet:definition,accepted,status,score:scoring.score,snippetQualityScore:Number.isFinite(Number(scoring?.snippet_quality_score))?Number(scoring.snippet_quality_score):null,semanticAlignmentScore:Number.isFinite(Number(scoring?.semantic_alignment_score))?Number(scoring.semantic_alignment_score):null,confidence:scoring.confidence,reasons:attemptReasons,inputInterpretation:candidate.parsed.inputInterpretation,bestDefinition:candidate.parsed.bestDefinition,altFacts:candidate.parsed.altFacts,assumptions:candidate.parsed.assumptions,didYouMeans:candidate.parsed.didYouMeans,warnings:candidate.parsed.warnings,chosenInterpretation,mode,durationMs:attemptDuration,statusCode:attemptStatusCode,cacheStatus:attemptCacheStatus,chosenPod,appliedToDescription:false,success:true});
      }catch(err){
        const attemptDuration=Date.now()-attemptStarted;
        notes.push(`${term.label}: ${resolutionLabel} -> ${err.message||err}`);
        attemptRecords.push({rank,strategy,query,resolutionLabel,status:"error",accepted:false,score:0,confidence:"low",reasons:["query_failed"],definition:"",chosenInterpretation:"",parsed:serializeWolframParsed({}),error:String(err?.message||err)});
        term.description_provenance=mergeDescriptionProvenance(term.description_provenance,[{source:"wolfram",stage:"grounding",discName,status:"error",impact:"metadata_only",query,note:`${resolutionLabel}: ${String(err?.message||err)}`}]);
        term.grounding=mergeGroundingBlocks(term.grounding,normalizeGroundingBlock({groundingStatus:"failed",wolframConfidence:{level:"low",score:0}}));
        recordWolframGroundingDiagnostic({target,discName,termLabel:term.label,attemptRank:rank,attemptStrategy:strategy,resolutionLabel,query,snippet:"",accepted:false,status:"error",score:0,confidence:"low",reasons:["query_failed"],error:String(err?.message||err),mode,durationMs:attemptDuration,statusCode:0,cacheStatus:"memory_miss",chosenPod:"",appliedToDescription:false,success:false});
      }
    }
    const chosen=bestAccepted||bestObserved;
    if(chosen){
      const fallbackGate=evaluateGroundingCategoryMismatch({termLabel:term.label,entityType:term?.wolfram_entity?.type||"",chosenInterpretation:String(chosen?.chosenInterpretation||chosen?.parsed?.inputInterpretation||""),definition:String(chosen?.definition||""),parsed:chosen?.parsed||{},chosenPod:String(chosen?.chosenPod||""),policy:groundingPolicy,scoring:chosen?.scoring||null});
      const baseDecision=chosen.decision&&typeof chosen.decision==="object"?chosen.decision:evaluateGroundingApplication(chosen.scoring,groundingPolicy);
      const driftDecision=applySingleWordDriftGuard(baseDecision,chosen.scoring);
      const warningDecision=applyWarningAssumptionRiskGuard(driftDecision,chosen.scoring);
      const compositeDecision=applyCompositeTermAppendGuard(warningDecision,chosen.scoring,{termLabel:term.label,definition:String(chosen?.definition||""),chosenInterpretation:String(chosen?.chosenInterpretation||chosen?.parsed?.inputInterpretation||""),parsed:chosen?.parsed||{}});
      const decision=applyGroundingCategoryMismatchGuard(compositeDecision,fallbackGate);
      const accepted=Boolean(decision.accepted);
      const appliedToDescription=Boolean(decision.applyToDescription);
      const status=String(decision.status||"rejected_low_confidence");
      const resolutionText=`resolved via ${chosen.resolutionLabel}`;
      const combinedReasons=[...(Array.isArray(chosen?.scoring?.reasons)?chosen.scoring.reasons:[]),...(Array.isArray(decision.reasons)?decision.reasons:[])];
      const groundingStatus=appliedToDescription?"grounded":accepted?"partial":"failed";
      term.grounding=mergeGroundingBlocks(term.grounding,normalizeGroundingBlock({wolframConfidence:{level:chosen.scoring.confidence,score:chosen.scoring.score},groundingStatus,wolframResolution:resolutionText,wolframChosenInterpretation:chosen.chosenInterpretation,wolframInterpretations:interpretationPool}));
      term.descriptions=normalizeTermDescriptions(term.descriptions,{label:term.label});
      if(accepted){
        const layerText=buildWolframLayerTextForPolicy(chosen,groundingPolicy,term.label);
        term.descriptions.wolframGrounding=mergeDescription(term.descriptions.wolframGrounding,layerText);
      }
      term.descriptions.wolframDisplayMode=appliedToDescription?"append":"metadata_only";
      term.descriptions.wolframMinScore=groundingPolicy.minQualityScore;
      term.descriptions.wolframMinAlignmentScore=groundingPolicy.minAlignmentScore;
      applyDisplayDescriptionForTerm(term,{fallbackSource:term.description_source});
      const displayUsesWolfram=appliedToDescription&&String(term?.descriptions?.displayDescriptionReason||"").includes("wolframGrounding");
      recordWolframGroundingDiagnostic({target,discName,termLabel:term.label,attemptRank:Number.isFinite(Number(chosen.rank))?Number(chosen.rank):null,attemptStrategy:String(chosen.strategy||""),resolutionLabel:String(chosen.resolutionLabel||""),stopReason:stopReason||"selected_final_candidate",query:String(chosen.query||""),snippet:String(chosen.definition||""),accepted,status,score:Number.isFinite(Number(chosen?.scoring?.score))?Number(chosen.scoring.score):0,snippetQualityScore:Number.isFinite(Number(chosen?.scoring?.snippet_quality_score))?Number(chosen.scoring.snippet_quality_score):null,semanticAlignmentScore:Number.isFinite(Number(chosen?.scoring?.semantic_alignment_score))?Number(chosen.scoring.semantic_alignment_score):null,confidence:String(chosen?.scoring?.confidence||"low"),reasons:combinedReasons,inputInterpretation:String(chosen?.parsed?.inputInterpretation||""),bestDefinition:String(chosen?.parsed?.bestDefinition||""),altFacts:Array.isArray(chosen?.parsed?.altFacts)?chosen.parsed.altFacts:[],assumptions:Array.isArray(chosen?.parsed?.assumptions)?chosen.parsed.assumptions:[],didYouMeans:Array.isArray(chosen?.parsed?.didYouMeans)?chosen.parsed.didYouMeans:[],warnings:Array.isArray(chosen?.parsed?.warnings)?chosen.parsed.warnings:[],chosenInterpretation:String(chosen?.chosenInterpretation||""),mode,durationMs:Number.isFinite(Number(chosen?.durationMs))?Number(chosen.durationMs):null,statusCode:Number.isFinite(Number(chosen?.statusCode))?Number(chosen.statusCode):200,cacheStatus:String(chosen?.cacheStatus||"memory_miss"),chosenPod:String(chosen?.chosenPod||""),appliedToDescription:displayUsesWolfram,success:true});
      if(accepted){
        const impact=displayUsesWolfram?"display_description_enriched":"metadata_only";
        term.description_provenance=mergeDescriptionProvenance(term.description_provenance,[{source:"wolfram",stage:"grounding",discName,status,impact,query:chosen.query,note:`Scored ${chosen.scoring.score} (${chosen.scoring.confidence}); ${resolutionText}${stopReason?`; ${stopReason}`:""}`}]);
      }else{
        if(combinedReasons.some(r=>String(r||"").startsWith("category_mismatch_"))){notes.push(`${term.label}: category mismatch guard forced metadata-only (${combinedReasons.join(", ")||"unspecified"})`);}else{notes.push(`${term.label}: rejected low-confidence snippet (${combinedReasons.join(", ")||"unspecified"})`);}
        term.description_provenance=mergeDescriptionProvenance(term.description_provenance,[{source:"wolfram",stage:"grounding",discName,status,impact:"metadata_only",query:chosen.query,note:`Rejected snippet (${status}) ${chosen.scoring.score}: ${combinedReasons.join(", ")||"unspecified"}; ${resolutionText}`}]);
      }
      const chosenForCache={query:chosen.query,rank:chosen.rank,strategy:chosen.strategy,resolutionLabel:chosen.resolutionLabel,definition:chosen.definition,chosenInterpretation:chosen.chosenInterpretation,chosenPod:String(chosen?.chosenPod||""),accepted,appliedToDescription,status,scoring:{score:chosen.scoring.score,snippet_quality_score:chosen.scoring.snippet_quality_score,semantic_alignment_score:chosen.scoring.semantic_alignment_score,confidence:chosen.scoring.confidence,reasons:combinedReasons},parsed:serializeWolframParsed(chosen.parsed)};
      const cite=buildWolframGroundingCitation(term.label,chosenForCache,accepted,resolutionText,{appliedToDescription,policyMode:groundingPolicy.mode});
      if(cite) citations.push(cite);
      setWolframTermCache(termCacheKey,{queriesTried:attempts.map(a=>a.query),interpretations:dedupeCasefold(interpretationPool,40),resolutionText,chosenInterpretation:chosen.chosenInterpretation,stopReason,chosen:chosenForCache,attempts:attemptRecords});
      if(stopReason) notes.push(`${term.label}: ${stopReason}`);
    }else{
      notes.push(`${term.label}: no Wolfram plaintext definition found after ${attempts.length} attempts`);
      term.description_provenance=mergeDescriptionProvenance(term.description_provenance,[{source:"wolfram",stage:"grounding",discName,status:"no_plaintext",impact:"metadata_only",query:attempts.map(a=>a.query).join(" || "),note:`No plaintext definition returned across ${attempts.length} fallback attempts`}]);
      term.grounding=mergeGroundingBlocks(term.grounding,normalizeGroundingBlock({groundingStatus:"failed",wolframResolution:`no match after ${attempts.length} attempts`}));
      const fallbackNoPlaintextReasons=[...new Set(["empty","parser_selection_exhausted",...attemptRecords.flatMap(row=>Array.isArray(row?.reasons)?row.reasons:[])])];
      recordWolframGroundingDiagnostic({target,discName,termLabel:term.label,status:"no_plaintext_after_fallbacks",accepted:false,score:0,confidence:"low",reasons:fallbackNoPlaintextReasons,query:String(attempts?.[0]?.query||""),stopReason:`no match after ${attempts.length} attempts`,mode,durationMs:null,statusCode:200,cacheStatus:"memory_miss",chosenPod:"",appliedToDescription:false,success:true});
      setWolframTermCache(termCacheKey,{queriesTried:attempts.map(a=>a.query),interpretations:dedupeCasefold(interpretationPool,40),resolutionText:`no match after ${attempts.length} attempts`,chosenInterpretation:"",stopReason,chosen:null,attempts:attemptRecords});
    }
  }
  const suspiciousAuditNotes=applySuspiciousAcceptanceAuditPass(norm,{target,discName,cfg,citations});
  if(suspiciousAuditNotes.length) notes.push(...suspiciousAuditNotes);
  norm.citations=dedupeCitations(citations);
  if(notes.length){
    const line=`Wolfram grounding notes (${discName}): ${notes.slice(0,4).join(" | ")}${notes.length>4?" ...":""}`;
    norm.confidence_notes=norm.confidence_notes?`${norm.confidence_notes} ${line}`:line;
  }
  return norm;
}
function applySuspiciousAcceptanceAuditPass(norm,{target="",discName="",cfg={},citations=[]}={}){
  const notes=[];
  const terms=Array.isArray(norm?.terms)?norm.terms:[];
  const citeList=Array.isArray(citations)?citations:[];
  const mode=normalizeMode(cfg||{});
  const acceptedStatuses=new Set(["accepted","accepted_metadata_only","accepted_annotation_only"]);
  for(const term of terms){
    if(!term?.label) continue;
    const status=getNodeGroundingStatus(term);
    const displayMode=normalizeWolframDisplayMode(term?.descriptions?.wolframDisplayMode||"auto");
    if(status!=="grounded"||displayMode!=="append") continue;
    const termLabel=String(term.label||"").trim();
    const termKey=toCanonicalKey(termLabel);
    const termWolframCites=citeList.filter(cite=>{
      if(!cite||typeof cite!=="object") return false;
      if(!isWolframGroundingCitation(cite)) return false;
      const supports=(Array.isArray(cite?.supporting_terms)?cite.supporting_terms:[]).some(t=>toCanonicalKey(t)===termKey);
      const titleMatch=toCanonicalKey(cite?.title||"").includes(termKey);
      return supports||titleMatch;
    });
    const hasAcceptedCitation=termWolframCites.some(cite=>acceptedStatuses.has(String(cite?.grounding_status||"").trim().toLowerCase()));
    if(!hasAcceptedCitation&&!hasWolframGrounding(term)) continue;
    const chosenInterpretation=String(term?.grounding?.wolframChosenInterpretation||termWolframCites.find(c=>String(c?.wolfram_input_interpretation||"").trim())?.wolfram_input_interpretation||"").trim();
    const definition=String(term?.descriptions?.wolframGrounding||termWolframCites.find(c=>String(c?.wolfram_best_definition||"").trim())?.wolfram_best_definition||termWolframCites.find(c=>String(c?.quote_or_snippet||"").trim())?.quote_or_snippet||"").trim();
    const warnings=[...new Set(termWolframCites.flatMap(c=>Array.isArray(c?.wolfram_warnings)?c.wolfram_warnings:[]).map(x=>String(x||"").trim()).filter(Boolean))];
    const didYouMeans=[...new Set(termWolframCites.flatMap(c=>Array.isArray(c?.wolfram_did_you_means)?c.wolfram_did_you_means:[]).map(x=>String(x||"").trim()).filter(Boolean))];
    const altFacts=[...new Set(termWolframCites.flatMap(c=>Array.isArray(c?.wolfram_alt_facts)?c.wolfram_alt_facts:[]).map(x=>String(x||"").trim()).filter(Boolean))];
    const confidence=String(term?.grounding?.wolframConfidence?.level||termWolframCites.find(c=>String(c?.grounding_confidence||"").trim())?.grounding_confidence||"medium").toLowerCase();
    const parsed={inputInterpretation:chosenInterpretation,bestDefinition:definition,warnings,didYouMeans,altFacts};
    const audit=evaluateSuspiciousAcceptedGrounding({termLabel,entityType:term?.wolfram_entity?.type||"",chosenInterpretation,definition,warnings,confidence,parsed,chosenPod:String(term?.grounding?.wolframResolution||"")});
    if(!audit.suspicious) continue;
    const reasons=[...new Set([...audit.reasons,"suspicious_acceptance_audit_downgraded"])];
    const fallbackDescription=String(term?.descriptions?.synthesisSummary||term?.descriptions?.probeSummary||"").trim();
    const fallbackSource=fallbackDescription&&String(term?.descriptions?.synthesisSummary||"").trim()?"synthesis":(term.description_source||"llm");
    term.descriptions=normalizeTermDescriptions(term.descriptions,{label:term.label,fallbackDescription,fallbackSource});
    term.descriptions.wolframDisplayMode="metadata_only";
    applyDisplayDescriptionForTerm(term,{fallbackDescription,fallbackSource});
    const queryUsed=Array.isArray(term?.grounding?.wolframQueriesTried)&&term.grounding.wolframQueriesTried.length?String(term.grounding.wolframQueriesTried[0]||"").trim():String(termWolframCites[0]?.url||"").trim();
    term.grounding=mergeGroundingBlocks(term.grounding,normalizeGroundingBlock({groundingStatus:"partial",wolframResolution:mergeDescription(String(term?.grounding?.wolframResolution||""),`suspicious acceptance audit downgraded to metadata_only (${reasons.join(", ")})`)}));
    term.description_provenance=mergeDescriptionProvenance(term.description_provenance,[{source:"wolfram",stage:"grounding_audit",discName,status:"accepted_metadata_only",impact:"metadata_only",query:queryUsed,note:`Suspicious acceptance audit downgraded append: ${reasons.join(", ")}`}]);
    for(const cite of termWolframCites){
      const currentStatus=String(cite?.grounding_status||"").trim().toLowerCase();
      if(currentStatus==="accepted"||currentStatus==="accepted_annotation_only") cite.grounding_status="accepted_metadata_only";
      cite.grounding_reasons=[...new Set([...(Array.isArray(cite?.grounding_reasons)?cite.grounding_reasons:[]),...reasons])];
    }
    recordWolframGroundingDiagnostic({target,discName,termLabel,attemptRank:null,attemptStrategy:"post_grounding_audit",resolutionLabel:"suspicious_acceptance_audit",stopReason:"suspicious_acceptance_audit",query:queryUsed,snippet:definition,accepted:true,status:"accepted_metadata_only",score:Number.isFinite(Number(term?.grounding?.wolframConfidence?.score))?Number(term.grounding.wolframConfidence.score):0,snippetQualityScore:null,semanticAlignmentScore:null,confidence,reasons,inputInterpretation:chosenInterpretation,bestDefinition:definition,altFacts,assumptions:termWolframCites.flatMap(c=>Array.isArray(c?.wolfram_assumptions)?c.wolfram_assumptions:[]),didYouMeans,warnings,chosenInterpretation,mode,statusCode:200,durationMs:0,cacheStatus:"memory_miss",chosenPod:"",appliedToDescription:false,success:true});
    notes.push(`${termLabel}: suspicious acceptance audit downgraded append to metadata-only`);
  }
  return notes;
}
function normalizeOddWidth(width){let w=clampInt(width,31,401);if(w%2===0) w=Math.min(401,w+1);return w;}
function simulateElementaryCA(rule,steps,width){const w=normalizeOddWidth(width);const s=clampInt(steps,16,240);const r=clampInt(rule,0,255);const grid=[];let row=new Array(w).fill(0);row[Math.floor(w/2)]=1;grid.push([...row]);for(let y=1;y<s;y++){const next=new Array(w).fill(0);for(let x=0;x<w;x++){const left=row[x-1]||0;const center=row[x]||0;const right=row[x+1]||0;const idx=(left<<2)|(center<<1)|right;next[x]=(r>>idx)&1;}grid.push(next);row=next;}return {rule:r,steps:s,width:w,grid};}
function computeAutomataMetrics(sim){const grid=sim?.grid||[];const total=grid.length*(sim?.width||0);let alive=0;let transitions=0;let band=0;for(const row of grid){let rowAlive=0;for(let i=0;i<row.length;i++){if(row[i]){alive++;rowAlive++;}if(i>0&&row[i]!==row[i-1]) transitions++;}band=Math.max(band,rowAlive);}const density=total?alive/total:0;const volatility=total?transitions/total:0;const spread=(sim?.width||1)?band/(sim?.width||1):0;return {density,volatility,spread};}
function renderAutomataDataUrl(sim){const grid=sim?.grid||[];const w=sim?.width||0;const h=sim?.steps||0;if(!w||!h) return "";const scale=Math.max(1,Math.floor(360/Math.max(w,h)));const canvas=document.createElement("canvas");canvas.width=w*scale;canvas.height=h*scale;const ctx=canvas.getContext("2d");ctx.fillStyle="#ffffff";ctx.fillRect(0,0,canvas.width,canvas.height);ctx.fillStyle="#111827";for(let y=0;y<h;y++){for(let x=0;x<w;x++){if(grid[y]?.[x]) ctx.fillRect(x*scale,y*scale,scale,scale);}}return canvas.toDataURL("image/png");}
function buildAutomataCommentary(metrics,target,rule){const regime=metrics.volatility>0.38?"highly turbulent":metrics.volatility>0.22?"mixed-order":"stable/periodic";const spread=metrics.spread>0.65?"high diffusion":metrics.spread>0.4?"moderate diffusion":"narrow diffusion";return `Rule ${rule} produces a ${regime} evolution regime with ${spread}. For "${target}", this is a simulation lens: outcomes depend on iterating local interactions, not one-step narrative prediction.`;}
async function runComputationalIrreducibilityProbe(target,cfg){const sim=simulateElementaryCA(cfg?.caRule??30,cfg?.caSteps??96,cfg?.caWidth??151);const metrics=computeAutomataMetrics(sim);const imageUrl=renderAutomataDataUrl(sim);const query=`CellularAutomaton[${sim.rule}, {{1}, 0}, {${sim.steps}, ${sim.width}}]`;let wolframNote="";if(cfg?.wolframAppId&&normalizeMode(cfg)==="proxy"){try{const data=await fetchWolframJSON(query,cfg,{target,discName:"Computational Irreducibility",termLabel:`Rule ${sim.rule} Local Interaction Dynamics`,resolutionLabel:"ca_probe"});const parsed=extractWolframStructured(data);const selected=selectWolframSnippetFromParsed(parsed);const txt=String(selected?.snippet||"").trim();if(txt) wolframNote=` Wolfram returned: ${txt.slice(0,180)}.`;if(Array.isArray(parsed.didYouMeans)&&parsed.didYouMeans.length) wolframNote+=` Interpretation alternatives: ${parsed.didYouMeans.slice(0,3).join(", ")}.`;}catch(err){wolframNote=` Wolfram call failed: ${err.message||err}.`;}}else if(cfg?.wolframAppId&&normalizeMode(cfg)!=="proxy"){wolframNote=" Wolfram lookup skipped in direct mode (CORS).";}const commentary=`${buildAutomataCommentary(metrics,target,sim.rule)}${wolframNote}`.trim();CA_PROBE_OUTPUT={rule:sim.rule,steps:sim.steps,width:sim.width,imageUrl,query,metrics,commentary,generatedAt:new Date().toISOString()};const terms=[{label:`Rule ${sim.rule} Local Interaction Dynamics`,centrality:0.96,description:"Micro-update rule where each cell depends on nearest-neighbor state.",grounding:normalizeGroundingBlock({groundingEligibility:"synthetic_local",groundingSkipReason:"Locally simulated CA metric; externally ungrounded by design."},{defaultStatus:"not_attempted"})},{label:"Diffusion Bandwidth",centrality:0.78,description:`Active-cell spread ratio across rows: ${(metrics.spread*100).toFixed(1)}%.`,grounding:normalizeGroundingBlock({groundingEligibility:"synthetic_local",groundingSkipReason:"Locally simulated CA metric; externally ungrounded by design."},{defaultStatus:"not_attempted"})},{label:"Transition Volatility",centrality:0.82,description:`Adjacent-state transition ratio: ${(metrics.volatility*100).toFixed(1)}%.`,grounding:normalizeGroundingBlock({groundingEligibility:"synthetic_local",groundingSkipReason:"Locally simulated CA metric; externally ungrounded by design."},{defaultStatus:"not_attempted"})},{label:"Computational Irreducibility",centrality:0.9,description:"System behavior requires forward simulation; closed-form shortcut is generally unavailable.",grounding:normalizeGroundingBlock({groundingEligibility:"ca_bypassed",groundingSkipReason:"CA probe terms bypass Wolfram grounding in the main grounding loop."},{defaultStatus:"not_attempted"})}];const claims=[`Rule ${sim.rule} density ${(metrics.density*100).toFixed(1)}% across ${sim.steps} steps.`,`Transition volatility ${(metrics.volatility*100).toFixed(1)}% suggests ${metrics.volatility>0.3?"persistent structural churn":"comparatively stable local neighborhoods"}.`,`The modeled regime is ${metrics.spread>0.6?"diffusive":"bounded"} under this initialization.`];const citations=[normalizeCitation({url:wolframPublicInputUrl(query),title:`Wolfram cellular automaton rule ${sim.rule}`,publisher:"Wolfram|Alpha",date:new Date().toISOString().slice(0,10),quote_or_snippet:`CellularAutomaton[${sim.rule}] simulation`,relevance:"Computational probe substrate",source_type:"wolfram",supporting_terms:["Computational Irreducibility","Transition Volatility","Diffusion Bandwidth"]})];return {summary:commentary,terms,claims_or_findings:claims,citations,confidence_notes:"CA probe is simulation-based with centered single-cell initialization and finite boundary conditions."};}
function renderCAPanel(){const panel=document.getElementById("ca-panel");if(!panel) return;const titleEl=document.getElementById("ca-title");const metaEl=document.getElementById("ca-meta");const imgEl=document.getElementById("ca-image");const commentaryEl=document.getElementById("ca-commentary");if(!CA_PROBE_OUTPUT){panel.style.display="none";if(imgEl) imgEl.removeAttribute("src");if(titleEl) titleEl.textContent="";if(metaEl) metaEl.textContent="";if(commentaryEl) commentaryEl.textContent="";return;}panel.style.display="flex";if(titleEl) titleEl.textContent=`Rule ${CA_PROBE_OUTPUT.rule} cellular automaton`;const m=CA_PROBE_OUTPUT.metrics||{};if(metaEl) metaEl.textContent=`steps ${CA_PROBE_OUTPUT.steps} | width ${CA_PROBE_OUTPUT.width} | density ${(Number(m.density||0)*100).toFixed(1)}% | volatility ${(Number(m.volatility||0)*100).toFixed(1)}%`;if(imgEl&&CA_PROBE_OUTPUT.imageUrl) imgEl.src=CA_PROBE_OUTPUT.imageUrl;if(commentaryEl) commentaryEl.textContent=CA_PROBE_OUTPUT.commentary||"";}
function buildSynthesisPrompt(target,probeResults,quality,cfg={}){const allTerms=probeResults.map(r=>`DISCIPLINE ${r.discId} (${DISCS[r.discId]?.name}):\nSummary: ${r.summary}\nTerms: ${(r.terms||[]).map(t=>t.label).join(", ")}\nClaims: ${(r.claims_or_findings||[]).join("; ")}`).join("\n\n");const styleLine=cfg?.promptOutputStyle?`\nStyle preference: ${sanitizePromptMadLib(cfg.promptOutputStyle)}.`:"";const emphasisLine=cfg?.promptLensEmphasis?`\nSynthesis emphasis: ${sanitizePromptMadLib(cfg.promptLensEmphasis)}.`:"";const hardConstraintLine=cfg?.promptHardConstraints?`\nHard constraints: ${sanitizePromptMadLib(cfg.promptHardConstraints,560)}.`:"";return `These are research summaries about "${target}" from ${DISCS.length} independent disciplines:\n\n${allTerms}\n\nIdentify:\n1. CONVERGENT: concepts that appear across 2+ disciplines\n2. CONTRADICTORY: genuine tensions between disciplines\n3. EMERGENT: insights visible only after cross-disciplinary integration${styleLine}${emphasisLine}${hardConstraintLine}\n\nReturn only this JSON:\n{\n  "convergent": [\n    {"label": "shared concept", "disciplines": [0,1,3], "description": "why it converges"}\n  ],\n  "contradictory": [\n    {"label": "tension description", "disciplines": [0,2], "description": "what the tension is"}\n  ],\n  "emergent": [\n    {"label": "synthesis insight", "description": "what appears only in integration"}\n  ]\n}\n\nInclude ${quality.synthConvergent} convergent, ${quality.synthContradictory} contradictory, and ${quality.synthEmergent} emergent items.`;}
function parseSynthesisRangeMin(spec,fallback=1){const m=String(spec||"").match(/(\d+)/);return m?clampInt(Number(m[1]),0,12):fallback;}
function disciplineIndexFromValue(value){if(Number.isInteger(value)&&value>=0&&value<DISCS.length) return value;const numeric=Number.parseInt(String(value||"").trim(),10);if(Number.isInteger(numeric)&&numeric>=0&&numeric<DISCS.length) return numeric;const key=toCanonicalKey(String(value||""));if(!key) return null;for(const d of DISCS){const nameKey=toCanonicalKey(d?.name||"");const abbrKey=toCanonicalKey(d?.abbr||"");if(key===nameKey||key===abbrKey) return d.id;if(nameKey&&key.includes(nameKey)) return d.id;}const probeMatch=String(value||"").match(/probe\s*(\d+)/i);if(probeMatch){const idx=Math.max(1,Number(probeMatch[1]))-1;if(idx>=0&&idx<DISCS.length) return idx;}return null;}
function coerceSynthesisDisciplines(value){const arr=Array.isArray(value)?value:[value];const ids=[];for(const item of arr){const idx=disciplineIndexFromValue(item);if(Number.isInteger(idx)&&idx>=0&&idx<DISCS.length&&!ids.includes(idx)) ids.push(idx);}return ids;}
function normalizeSynthesisEntry(item,type,index,target){const raw=(item&&typeof item==="object")?item:{};const labelSource=typeof item==="string"?item:String(raw.label||raw.title||raw.name||"").trim();const label=String(labelSource||"").trim()||`${type}_${index+1}`;const description=String(raw.description||raw.rationale||raw.reason||raw.explanation||"").trim();if(type==="emergent"){return {label,description:description||`Cross-probe synthesis around ${target}.`};}const disciplines=coerceSynthesisDisciplines(raw.disciplines||raw.discipline||raw.probes||raw.probe_ids||raw.discIds||[]);return {label,description:description||`${type} relationship synthesized across probe outputs.`,disciplines};}
function buildTermCoverageByDiscipline(probeResults){const coverage=new Map();for(const row of (Array.isArray(probeResults)?probeResults:[])){const discId=Number(row?.discId);if(!Number.isInteger(discId)||discId<0||discId>=DISCS.length) continue;for(const term of (row?.terms||[])){const label=String(term?.label||"").trim();if(!label) continue;const key=toCanonicalKey(label)||label.toLowerCase();if(!coverage.has(key)) coverage.set(key,{label,discIds:new Set()});coverage.get(key).discIds.add(discId);}}return coverage;}
function jaccardFromSets(a,b){const left=a instanceof Set?a:new Set();const right=b instanceof Set?b:new Set();if(!left.size&&!right.size) return 1;let inter=0;for(const v of left){if(right.has(v)) inter++;}const union=left.size+right.size-inter;return union>0?inter/union:0;}
function buildFallbackSynthesisResult({target,probeResults,quality,existing={convergent:[],contradictory:[],emergent:[]}}={}){const minConv=parseSynthesisRangeMin(quality?.synthConvergent,2);const minContr=parseSynthesisRangeMin(quality?.synthContradictory,1);const minEmerg=parseSynthesisRangeMin(quality?.synthEmergent,1);const out={convergent:[...(existing?.convergent||[])],contradictory:[...(existing?.contradictory||[])],emergent:[...(existing?.emergent||[])]};const seenConv=new Set(out.convergent.map(x=>toCanonicalKey(x?.label||"")).filter(Boolean));const seenContr=new Set(out.contradictory.map(x=>toCanonicalKey(x?.label||"")).filter(Boolean));const seenEmerg=new Set(out.emergent.map(x=>toCanonicalKey(x?.label||"")).filter(Boolean));const coverage=buildTermCoverageByDiscipline(probeResults);const convergentCandidates=[...coverage.values()].filter(x=>x.discIds.size>=2).sort((a,b)=>b.discIds.size-a.discIds.size||String(a.label).localeCompare(String(b.label)));for(const cand of convergentCandidates){if(out.convergent.length>=minConv) break;const key=toCanonicalKey(cand.label||"");if(key&&seenConv.has(key)) continue;out.convergent.push({label:cand.label,disciplines:[...cand.discIds].sort((a,b)=>a-b),description:`Observed across ${cand.discIds.size} probes.`});if(key) seenConv.add(key);}if(out.contradictory.length<minContr){const discTermSets=new Map();for(const row of (probeResults||[])){const discId=Number(row?.discId);if(!Number.isInteger(discId)||discId<0||discId>=DISCS.length) continue;const set=new Set((row?.terms||[]).map(t=>toCanonicalKey(String(t?.label||""))).filter(Boolean));discTermSets.set(discId,set);}const pairs=[];for(let i=0;i<DISCS.length;i++){for(let j=i+1;j<DISCS.length;j++){const setA=discTermSets.get(i)||new Set();const setB=discTermSets.get(j)||new Set();if(!setA.size&&!setB.size) continue;const overlap=jaccardFromSets(setA,setB);pairs.push({i,j,overlap});}}pairs.sort((a,b)=>a.overlap-b.overlap);for(const pair of pairs){if(out.contradictory.length>=minContr) break;const discA=DISCS[pair.i]?.name||`Probe ${pair.i+1}`;const discB=DISCS[pair.j]?.name||`Probe ${pair.j+1}`;const label=`${discA} vs ${discB} framing tension`;const key=toCanonicalKey(label);if(key&&seenContr.has(key)) continue;out.contradictory.push({label,disciplines:[pair.i,pair.j],description:`Low term-overlap (${(pair.overlap*100).toFixed(0)}%) suggests differing priors or mechanisms.`});if(key) seenContr.add(key);}}if(out.emergent.length<minEmerg){const convLabels=out.convergent.map(x=>String(x?.label||"").trim()).filter(Boolean);const contrLabel=String(out.contradictory[0]?.label||"").trim();while(out.emergent.length<minEmerg){const idx=out.emergent.length+1;const label=idx===1&&convLabels.length>=2?`${convLabels[0]} x ${convLabels[1]} integration`:`${String(target||"Topic").trim()||"Topic"} synthesis pattern ${idx}`;const desc=idx===1?`Emerges by reconciling convergent motifs with tensions${contrLabel?` (e.g., ${contrLabel})`:""}.`:`Cross-lens synthesis candidate inferred from probe-level structure.`;const key=toCanonicalKey(label);if(key&&seenEmerg.has(key)){break;}out.emergent.push({label,description:desc});if(key) seenEmerg.add(key);}}return out;}
function normalizeSynthesisResult(raw,target,probeResults,quality){const base=raw&&typeof raw==="object"?raw:{};const convRaw=Array.isArray(base.convergent)?base.convergent:[];const contrRaw=Array.isArray(base.contradictory)?base.contradictory:[];const emergRaw=Array.isArray(base.emergent)?base.emergent:[];const convergent=convRaw.map((item,idx)=>normalizeSynthesisEntry(item,"convergent",idx,target)).filter(item=>item.label&&Array.isArray(item.disciplines)&&item.disciplines.length>0);const contradictory=contrRaw.map((item,idx)=>normalizeSynthesisEntry(item,"contradictory",idx,target)).filter(item=>item.label&&Array.isArray(item.disciplines)&&item.disciplines.length>0);const emergent=emergRaw.map((item,idx)=>normalizeSynthesisEntry(item,"emergent",idx,target)).filter(item=>item.label);const fallbacked=buildFallbackSynthesisResult({target,probeResults,quality,existing:{convergent,contradictory,emergent}});return {convergent:fallbacked.convergent,contradictory:fallbacked.contradictory,emergent:fallbacked.emergent};}
async function repairSynthesisJSONWithModel(rawText,contextLabel,cfg){const repairSystem="You repair malformed JSON. Return only valid JSON.";const repairPrompt=`Task context: ${contextLabel}\n\nRepair the malformed JSON below. Preserve meaning and fields. Do not add markdown.\nReturn strict JSON only.\nExpected top-level object keys: convergent, contradictory, emergent.\n\nMalformed text:\n${String(rawText||"").slice(0,24000)}`;return callLLMJSON(repairSystem,repairPrompt,{...cfg,__tempOverride:0,__maxTokens:Math.max(900,Math.floor(getQualityProfile(cfg.qualityMode).maxTokens*0.9))});}
function buildSynthesisCompactFallbackPrompt(target,probeResults,quality){const allTerms=probeResults.map(r=>`${DISCS[r.discId]?.name||`Probe ${r.discId+1}`}: ${(r.terms||[]).slice(0,10).map(t=>String(t?.label||"").trim()).filter(Boolean).join(", ")}`).join("\n");return `Topic: "${target}"\n\nProbe term snapshots:\n${allTerms}\n\nReturn strict JSON only:\n{\n  "convergent":[{"label":"","disciplines":[0,1],"description":""}],\n  "contradictory":[{"label":"","disciplines":[0,2],"description":""}],\n  "emergent":[{"label":"","description":""}]\n}\n\nRules:\n- Include at least ${parseSynthesisRangeMin(quality?.synthConvergent,2)} convergent items\n- Include at least ${parseSynthesisRangeMin(quality?.synthContradictory,1)} contradictory items\n- Include at least ${parseSynthesisRangeMin(quality?.synthEmergent,1)} emergent items\n- disciplines must be integer probe indices\n- no markdown`; }
async function getSynthesisResultWithRecovery(target,probeResults,quality,cfg,{contextLabel="synthesis"}={}){const parseAttempts=[];const rawSamples=[];const parseTry=(label,text)=>{try{return extractJSON(text);}catch(err1){try{return extractJSONLenient(text);}catch(err2){parseAttempts.push(`${label}: ${err1.message||err1}; lenient: ${err2.message||err2}`);return null;}}};const synthDefaults={systemPrompt:buildProbeSystemPrompt(cfg),userPrompt:buildSynthesisPrompt(target,probeResults,quality,cfg)};const synthBundle=resolvePromptBundleWithOverrides("synthesis",{target,cfg,quality,defaults:synthDefaults});const synthMsg=synthBundle.userPrompt;const probeSystem=synthBundle.systemPrompt||synthDefaults.systemPrompt;try{const raw=await callLLMJSON(probeSystem,synthMsg,cfg);rawSamples.push(raw);const parsed=parseTry("initial",raw);if(parsed) return normalizeSynthesisResult(parsed,target,probeResults,quality);}catch(err){parseAttempts.push(`initial call failed: ${err.message||err}`);}try{const rawForRepair=rawSamples.length?rawSamples[rawSamples.length-1]:synthMsg;const repairedRaw=await repairSynthesisJSONWithModel(rawForRepair,`${contextLabel} repair`,cfg);rawSamples.push(repairedRaw);const parsed=parseTry("repair",repairedRaw);if(parsed) return normalizeSynthesisResult(parsed,target,probeResults,quality);}catch(err){parseAttempts.push(`repair call failed: ${err.message||err}`);}try{const retryCfg={...cfg,__tempOverride:Math.max(0,Number(getQualityProfile(cfg.qualityMode).temperature||0.2)-0.08)};const raw=await callLLMJSON(probeSystem,synthMsg,retryCfg);rawSamples.push(raw);const parsed=parseTry("retry",raw);if(parsed) return normalizeSynthesisResult(parsed,target,probeResults,quality);}catch(err){parseAttempts.push(`retry call failed: ${err.message||err}`);}try{const retryRawForRepair=rawSamples.length?rawSamples[rawSamples.length-1]:synthMsg;const repairedRetryRaw=await repairSynthesisJSONWithModel(retryRawForRepair,`${contextLabel} retry-repair`,cfg);rawSamples.push(repairedRetryRaw);const parsed=parseTry("retry-repair",repairedRetryRaw);if(parsed) return normalizeSynthesisResult(parsed,target,probeResults,quality);}catch(err){parseAttempts.push(`retry-repair call failed: ${err.message||err}`);}try{const compactPrompt=buildSynthesisCompactFallbackPrompt(target,probeResults,quality);const raw=await callLLMJSON("You synthesize cross-probe structures. Return strict JSON only.",compactPrompt,{...cfg,__tempOverride:0,__maxTokens:Math.min(Math.max(getQualityProfile(cfg.qualityMode).maxTokens,1500),3000)});rawSamples.push(raw);const parsed=parseTry("compact-fallback",raw);if(parsed) return normalizeSynthesisResult(parsed,target,probeResults,quality);}catch(err){parseAttempts.push(`compact-fallback call failed: ${err.message||err}`);}console.warn(`Synthesis recovery fallback applied (${contextLabel}).`,parseAttempts);return normalizeSynthesisResult({},target,probeResults,quality);}
function buildRedTeamPrompt(target,probeResults,synthResult,cfg={}){const probeSummaries=probeResults.map(r=>`${DISCS[r.discId]?.name}: ${r.summary} | Claims: ${(r.claims_or_findings||[]).join("; ")}`).join("\n");const contradictions=(synthResult.contradictory||[]).map(c=>`${c.label} (${(c.disciplines||[]).map(i=>DISCS[i]?.name||i).join(" vs ")})`).join("\n");const emergent=(synthResult.emergent||[]).map(e=>e.label).join(", ");const focusLine=cfg?.promptArtifactFocus?`\nCritique focus: ${sanitizePromptMadLib(cfg.promptArtifactFocus)}.`:"";const hardConstraintLine=cfg?.promptHardConstraints?`\nRespect hard constraints: ${sanitizePromptMadLib(cfg.promptHardConstraints,560)}.`:"";return `You are a skeptical reviewer. Attack weak joints, missing confounders, overgeneralizations, and citation risks.${focusLine}${hardConstraintLine}\n\nTopic: ${target}\n\nProbe summaries:\n${probeSummaries}\n\nContradictions:\n${contradictions}\n\nEmergent ideas:\n${emergent}\n\nReturn a concise critique with:\n- 3-6 high-risk claims\n- what evidence would falsify them\n- missing perspectives or datasets\n- any citation red flags`;}
async function launchExpedition(){
  const target=document.getElementById("target-input").value.trim();
  if(!target){showToast("Please enter a target concept.");return;}
  const cfg=readApiConfig();
  const quality=getQualityProfile(cfg.qualityMode);
  const cfgError=validateApiConfig(cfg);
  if(cfgError){showToast(cfgError);return;}
  if(normalizeMode(cfg)==="direct"&&location.protocol==="file:"){showToast("Tip: if auth fails in direct mode, serve this file from localhost instead of file://.");}
  sessionConfig=cfg;
  CALL_LOGS=[];
  CITATIONS=[];
  WOLFRAM_GROUNDING_DIAGNOSTICS=[];
  AMBIGUITY_QUEUE=[];
  updateAmbiguityQueueUIState();
  DISC_SIM_MATRIX=null;
  PROJECTION_STABILITY=null;
  CA_PROBE_OUTPUT=null;
  initArtifactStore();
  const discNames=Array.from(document.querySelectorAll(".disc-input")).map(el=>el.value.trim()).filter(Boolean);
  if(discNames.length<2){showToast("Please fill in at least 2 disciplines.");return;}
  const discSpecs=[...discNames.map(name=>({name,kind:"llm"}))];
  if(cfg.enableComputationalIrreducibility){discSpecs.push({name:"Computational Irreducibility",kind:"ca"});}
  const probeSystemDefault=buildProbeSystemPrompt(cfg);
  const probeSystemBundle=resolvePromptBundleWithOverrides("probe_system",{target,cfg,quality,defaults:{systemPrompt:probeSystemDefault,userPrompt:""}});
  const probeSystem=probeSystemBundle.systemPrompt||probeSystemDefault;
  const probeTemplateDefaults={systemPrompt:probeSystem,userPrompt:buildProbeUserPrompt(target,"__DISCIPLINE__",quality,cfg)};
  const probeTemplateBundle=resolvePromptBundleWithOverrides("probe_user",{discName:"__DISCIPLINE__",target,cfg,quality,defaults:probeTemplateDefaults});
  const synthesisDefaults={systemPrompt:buildProbeSystemPrompt(cfg),userPrompt:buildSynthesisPrompt(target,[],quality,cfg)};
  const synthesisBundle=resolvePromptBundleWithOverrides("synthesis",{target,cfg,quality,defaults:synthesisDefaults});
  const redTeamDefaults={systemPrompt:"You are a skeptical reviewer.",userPrompt:buildRedTeamPrompt(target,[],{contradictory:[],emergent:[]},cfg)};
  const redTeamBundle=resolvePromptBundleWithOverrides("artifact_red_team",{target,cfg,quality,defaults:redTeamDefaults});
  const runFingerprint={target,probes:discSpecs.map(x=>x.name),config:safeConfigForRun(cfg),prompts:{probeSystem,probeUserTemplate:probeTemplateBundle.userPrompt,synthTemplate:synthesisBundle.userPrompt,redTeamTemplate:redTeamBundle.userPrompt}};
  CURRENT_RUN_ID=computeRunId(runFingerprint);
  RUN_STATE={runId:CURRENT_RUN_ID,target,config:cfg,probeResults:[],synthResult:{convergent:[],contradictory:[],emergent:[]},generatedAt:new Date().toISOString(),caProbe:null,wolframGroundingDiagnostics:[],ambiguityQueue:[]};
  DISCS=discSpecs.map((spec,i)=>({id:i,name:spec.name,abbr:makeAbbr(spec.name),col:COLORS[i%COLORS.length],kind:spec.kind}));
  isGenerating=true;
  switchMainTab("plot",{silent:true});
  const prog=progressEl;
  prog.style.display="flex";
  document.getElementById("prog-target-label").textContent=`TARGET: ${target.toUpperCase()} | CHAT MODEL: ${cfg.researchModel} | EMBED MODEL: ${cfg.embeddingModel} | QUALITY: ${quality.id.toUpperCase()} | WEB: ${cfg.webSearch?"ON":"OFF"} | WOLFRAM: ${(cfg.wolframEntityGrounding||cfg.enableComputationalIrreducibility)?"ON":"OFF"}`;
  const probeListEl=document.getElementById("probe-list");
  probeListEl.innerHTML="";
  for(const d of DISCS){const el=document.createElement("div");el.className="probe-item";el.innerHTML=`<div class="probe-dot idle" id="dot-${d.id}"></div><span class="probe-name" style="color:${d.col}">${d.name}</span><span class="probe-status" id="status-${d.id}">QUEUED</span>`;probeListEl.appendChild(el);}
  const probePromises=DISCS.map(async(d)=>{
    if(d.kind==="ca"){
      setProbeState(d.id,"running","SIMULATING...");
      try{
        const simNorm=await runComputationalIrreducibilityProbe(target,cfg);
        setProbeState(d.id,"done",`${simNorm.terms?.length||0} TERMS`);
        return {discId:d.id,summary:simNorm.summary,terms:Array.isArray(simNorm.terms)?simNorm.terms:[],claims_or_findings:simNorm.claims_or_findings,citations:simNorm.citations,confidence_notes:simNorm.confidence_notes};
      }catch(err){
        setProbeState(d.id,"error","ERROR");
        console.error("Computational irreducibility probe failed:",err);
        return {discId:d.id,summary:"",terms:[],claims_or_findings:[],citations:[],confidence_notes:""};
      }
    }
    setProbeState(d.id,"running","RESEARCHING...");
    try{
      const probeDefaults={systemPrompt:probeSystem,userPrompt:buildProbeUserPrompt(target,d.name,quality,cfg)};
      const probeBundle=resolvePromptBundleWithOverrides("probe_user",{discName:d.name,target,cfg,quality,defaults:probeDefaults});
      let norm=await getProbeResultWithRecovery({target,discName:d.name,probeSystem:probeBundle.systemPrompt||probeSystem,userMsg:probeBundle.userPrompt,cfg});
      norm=await groundProbeTermsWithWolfram(norm,target,d.name,cfg);
      setProbeState(d.id,"done",`${norm.terms?.length||0} TERMS`);
      return {discId:d.id,summary:norm.summary,terms:Array.isArray(norm.terms)?norm.terms:[],claims_or_findings:norm.claims_or_findings,citations:norm.citations,confidence_notes:norm.confidence_notes};
    }catch(err){
      setProbeState(d.id,"error","ERROR");
      console.error(`Probe ${d.name} failed:`,err);
      return {discId:d.id,summary:"",terms:[],claims_or_findings:[],citations:[],confidence_notes:""};
    }
  });
  const probeResults=await Promise.all(probePromises);
  RUN_STATE.probeResults=probeResults;
  RUN_STATE.caProbe=CA_PROBE_OUTPUT;
  const synthBar=document.getElementById("synth-bar");
  synthBar.className="synth-bar running";
  synthBar.textContent="SYNTHESIS - identifying convergences, contradictions, emergent features...";
  let synthResult={convergent:[],contradictory:[],emergent:[]};
  try{
    synthResult=await getSynthesisResultWithRecovery(target,probeResults,quality,cfg,{contextLabel:"launch"});
    synthBar.className="synth-bar done";
    synthBar.textContent=`SYNTHESIS COMPLETE - ${synthResult.convergent?.length||0} convergent | ${synthResult.contradictory?.length||0} contradictions | ${synthResult.emergent?.length||0} emergent`;
  }catch(err){
    synthBar.className="synth-bar error";
    synthBar.textContent="SYNTHESIS ERROR - proceeding with fallback synthesis";
    console.error("Synthesis failed:",err);
    synthResult=normalizeSynthesisResult({},target,probeResults,quality);
  }
  RUN_STATE.synthResult=synthResult;
  if(quality.cleanup){
    synthBar.className="synth-bar running";
    synthBar.textContent="TERM CLEANUP - resolving near-duplicate wording...";
    try{await applySecondPassCleanup(target,probeResults,synthResult,cfg);synthBar.textContent="TERM CLEANUP COMPLETE";}
    catch(err){console.warn("Cleanup pass failed:",err);synthBar.textContent="TERM CLEANUP SKIPPED - using first pass terms";}
  }
  buildTerms(probeResults,synthResult);
  collectCitations();
  if(TERMS.length){
    synthBar.className="synth-bar running";
    try{
      await assignSemanticPositions(target,cfg,msg=>{synthBar.textContent=msg;});
      synthBar.className="synth-bar done";
      synthBar.textContent=`VECTOR LAYOUT COMPLETE - ${TERMS.length} terms positioned by semantic distance`;
    }catch(err){
      console.error("Embedding layout failed:",err);
      applyFallbackPositions();
      DISC_SIM_MATRIX=null;
      PROJECTION_STABILITY=null;
      synthBar.className="synth-bar error";
      synthBar.textContent="VECTOR LAYOUT ERROR - using fallback geometry";
      showToast("Embedding layout failed. Fallback geometry was applied.");
    }
  }else{
    applyFallbackPositions();
    DISC_SIM_MATRIX=null;
    PROJECTION_STABILITY=null;
  }
  if(cfg.redTeam){await runRedTeamPass(true);}
  LAST_RUN=buildRunSnapshot(target,probeResults,synthResult,cfg);
  syncArtifactStoreFromRun();
  await new Promise(resolve=>setTimeout(resolve,500));
  showViz(target);
}
function setProbeState(id,state,statusText){const dot=document.getElementById(`dot-${id}`);const status=document.getElementById(`status-${id}`);const item=dot?.closest(".probe-item");if(!dot||!status||!item) return;dot.className=`probe-dot ${state}`;item.className=`probe-item ${state}`;status.textContent=statusText;}
function makeAbbr(name){const words=name.split(/[\s/]+/).filter(Boolean);if(words.length>=2) return (words[0][0]+words[1][0]).toUpperCase();return name.substring(0,2).toUpperCase();}
function normalizeLabel(label){return String(label||"").toLowerCase().normalize("NFKD").replace(/[^\w\s]|_/g," ").replace(/\s+/g," ").trim();}
function toCanonicalKey(label){let key=normalizeLabel(label);key=key.replace(/\b(the|a|an)\b/g," ").replace(/\s+/g," ").trim();if(key.endsWith("s")&&key.length>4) key=key.slice(0,-1);return key;}
function tokenSet(label){const parts=toCanonicalKey(label).split(" ").filter(Boolean);return new Set(parts);}
function jaccardSimilarity(a,b){if(!a.size||!b.size) return 0;let common=0;for(const term of a){if(b.has(term)) common++;}return common/(a.size+b.size-common);}
function aliasSimilarityScore(left,right){
  const a=toCanonicalKey(left);
  const b=toCanonicalKey(right);
  if(!a||!b) return 0;
  if(a===b) return 1;
  const aTokens=tokenSet(a);
  const bTokens=tokenSet(b);
  let score=jaccardSimilarity(aTokens,bTokens);
  if(a.includes(b)||b.includes(a)){
    const ratio=Math.min(a.length,b.length)/Math.max(a.length,b.length,1);
    score=Math.max(score,0.72+(0.22*ratio));
  }
  return Math.max(0,Math.min(0.99,score));
}
function matchTermFromAliasCandidate(label,terms){
  const canon=toCanonicalKey(label);
  if(!canon||!Array.isArray(terms)||!terms.length) return null;
  const exact=terms.find(term=>toCanonicalKey(term.label)===canon);
  if(exact) return {term:exact,score:1,strategy:"exact"};
  let best=null;
  let second=null;
  for(const term of terms){
    const score=aliasSimilarityScore(label,term.label);
    if(!best||score>best.score){second=best;best={term,score};}
    else if(!second||score>second.score){second={term,score};}
  }
  if(!best) return null;
  const shortSingleWord=canon.split(" ").length===1&&canon.length<5;
  if(shortSingleWord&&best.score<0.9) return null;
  if(best.score>=0.84&&(!second||best.score-second.score>=0.05)) return {term:best.term,score:best.score,strategy:"fuzzy"};
  return null;
}
function buildTermAliasIndex(){
  const aliasByTerm=new Map();
  const terms=Array.isArray(TERMS)?TERMS:[];
  const addAlias=(term,alias,source)=>{
    if(!term) return;
    const text=String(alias||"").trim();
    const canon=toCanonicalKey(text);
    if(!text||!canon) return;
    let bucket=aliasByTerm.get(term.label);
    if(!bucket){
      bucket={termLabel:term.label,termRef:term,aliases:new Map()};
      aliasByTerm.set(term.label,bucket);
    }
    const existing=bucket.aliases.get(canon);
    if(existing){
      existing.sources=[...new Set([...(existing.sources||[]),source])];
      if(text.length>String(existing.alias||"").length) existing.alias=text;
      return;
    }
    bucket.aliases.set(canon,{alias:text,sources:[source]});
  };
  for(const term of terms){
    addAlias(term,term.label,"merged_label");
    const interpretations=Array.isArray(term?.grounding?.wolframInterpretations)?term.grounding.wolframInterpretations:[];
    for(const interpretation of interpretations){addAlias(term,interpretation,"wolfram_interpretation");}
    if(term?.grounding?.wolframChosenInterpretation){addAlias(term,term.grounding.wolframChosenInterpretation,"wolfram_chosen");}
  }
  for(const probe of (RUN_STATE?.probeResults||[])){
    for(const probeTerm of (probe?.terms||[])){
      const label=String(probeTerm?.label||"").trim();
      if(!label) continue;
      const matched=matchTermFromAliasCandidate(label,terms);
      if(matched?.term) addAlias(matched.term,label,"probe_label");
    }
  }
  for(const key of ["convergent","contradictory","emergent"]){
    for(const item of (RUN_STATE?.synthResult?.[key]||[])){
      const label=String(item?.label||"").trim();
      if(!label) continue;
      const matched=matchTermFromAliasCandidate(label,terms);
      if(matched?.term) addAlias(matched.term,label,"synthesis_label");
    }
  }
  const entries=[];
  const byCanonical=new Map();
  for(const bucket of aliasByTerm.values()){
    const aliasList=[...bucket.aliases.values()].map(item=>String(item.alias||"").trim()).filter(Boolean);
    if(bucket.termRef){bucket.termRef.aliases=dedupeCasefold(aliasList,120);}
    for(const [canon,aliasMeta] of bucket.aliases.entries()){
      const entry={termLabel:bucket.termLabel,canonical:canon,alias:aliasMeta.alias,sources:[...(aliasMeta.sources||[])]};
      entries.push(entry);
      if(!byCanonical.has(canon)) byCanonical.set(canon,[]);
      byCanonical.get(canon).push(entry);
    }
  }
  return {entries,byCanonical};
}
function mapSupportingTermsWithAliases(supportingTermsRaw,aliasIndex){
  const mappedTerms=new Set();
  const mappings=[];
  const unmapped=[];
  const rawTerms=Array.isArray(supportingTermsRaw)?supportingTermsRaw:[];
  const byCanonical=aliasIndex?.byCanonical instanceof Map?aliasIndex.byCanonical:new Map();
  const entries=Array.isArray(aliasIndex?.entries)?aliasIndex.entries:[];
  for(const rawTerm of rawTerms){
    const text=String(rawTerm||"").trim();
    const canon=toCanonicalKey(text);
    if(!text||!canon) continue;
    const exactHits=byCanonical.get(canon)||[];
    if(exactHits.length===1){
      const hit=exactHits[0];
      mappedTerms.add(hit.termLabel);
      mappings.push({supporting_term:text,mapped_term:hit.termLabel,via_alias:hit.alias,strategy:"exact",confidence:1});
      continue;
    }
    if(exactHits.length>1){
      const ranked=[...exactHits].sort((a,b)=>String(b.alias||"").length-String(a.alias||"").length);
      const hit=ranked[0];
      mappedTerms.add(hit.termLabel);
      mappings.push({supporting_term:text,mapped_term:hit.termLabel,via_alias:hit.alias,strategy:"exact_ambiguous",confidence:0.94});
      continue;
    }
    let best=null;
    let second=null;
    for(const entry of entries){
      const score=aliasSimilarityScore(text,entry.alias);
      if(!best||score>best.score){second=best;best={entry,score};}
      else if(!second||score>second.score){second={entry,score};}
    }
    const margin=best&&second?best.score-second.score:best?best.score:0;
    const threshold=canon.split(" ").length<=1?0.9:0.79;
    if(best&&best.score>=threshold&&margin>=0.03){
      mappedTerms.add(best.entry.termLabel);
      mappings.push({supporting_term:text,mapped_term:best.entry.termLabel,via_alias:best.entry.alias,strategy:"fuzzy",confidence:Number(best.score.toFixed(3))});
    }else{
      unmapped.push(text);
    }
  }
  return {mappedTerms:[...mappedTerms],mappings,unmapped:dedupeCasefold(unmapped,120)};
}
function mergeType(a,b){return (TYPE_PRIORITY[b]||0)>(TYPE_PRIORITY[a]||0)?b:a;}
function pickBetterLabel(current,next){if(!current) return next;if(!next) return current;return next.length>current.length?next:current;}
function mergeDescription(a,b){const chunks=[String(a||"").trim(),String(b||"").trim()].filter(Boolean);if(!chunks.length) return "";if(chunks.length===1) return chunks[0];if(chunks[0].toLowerCase()===chunks[1].toLowerCase()) return chunks[0];return `${chunks[0]} ${chunks[1]}`.trim();}
function defaultDescriptionLayers(){return {probeSummary:"",synthesisSummary:"",wolframGrounding:"",displayDescription:"",displayDescriptionReason:"",wolframDisplayMode:"auto",wolframMinScore:null,wolframMinAlignmentScore:null};}
function normalizeWolframDisplayMode(value){const mode=String(value||"").trim().toLowerCase();if(mode==="append"||mode==="metadata_only"||mode==="auto") return mode;return "auto";}
function mergeWolframDisplayMode(left,right){const a=normalizeWolframDisplayMode(left);const b=normalizeWolframDisplayMode(right);if(a==="metadata_only"||b==="metadata_only") return "metadata_only";if(a==="append"||b==="append") return "append";return "auto";}
function inferDescriptionSourceFromLayers(descriptions,fallbackSource){
  const reason=String(descriptions?.displayDescriptionReason||"").toLowerCase();
  if(reason.includes("metadata_only")){
    if(reason.includes("synthesissummary")) return "synthesis";
    if(reason.includes("probesummary")) return "llm";
  }
  if(reason.includes("synthesissummary")&&reason.includes("wolframgrounding")) return "mixed";
  if(reason.includes("probesummary")&&reason.includes("wolframgrounding")) return "mixed";
  if(reason.includes("synthesissummary")) return "synthesis";
  if(reason.includes("probesummary")) return "llm";
  if(reason.includes("wolframgrounding")) return "wolfram";
  return String(fallbackSource||"").trim().toLowerCase()||"llm";
}
function computeDisplayDescriptionFromLayers(label,descriptions){
  const probeSummary=String(descriptions?.probeSummary||"").trim();
  const synthesisSummary=String(descriptions?.synthesisSummary||"").trim();
  const wolframGrounding=String(descriptions?.wolframGrounding||"").trim();
  const wolframDisplayMode=normalizeWolframDisplayMode(descriptions?.wolframDisplayMode||"auto");
  const wolframMinScore=clampGroundingSnippetScore(descriptions?.wolframMinScore,0.58);
  const wolframMinAlignmentScore=clampGroundingSnippetScore(descriptions?.wolframMinAlignmentScore,0.55);
  let display=synthesisSummary||probeSummary||"";
  let reason=synthesisSummary?"synthesisSummary":probeSummary?"probeSummary":"";
  if(!display&&wolframGrounding){
    if(wolframDisplayMode==="metadata_only"){
      return {displayDescription:"",displayDescriptionReason:"wolframGrounding_metadata_only"};
    }
    return {displayDescription:wolframGrounding,displayDescriptionReason:"wolframGrounding_fallback"};
  }
  if(display&&wolframGrounding){
    const scoring=scoreWolframSnippet(wolframGrounding,label||"",wolframMinScore,wolframMinAlignmentScore);
    const canonDisplay=toCanonicalKey(display);
    const canonWolfram=toCanonicalKey(wolframGrounding);
    const isDuplicate=Boolean(canonDisplay&&canonWolfram&&(canonDisplay===canonWolfram||canonDisplay.includes(canonWolfram)||canonWolfram.includes(canonDisplay)));
    const compositeConservative=isCompositeSyntheticTermLabel(label||"");
    const exactConceptMatch=hasExactConceptPhraseMatch(label||"",[wolframGrounding]);
    const highAlignmentMatch=hasHighAlignmentConceptMatch(scoring);
    const compositeAppendSafe=!compositeConservative||exactConceptMatch||highAlignmentMatch;
    const shouldAppend=(wolframDisplayMode==="append"||(wolframDisplayMode==="auto"&&scoring.accept))&&compositeAppendSafe;
    if(shouldAppend&&!isDuplicate){
      display=mergeDescription(display,wolframGrounding);
      reason=`${reason}+wolframGrounding`;
    }else{
      reason=`${reason||"base"};${!compositeAppendSafe?"wolframGrounding_composite_metadata_only":"wolframGrounding_metadata_only"}`;
    }
  }
  if(!display){
    return {displayDescription:"",displayDescriptionReason:"none"};
  }
  return {displayDescription:display,displayDescriptionReason:reason||"probeSummary"};
}
function normalizeTermDescriptions(raw,{fallbackDescription="",fallbackSource="",label=""}={}){
  const base=defaultDescriptionLayers();
  const src=raw&&typeof raw==="object"?raw:{};
  base.probeSummary=String(src.probeSummary||"").trim();
  base.synthesisSummary=String(src.synthesisSummary||"").trim();
  base.wolframGrounding=String(src.wolframGrounding||"").trim();
  base.wolframDisplayMode=normalizeWolframDisplayMode(src.wolframDisplayMode||src.wolfram_display_mode||"auto");
  base.wolframMinScore=Number.isFinite(Number(src.wolframMinScore))?clampGroundingSnippetScore(src.wolframMinScore,0.58):Number.isFinite(Number(src.wolfram_min_score))?clampGroundingSnippetScore(src.wolfram_min_score,0.58):null;
  base.wolframMinAlignmentScore=Number.isFinite(Number(src.wolframMinAlignmentScore))?clampGroundingSnippetScore(src.wolframMinAlignmentScore,0.55):Number.isFinite(Number(src.wolfram_min_alignment_score))?clampGroundingSnippetScore(src.wolfram_min_alignment_score,0.55):null;
  const fallback=String(fallbackDescription||"").trim();
  const source=String(fallbackSource||"").trim().toLowerCase();
  if(fallback){
    if(source==="synthesis") base.synthesisSummary=mergeDescription(base.synthesisSummary,fallback);
    else if(source==="wolfram") base.wolframGrounding=mergeDescription(base.wolframGrounding,fallback);
    else base.probeSummary=mergeDescription(base.probeSummary,fallback);
  }
  const selected=computeDisplayDescriptionFromLayers(label,base);
  base.displayDescription=selected.displayDescription||String(src.displayDescription||"").trim();
  base.displayDescriptionReason=selected.displayDescriptionReason||String(src.displayDescriptionReason||"").trim();
  if(base.displayDescription&&!base.displayDescriptionReason){
    base.displayDescriptionReason=selected.displayDescriptionReason||"derived";
  }
  return base;
}
function mergeTermDescriptions(left,right,label){
  const a=normalizeTermDescriptions(left||{},{label});
  const b=normalizeTermDescriptions(right||{},{label});
  const mergedMinScore=Number.isFinite(Number(a.wolframMinScore))&&Number.isFinite(Number(b.wolframMinScore))?Math.max(Number(a.wolframMinScore),Number(b.wolframMinScore)):Number.isFinite(Number(a.wolframMinScore))?Number(a.wolframMinScore):Number.isFinite(Number(b.wolframMinScore))?Number(b.wolframMinScore):null;
  const mergedMinAlignmentScore=Number.isFinite(Number(a.wolframMinAlignmentScore))&&Number.isFinite(Number(b.wolframMinAlignmentScore))?Math.max(Number(a.wolframMinAlignmentScore),Number(b.wolframMinAlignmentScore)):Number.isFinite(Number(a.wolframMinAlignmentScore))?Number(a.wolframMinAlignmentScore):Number.isFinite(Number(b.wolframMinAlignmentScore))?Number(b.wolframMinAlignmentScore):null;
  return normalizeTermDescriptions({
    probeSummary:mergeDescription(a.probeSummary,b.probeSummary),
    synthesisSummary:mergeDescription(a.synthesisSummary,b.synthesisSummary),
    wolframGrounding:mergeDescription(a.wolframGrounding,b.wolframGrounding),
    wolframDisplayMode:mergeWolframDisplayMode(a.wolframDisplayMode,b.wolframDisplayMode),
    wolframMinScore:mergedMinScore,
    wolframMinAlignmentScore:mergedMinAlignmentScore
  },{label});
}
function applyDisplayDescriptionForTerm(term,{fallbackDescription="",fallbackSource=""}={}){
  if(!term||typeof term!=="object") return term;
  term.descriptions=normalizeTermDescriptions(term.descriptions,{fallbackDescription,fallbackSource,label:term.label||""});
  term.description=String(term.descriptions.displayDescription||fallbackDescription||term.description||"").trim();
  term.description_source=inferDescriptionSourceFromLayers(term.descriptions,term.description_source||fallbackSource||"llm");
  return term;
}
function addRawTerm(raw,node){
  const label=String(node.label||"").trim();
  if(!label) return;
  const slices=Array.isArray(node.slices)?node.slices.filter(i=>Number.isInteger(i)&&i>=0&&i<DISCS.length):[];
  const source=String(node.description_source||"").trim().toLowerCase()||(node.type==="emergent"||node.description_source==="synthesis"?"synthesis":"llm");
  const provenance=mergeDescriptionProvenance(node.description_provenance,[]);
  const grounding=normalizeGroundingBlock(node.grounding,{entityRef:buildWolframEntityRef(node.wolfram_entity),defaultStatus:"not_attempted"});
  const descriptions=normalizeTermDescriptions(node.descriptions,{fallbackDescription:String(node.description||"").trim(),fallbackSource:source,label});
  raw.push({label,descriptions,description:String(descriptions.displayDescription||node.description||"").trim(),centrality:clamp01(Number(node.centrality||0.5)),slices:[...new Set(slices)],type:node.type||"unique",pos:[0,0,0],description_source:inferDescriptionSourceFromLayers(descriptions,source),description_provenance:provenance,grounding});
}
function mergeRawTerms(rawTerms){
  const merged=[];
  for(const node of rawTerms){
    const key=toCanonicalKey(node.label);
    const tokens=tokenSet(node.label);
    let match=merged.find(m=>m.key===key);
    if(!match){
      match=merged.find(m=>jaccardSimilarity(m.tokens,tokens)>=0.86&&Math.abs(m.label.length-node.label.length)<=14&&m.type===node.type);
    }
    if(!match){
      const descriptions=normalizeTermDescriptions(node.descriptions,{fallbackDescription:node.description,fallbackSource:node.description_source,label:node.label});
      merged.push({key,tokens,label:node.label,descriptions,description:descriptions.displayDescription||node.description,centrality:node.centrality,slices:[...node.slices],type:node.type,pos:[0,0,0],description_source:inferDescriptionSourceFromLayers(descriptions,node.description_source||""),description_provenance:mergeDescriptionProvenance(node.description_provenance,[]),grounding:normalizeGroundingBlock(node.grounding)});
      continue;
    }
    match.label=pickBetterLabel(match.label,node.label);
    match.descriptions=mergeTermDescriptions(match.descriptions,node.descriptions,match.label);
    match.description=String(match.descriptions.displayDescription||mergeDescription(match.description,node.description)).trim();
    match.centrality=Math.max(match.centrality,node.centrality);
    match.slices=[...new Set([...match.slices,...node.slices])];
    match.type=mergeType(match.type,node.type);
    match.description_source=inferDescriptionSourceFromLayers(match.descriptions,mergeDescriptionSource(match.description_source,node.description_source));
    match.description_provenance=mergeDescriptionProvenance(match.description_provenance,node.description_provenance);
    match.grounding=mergeGroundingBlocks(match.grounding,node.grounding);
    match.key=toCanonicalKey(match.label);
    match.tokens=tokenSet(match.label);
  }
  for(const term of merged){
    if(term.type==="unique"&&term.slices.length>1) term.type="convergent";
    if(!term.description_source) term.description_source=term.type==="emergent"?"synthesis":"llm";
    applyDisplayDescriptionForTerm(term,{fallbackDescription:term.description,fallbackSource:term.description_source});
    term.grounding=normalizeGroundingBlock(term.grounding,{defaultStatus:"not_attempted"});
  }
  return merged.map(({tokens,key,...rest})=>rest);
}
function buildTerms(probeResults,synthResult){
  const raw=[];
  for(const r of probeResults){
    const d=DISCS[r.discId];
    if(!d) continue;
    for(const term of (r.terms||[])){
      const source=String(term.description_source||"").trim().toLowerCase()||"llm";
      const fallbackNote=source==="wolfram"?"Wolfram grounding applied to description":"Probe model description";
      const provenance=mergeDescriptionProvenance(term.description_provenance,[{source,stage:"probe",discId:r.discId,discName:d.name,note:fallbackNote}]);
      addRawTerm(raw,{label:term.label,description:term.description,descriptions:term.descriptions,centrality:term.centrality,slices:[r.discId],type:"unique",description_source:source,description_provenance:provenance,wolfram_entity:term.wolfram_entity,grounding:normalizeGroundingBlock(term.grounding,{entityRef:buildWolframEntityRef(term.wolfram_entity),defaultStatus:"not_attempted"})});
    }
  }
  for(const item of (synthResult.convergent||[])){
    const ids=(item.disciplines||[]).filter(i=>Number.isInteger(i)&&i>=0&&i<DISCS.length);
    if(!ids.length) continue;
    addRawTerm(raw,{label:item.label,description:item.description,descriptions:{synthesisSummary:String(item.description||"")},centrality:0.6,slices:ids,type:"convergent",description_source:"synthesis",description_provenance:[{source:"synthesis",stage:"synthesis",note:"Cross-probe convergence"}],grounding:normalizeGroundingBlock({groundingEligibility:"eligible",groundingSkipReason:"Synthesis-stage term; direct WA grounding is only attempted on probe-origin terms."},{defaultStatus:"not_attempted"})});
  }
  for(const item of (synthResult.contradictory||[])){
    const ids=(item.disciplines||[]).filter(i=>Number.isInteger(i)&&i>=0&&i<DISCS.length);
    if(!ids.length) continue;
    addRawTerm(raw,{label:item.label,description:item.description,descriptions:{synthesisSummary:String(item.description||"")},centrality:0.5,slices:ids,type:"contradictory",description_source:"synthesis",description_provenance:[{source:"synthesis",stage:"synthesis",note:"Cross-probe contradiction"}],grounding:normalizeGroundingBlock({groundingEligibility:"eligible",groundingSkipReason:"Synthesis-stage term; direct WA grounding is only attempted on probe-origin terms."},{defaultStatus:"not_attempted"})});
  }
  for(const item of (synthResult.emergent||[])){
    addRawTerm(raw,{label:item.label,description:item.description,descriptions:{synthesisSummary:String(item.description||"")},centrality:0.5,slices:[],type:"emergent",description_source:"synthesis",description_provenance:[{source:"synthesis",stage:"synthesis",note:"Emergent synthesis insight"}],grounding:normalizeGroundingBlock({groundingEligibility:"eligible",groundingSkipReason:"Synthesis-stage term; direct WA grounding is only attempted on probe-origin terms."},{defaultStatus:"not_attempted"})});
  }
  TERMS=mergeRawTerms(raw);
}
function collectCitations(){
  const prevCount=CITATIONS.length;
  CITATIONS=[];
  const map=new Map();
  const keyFor=(c)=>{
    if(c.url) return c.url.trim().toLowerCase();
    return `${c.title}|${c.publisher}|${c.date}`.toLowerCase();
  };
  for(const probe of (RUN_STATE?.probeResults||[])){
    for(const cite of (probe.citations||[])){
      const key=keyFor(cite);
      if(!key.trim()) continue;
      let entry=map.get(key);
      const incomingTerms=Array.isArray(cite.supporting_terms_raw)?cite.supporting_terms_raw:(Array.isArray(cite.supporting_terms)?cite.supporting_terms:[]);
      if(!entry){
        entry={
          id:CITATIONS.length,
          source_type:normalizeSourceType(cite.source_type,cite.publisher),
          url:cite.url||"",
          title:cite.title||"",
          publisher:cite.publisher||"",
          date:cite.date||"",
          quote_or_snippet:cite.quote_or_snippet||"",
          relevance:cite.relevance||"",
          supporting_terms:[...new Set(incomingTerms)],
          supporting_terms_raw:[...new Set(incomingTerms)],
          supporting_term_mappings:[],
          unmapped_supporting_terms:[],
          probeId:probe.discId,
          grounding_status:cite.grounding_status||"",
          grounding_confidence:cite.grounding_confidence||"",
          grounding_score:Number.isFinite(Number(cite.grounding_score))?Number(cite.grounding_score):null,
          grounding_reasons:Array.isArray(cite.grounding_reasons)?[...new Set(cite.grounding_reasons)]:[],
          wolfram_input_interpretation:cite.wolfram_input_interpretation||"",
          wolfram_best_definition:cite.wolfram_best_definition||"",
          wolfram_alt_facts:Array.isArray(cite.wolfram_alt_facts)?[...new Set(cite.wolfram_alt_facts)]:[],
          wolfram_assumptions:Array.isArray(cite.wolfram_assumptions)?[...new Set(cite.wolfram_assumptions.map(x=>normalizeWolframAssumptionText(x,{})).filter(Boolean))]:[],
          wolfram_did_you_means:Array.isArray(cite.wolfram_did_you_means)?[...new Set(cite.wolfram_did_you_means)]:[],
          wolfram_warnings:Array.isArray(cite.wolfram_warnings)?[...new Set(cite.wolfram_warnings)]:[]
        };
        map.set(key,entry);
        CITATIONS.push(entry);
      }else{
        if(!entry.source_type&&cite.source_type) entry.source_type=normalizeSourceType(cite.source_type,cite.publisher);
        if(!entry.source_type&&/wolfram/i.test(String(cite.publisher||""))) entry.source_type="wolfram";
        entry.supporting_terms_raw=[...new Set([...(entry.supporting_terms_raw||[]),...incomingTerms])];
        entry.supporting_terms=[...new Set([...(entry.supporting_terms||[]),...incomingTerms])];
        if(!entry.grounding_status&&cite.grounding_status) entry.grounding_status=String(cite.grounding_status);
        if(!entry.grounding_confidence&&cite.grounding_confidence) entry.grounding_confidence=String(cite.grounding_confidence);
        if(entry.grounding_score===null&&Number.isFinite(Number(cite.grounding_score))) entry.grounding_score=Number(cite.grounding_score);
        const incomingReasons=(Array.isArray(cite.grounding_reasons)?cite.grounding_reasons:[]).map(x=>String(x||"").trim()).filter(Boolean);
        entry.grounding_reasons=[...new Set([...(entry.grounding_reasons||[]),...incomingReasons])];
        if(!entry.wolfram_input_interpretation&&cite.wolfram_input_interpretation) entry.wolfram_input_interpretation=String(cite.wolfram_input_interpretation);
        if(!entry.wolfram_best_definition&&cite.wolfram_best_definition) entry.wolfram_best_definition=String(cite.wolfram_best_definition);
        const incomingAltFacts=(Array.isArray(cite.wolfram_alt_facts)?cite.wolfram_alt_facts:[]).map(x=>String(x||"").trim()).filter(Boolean);
        const incomingAssumptions=(Array.isArray(cite.wolfram_assumptions)?cite.wolfram_assumptions:[]).map(x=>normalizeWolframAssumptionText(x,{})).filter(Boolean);
        const incomingDidYou=(Array.isArray(cite.wolfram_did_you_means)?cite.wolfram_did_you_means:[]).map(x=>String(x||"").trim()).filter(Boolean);
        const incomingWarnings=(Array.isArray(cite.wolfram_warnings)?cite.wolfram_warnings:[]).map(x=>String(x||"").trim()).filter(Boolean);
        entry.wolfram_alt_facts=[...new Set([...(entry.wolfram_alt_facts||[]),...incomingAltFacts])];
        entry.wolfram_assumptions=[...new Set([...(entry.wolfram_assumptions||[]),...incomingAssumptions])];
        entry.wolfram_did_you_means=[...new Set([...(entry.wolfram_did_you_means||[]),...incomingDidYou])];
        entry.wolfram_warnings=[...new Set([...(entry.wolfram_warnings||[]),...incomingWarnings])];
      }
    }
  }
  const termMap=new Map();
  for(const term of TERMS){
    term.citations=[];
    termMap.set(toCanonicalKey(term.label),term);
  }
  const aliasIndex=buildTermAliasIndex();
  const unmappedGlobal=new Set();
  for(const cite of CITATIONS){
    const rawTerms=dedupeCasefold([...(cite.supporting_terms_raw||cite.supporting_terms||[])],160);
    const resolved=mapSupportingTermsWithAliases(rawTerms,aliasIndex);
    cite.supporting_terms_raw=rawTerms;
    cite.supporting_terms=dedupeCasefold(resolved.mappedTerms,120);
    cite.supporting_term_mappings=resolved.mappings;
    cite.unmapped_supporting_terms=resolved.unmapped;
    for(const raw of (resolved.unmapped||[])){unmappedGlobal.add(raw);}
    for(const t of (cite.supporting_terms||[])){
      const key=toCanonicalKey(t);
      const term=termMap.get(key);
      if(term&&!term.citations.includes(cite.id)) term.citations.push(cite.id);
    }
  }
  CITATION_UNMAPPED_SUPPORTING_TERMS=[...unmappedGlobal];
  refreshTermSignalFields(TERMS);
  if(prevCount!==CITATIONS.length){
    markArtifactsStale(["claims","outline","deep_report","red_team","replication","markdown"]);
  }
}
function isLikelyDictionaryOnlyGroundingText(text,label=""){
  const raw=String(text||"").replace(/\s+/g," ").trim();
  if(!raw) return false;
  const canonText=toCanonicalKey(raw);
  const canonLabel=toCanonicalKey(label||"");
  if(canonText&&canonLabel&&(canonText===canonLabel||canonText.includes(canonLabel)||canonLabel.includes(canonText))) return true;
  const words=raw.split(" ").filter(Boolean);
  const genericLex=/\b(?:concept|term|idea|principle|method|process|system|framework|phenomenon|state|quality|property)\b/i;
  const bareDef=/(?:\bis\b|\bare\b)\s+(?:a|an|the)\s+/i.test(raw);
  if(words.length<=9&&genericLex.test(raw)) return true;
  if(words.length<=12&&bareDef&&genericLex.test(raw)) return true;
  return false;
}
function computeGroundingStats(terms=TERMS,citations=CITATIONS,diagnostics=WOLFRAM_GROUNDING_DIAGNOSTICS){
  const nodes=Array.isArray(terms)?terms:[];
  const totalNodes=nodes.length;
  const citationList=Array.isArray(citations)?citations:[];
  const diagList=Array.isArray(diagnostics)?diagnostics:[];
  const citationById=new Map();
  for(const cite of citationList){
    const id=Number(cite?.id);
    if(Number.isFinite(id)) citationById.set(id,cite);
  }
  const diagsByTermKey=new Map();
  for(const diag of diagList){
    const key=toCanonicalKey(diag?.termLabel||"");
    if(!key) continue;
    if(!diagsByTermKey.has(key)) diagsByTermKey.set(key,[]);
    diagsByTermKey.get(key).push(diag);
  }
  const outcomeCounts={grounded:0,metadata_only:0,rejected:0,not_attempted:0,local_defined:0};
  let groundedNodes=0;
  let ambiguousWaMatches=0;
  let waFailures=0;
  let totalCitationLinks=0;
  let nodesWithNoCitations=0;
  let acceptedWolfram=0;
  let rejectedWolfram=0;
  let acceptedButLowAlignment=0;
  let dictionaryOnlyGroundings=0;
  let likelyCategoryMismatch=0;
  let metadataOnlyTerms=0;
  let relevanceScoreTotal=0;
  let evidenceSupportScoreTotal=0;
  let researchSupportedWaUnresolved=0;
  let highRelevanceWaUnresolved=0;
  let waNotSuitableTerms=0;
  for(const term of nodes){
    const termLabel=String(term?.label||"").trim();
    const termKey=toCanonicalKey(termLabel||"");
    const termDiags=termKey?(diagsByTermKey.get(termKey)||[]):[];
    const citeIds=Array.isArray(term?.citations)?term.citations:[];
    const citeCount=citeIds.length;
    totalCitationLinks+=citeCount;
    if(citeCount===0) nodesWithNoCitations++;
    const termWolframCitations=citeIds.map(id=>citationById.get(Number(id))).filter(cite=>isWolframGroundingCitation(cite));
    const outcome=getTermGroundingOutcome(term,{termDiags,termWolframCitations});
    const relevanceScore=computeTermRelevanceScore(term);
    const evidenceSupportScore=computeTermEvidenceSupportScore(term);
    relevanceScoreTotal+=relevanceScore;
    evidenceSupportScoreTotal+=evidenceSupportScore;
    const waStatus=deriveWaGroundingStatusKey(term,outcome);
    if(waStatus==="wa_not_suitable") waNotSuitableTerms++;
    const researchSupported=getResearchCitationsForTerm(term).length>0;
    if(researchSupported&&waStatus.startsWith("wa_unresolved")) researchSupportedWaUnresolved++;
    if(relevanceScore>=0.72&&waStatus.startsWith("wa_unresolved")) highRelevanceWaUnresolved++;
    if(Object.prototype.hasOwnProperty.call(outcomeCounts,outcome)) outcomeCounts[outcome]++;
    else outcomeCounts.not_attempted++;
    if(outcome==="grounded") groundedNodes++;
    if(outcome==="rejected") waFailures++;
    const hasMultipleInterpretations=Array.isArray(term?.grounding?.wolframInterpretations)&&term.grounding.wolframInterpretations.length>1;
    const hasAmbiguousResolution=/fallback|ambiguous|did.?you.?mean/.test(String(term?.grounding?.wolframResolution||"").toLowerCase());
    if(outcome==="rejected"&&(hasMultipleInterpretations||hasAmbiguousResolution)) ambiguousWaMatches++;
    const hasAcceptedOutcome=outcome==="grounded"||outcome==="metadata_only";
    if(hasAcceptedOutcome) acceptedWolfram++;
    if(outcome==="rejected") rejectedWolfram++;
    const reasons=[
      ...termWolframCitations.flatMap(cite=>Array.isArray(cite?.grounding_reasons)?cite.grounding_reasons:[]),
      ...termDiags.flatMap(diag=>Array.isArray(diag?.reasons)?diag.reasons:[])
    ].map(x=>String(x||"").trim().toLowerCase()).filter(Boolean);
    const lowAlignmentFromReason=reasons.some(r=>r.startsWith("alignment_below_threshold_"));
    const lowAlignmentFromDiag=termDiags.some(diag=>Boolean(diag?.accepted)&&Number.isFinite(Number(diag?.semanticAlignmentScore??diag?.semantic_alignment_score))&&Number(diag?.semanticAlignmentScore??diag?.semantic_alignment_score)<0.62);
    if(hasAcceptedOutcome&&(lowAlignmentFromReason||lowAlignmentFromDiag)){
      acceptedButLowAlignment++;
    }
    const dictionaryReasonHit=reasons.some(r=>["generic_placeholder","same_as_label","too_short","label_tokens_missing","mostly_numeric"].includes(r));
    const wolframText=String(term?.descriptions?.wolframGrounding||"").trim();
    if(hasAcceptedOutcome&&(dictionaryReasonHit||isLikelyDictionaryOnlyGroundingText(wolframText,termLabel))){
      dictionaryOnlyGroundings++;
    }
    const categoryMismatchHit=reasons.some(r=>r.startsWith("category_mismatch_"))||reasons.includes("forced_metadata_only_category_mismatch");
    if(categoryMismatchHit) likelyCategoryMismatch++;
    if(outcome==="metadata_only") metadataOnlyTerms++;
  }
  const coverageCount=Number(outcomeCounts.grounded||0)+Number(outcomeCounts.metadata_only||0)+Number(outcomeCounts.local_defined||0);
  return {
    totalNodes,
    groundedNodes,
    groundedNodesPct:totalNodes?Number((groundedNodes/totalNodes).toFixed(4)):0,
    ambiguousWaMatches,
    waFailures,
    avgCitationsPerNode:totalNodes?Number((totalCitationLinks/totalNodes).toFixed(3)):0,
    nodesWithNoCitations,
    nodesWithNoCitationsPct:totalNodes?Number((nodesWithNoCitations/totalNodes).toFixed(4)):0,
    total_terms:totalNodes,
    accepted_wolfram:acceptedWolfram,
    rejected_wolfram:rejectedWolfram,
    accepted_but_low_alignment:acceptedButLowAlignment,
    dictionary_only_groundings:dictionaryOnlyGroundings,
    likely_category_mismatch:likelyCategoryMismatch,
    metadata_only_terms:metadataOnlyTerms,
    attempted_rejected_terms:waFailures,
    avg_relevance_score:totalNodes?Number((relevanceScoreTotal/totalNodes).toFixed(4)):0,
    avg_evidence_support_score:totalNodes?Number((evidenceSupportScoreTotal/totalNodes).toFixed(4)):0,
    research_supported_wa_unresolved:researchSupportedWaUnresolved,
    high_relevance_wa_unresolved:highRelevanceWaUnresolved,
    wa_not_suitable_terms:waNotSuitableTerms,
    termOutcomeBreakdown:outcomeCounts,
    term_outcome_grounded:Number(outcomeCounts.grounded||0),
    term_outcome_metadata_only:Number(outcomeCounts.metadata_only||0),
    term_outcome_rejected:Number(outcomeCounts.rejected||0),
    term_outcome_not_attempted:Number(outcomeCounts.not_attempted||0),
    term_outcome_local_defined:Number(outcomeCounts.local_defined||0),
    term_outcome_coverage_pct:totalNodes?Number((coverageCount/totalNodes).toFixed(4)):0
  };
}
function computeSourceTypeBreakdown(citations=CITATIONS){
  const out={};
  for(const cite of (Array.isArray(citations)?citations:[])){
    const key=normalizeSourceType(cite?.source_type,cite?.publisher)||"untyped";
    out[key]=(out[key]||0)+1;
  }
  return Object.fromEntries(Object.entries(out).sort((a,b)=>Number(b[1]||0)-Number(a[1]||0)));
}
function interpretationLooksGeneric(text){
  const raw=String(text||"").replace(/\s+/g," ").trim();
  if(!raw) return true;
  const canonical=toCanonicalKey(raw);
  if(!canonical) return true;
  const words=canonical.split(" ").filter(Boolean);
  if(!words.length) return true;
  const genericTokens=new Set(["concept","entity","count","term","word","unit","idea","object","thing","value","state","class","category","system","process","framework","function","definition","noun","adjective","verb","property","quality","phenomenon","model"]);
  const tokenHits=words.filter(tok=>genericTokens.has(tok)).length;
  if(words.length<=3&&tokenHits>=1) return true;
  if(words.length<=6&&tokenHits>=2) return true;
  if(/^(?:entity|concept|term|word|definition|entity count)$/i.test(raw)) return true;
  return false;
}
function computeGenericInterpretationHotspotAudit(diagnostics=WOLFRAM_GROUNDING_DIAGNOSTICS){
  const diagList=Array.isArray(diagnostics)?diagnostics.filter(item=>item&&typeof item==="object"):[];
  const bucketMap=new Map();
  const lowSignalReasons=new Set(["generic_placeholder","too_short","same_as_label","label_tokens_missing","mostly_numeric","empty"]);
  for(const diag of diagList){
    const termLabel=normalizeWAGraphLabel(diag?.termLabel,"(unknown term)");
    const query=normalizeWAGraphLabel(diag?.query,"(no query)");
    const interpretation=normalizeWAGraphLabel(diag?.chosenInterpretation||diag?.inputInterpretation||diag?.bestDefinition||diag?.snippet,"(no interpretation)");
    const key=toCanonicalKey(interpretation)||hashString(`interp:${interpretation}`);
    if(!bucketMap.has(key)) bucketMap.set(key,{interpretation,count:0,terms:new Set(),queries:new Set(),genericSignalHits:0,statusCounts:{},reasons:new Set()});
    const bucket=bucketMap.get(key);
    bucket.count++;
    bucket.terms.add(termLabel);
    bucket.queries.add(query);
    const outcome=resolveWAGraphOutcomeBucket(diag);
    bucket.statusCounts[outcome]=(bucket.statusCounts[outcome]||0)+1;
    const reasons=(Array.isArray(diag?.reasons)?diag.reasons:[]).map(x=>String(x||"").trim().toLowerCase()).filter(Boolean);
    for(const reason of reasons){if(bucket.reasons.size<12) bucket.reasons.add(reason);}
    const reasonSignal=reasons.some(reason=>lowSignalReasons.has(reason)||reason.startsWith("category_mismatch_"));
    if(interpretationLooksGeneric(interpretation)||reasonSignal) bucket.genericSignalHits++;
  }
  const repeated=[...bucketMap.values()].filter(row=>row.terms.size>=2).map(row=>{
    const statusRanked=Object.entries(row.statusCounts).map(([bucket,count])=>({bucket,count:Number(count)||0})).sort((a,b)=>Number(b.count)-Number(a.count));
    return {
      interpretation:row.interpretation,
      count:row.count,
      uniqueTermCount:row.terms.size,
      uniqueQueryCount:row.queries.size,
      genericSignalHits:row.genericSignalHits,
      dominantStatusBucket:statusRanked[0]?.bucket||"",
      statusCounts:row.statusCounts,
      terms:[...row.terms].sort(),
      reasons:[...row.reasons]
    };
  }).sort((a,b)=>Number(b.uniqueTermCount)-Number(a.uniqueTermCount)||Number(b.count)-Number(a.count)||String(a.interpretation).localeCompare(String(b.interpretation)));
  const genericHotspots=repeated.filter(row=>row.genericSignalHits>0).sort((a,b)=>Number(b.genericSignalHits)-Number(a.genericSignalHits)||Number(b.uniqueTermCount)-Number(a.uniqueTermCount)||Number(b.count)-Number(a.count));
  return {
    diagnosticsCount:diagList.length,
    repeatedInterpretationCount:repeated.length,
    genericHotspotCount:genericHotspots.length,
    repeated,
    genericHotspots
  };
}
function renderGenericInterpretationHotspotAudit(diagnostics=WOLFRAM_GROUNDING_DIAGNOSTICS){
  const statusEl=document.getElementById("wa-hotspot-status");
  const matrixEl=document.getElementById("wa-hotspot-matrix");
  if(!statusEl||!matrixEl) return;
  const audit=computeGenericInterpretationHotspotAudit(diagnostics);
  if(!audit.diagnosticsCount){
    statusEl.textContent="No Wolfram interpretation hotspot diagnostics yet.";
    matrixEl.innerHTML="";
    return;
  }
  const modeLabel=audit.genericHotspotCount?"Generic repeated chosen interpretations":"Repeated chosen interpretations";
  statusEl.textContent=`${modeLabel}: ${audit.genericHotspotCount||0} generic hotspots | ${audit.repeatedInterpretationCount||0} repeated interpretations across terms (from ${audit.diagnosticsCount} diagnostics).`;
  const rows=(audit.genericHotspots.length?audit.genericHotspots:audit.repeated).slice(0,10);
  if(!rows.length){
    matrixEl.innerHTML="<div class=\"matrix-note\" style=\"padding:8px\">No repeated chosen interpretations detected.</div>";
    return;
  }
  const body=rows.map(row=>{
    const statusBucket=String(row?.dominantStatusBucket||"");
    const statusLabel=statusBucket?waGraphStatusLabel(statusBucket):"unknown";
    const statusColor=statusBucket?waGraphStatusColor(statusBucket):"#64748b";
    const termsPreview=row.terms.slice(0,3).join(" | ");
    const termsExtra=row.terms.length>3?` +${row.terms.length-3}`:"";
    return `<tr><td>${escapeHtml(row.interpretation)}</td><td>${row.uniqueTermCount}</td><td>${row.count}</td><td>${row.genericSignalHits}</td><td><span class="tag" style="border-color:${statusColor};color:${statusColor}">${escapeHtml(statusLabel)}</span></td><td>${escapeHtml(`${termsPreview}${termsExtra}`)}</td></tr>`;
  }).join("");
  matrixEl.innerHTML=`<table class="matrix-table"><thead><tr><th>Chosen interpretation</th><th>Terms</th><th>Hits</th><th>Generic signal</th><th>Dominant outcome</th><th>Example terms</th></tr></thead><tbody>${body}</tbody></table>`;
}
function buildGroundingHealthWarnings(groundingStats,sourceTypeBreakdown){
  const stats=groundingStats&&typeof groundingStats==="object"?groundingStats:computeGroundingStats();
  const src=sourceTypeBreakdown&&typeof sourceTypeBreakdown==="object"?sourceTypeBreakdown:computeSourceTypeBreakdown();
  const warnings=[];
  if(!stats.totalNodes){
    warnings.push("No nodes available; grounding health cannot be assessed.");
    return warnings;
  }
  if(stats.groundedNodesPct<0.35){
    warnings.push(`Low grounded coverage (${(stats.groundedNodesPct*100).toFixed(1)}%). Treat this map as exploratory.`);
  }
  if(Number(stats.term_outcome_coverage_pct||0)<0.5){
    warnings.push(`Low term-outcome coverage (${(Number(stats.term_outcome_coverage_pct||0)*100).toFixed(1)}% grounded/metadata-only/local-defined).`);
  }
  if(stats.ambiguousWaMatches>=Math.max(2,Math.ceil(stats.totalNodes*0.2))){
    warnings.push(`Ambiguous Wolfram matches are elevated (${stats.ambiguousWaMatches}). Verify interpretation choices.`);
  }
  if(stats.waFailures>=Math.max(2,Math.ceil(stats.totalNodes*0.15))){
    warnings.push(`WA unresolved after attempts is elevated (${stats.waFailures}). Check proxy/appid/query quality.`);
    warnings.push("No WA match should be treated as unresolved canonicalization, not as low relevance.");
  }
  if(stats.avgCitationsPerNode<0.9){
    warnings.push(`Evidence density is sparse (${stats.avgCitationsPerNode.toFixed(2)} citations/node).`);
  }
  if(stats.nodesWithNoCitationsPct>0.5){
    warnings.push(`Most nodes have no citations (${(stats.nodesWithNoCitationsPct*100).toFixed(1)}%).`);
  }
  const lowAlignCount=Number(stats.accepted_but_low_alignment||0);
  if(lowAlignCount>0){
    warnings.push(`Accepted WA nodes with low semantic alignment detected (${lowAlignCount}).`);
  }
  const dictOnlyCount=Number(stats.dictionary_only_groundings||0);
  if(dictOnlyCount>0){
    warnings.push(`Dictionary-like WA groundings detected (${dictOnlyCount}). Review append decisions.`);
  }
  const categoryMismatchCount=Number(stats.likely_category_mismatch||0);
  if(categoryMismatchCount>0){
    warnings.push(`Likely WA category mismatches detected (${categoryMismatchCount}).`);
  }
  const totalSources=Object.values(src).reduce((sum,v)=>sum+Number(v||0),0);
  if(totalSources===0){
    warnings.push("No sources were captured in this run.");
  }else{
    const sourceTypes=Object.keys(src);
    const wolframOnly=sourceTypes.length===1&&sourceTypes[0]==="wolfram";
    if(wolframOnly){
      warnings.push("Evidence is Wolfram-only; add external sources for triangulation.");
    }
  }
  return warnings;
}
function serializeTermForRun(term){
  const signal=getTermSignalModel(term);
  return {
    label:term.label,
    description:term.description,
    descriptions:structuredCloneSafe(term.descriptions||defaultDescriptionLayers()),
    centrality:term.centrality,
    slices:[...term.slices],
    type:term.type,
    pos:[...(term.pos||[0,0,0])],
    citations:[...(term.citations||[])],
    aliases:Array.isArray(term.aliases)?[...term.aliases]:[],
    description_source:term.description_source||"",
    description_provenance:structuredCloneSafe(term.description_provenance||[]),
    grounding:structuredCloneSafe(term.grounding||defaultGroundingBlock()),
    groundingOutcome:signal.outcome,
    relevance_score:signal.relevanceScore,
    evidence_support_score:signal.evidenceSupportScore,
    wa_eligibility:signal.waEligibility,
    wa_grounding_status:signal.waGroundingStatus,
    display_description_source:signal.displayDescriptionSource
  };
}
function buildRunSnapshot(target,probeResults,synthResult,cfg){
  refreshTermSignalFields(TERMS);
  const groundingStats=computeGroundingStats(TERMS);
  const sourceTypeBreakdown=computeSourceTypeBreakdown(CITATIONS);
  const warnings=buildGroundingHealthWarnings(groundingStats,sourceTypeBreakdown);
  return {
    schemaVersion:6,
    runId:CURRENT_RUN_ID||null,
    target,
    probeResults,
    synthResult,
    generatedAt:new Date().toISOString(),
    config:safeConfigForRun(cfg),
    sourcePolicy:cfg.sourcePolicy||"",
    groundingStats,
    sourceTypeBreakdown,
    warnings,
    discs:DISCS.map(d=>({id:d.id,name:d.name,abbr:d.abbr,col:d.col,kind:d.kind||"llm"})),
    terms:TERMS.map(serializeTermForRun),
    citations:[...CITATIONS],
    auditTrail:[...CALL_LOGS],
    embeddingDiagnostics:{similarityMatrix:structuredCloneSafe(DISC_SIM_MATRIX),projectionStability:structuredCloneSafe(PROJECTION_STABILITY)},
    wolframGroundingDiagnostics:structuredCloneSafe(WOLFRAM_GROUNDING_DIAGNOSTICS),
    ambiguityQueue:structuredCloneSafe(AMBIGUITY_QUEUE),
    artifacts:structuredCloneSafe(ARTIFACT_STORE),
    report:LAST_RUN?.report||"",
    claimsLedger:LAST_RUN?.claimsLedger||[],
    redTeamCritique:LAST_RUN?.redTeamCritique||"",
    replication:LAST_RUN?.replication||[],
    outline:LAST_RUN?.outline||"",
    markdown:LAST_RUN?.markdown||"",
    caProbe:structuredCloneSafe(CA_PROBE_OUTPUT)
  };
}
function structuredCloneSafe(obj){try{return structuredClone(obj);}catch{return JSON.parse(JSON.stringify(obj||{}));}}
function applyRenameMapToResults(probeResults,synthResult,renameMap){const normMap=new Map();for(const pair of (renameMap||[])){const from=String(pair.from||"").trim();const to=String(pair.to||"").trim();if(!from||!to) continue;normMap.set(toCanonicalKey(from),to);}if(!normMap.size) return;const rename=(label)=>normMap.get(toCanonicalKey(label))||label;for(const probe of probeResults){for(const term of (probe.terms||[])){term.label=rename(term.label);}}for(const key of ["convergent","contradictory","emergent"]){for(const item of (synthResult[key]||[])){item.label=rename(item.label);}}}
async function applySecondPassCleanup(target,probeResults,synthResult,cfg){const pool=[];for(const r of probeResults){for(const t of (r.terms||[])){if(t?.label) pool.push(String(t.label));}}for(const k of ["convergent","contradictory","emergent"]){for(const t of (synthResult[k]||[])){if(t?.label) pool.push(String(t.label));}}const uniq=[...new Set(pool.map(s=>s.trim()).filter(Boolean))];if(uniq.length<2) return;const prompt=`Target concept: "${target}"\n\nTerms:\n${uniq.map((t,i)=>`${i+1}. ${t}`).join("\n")}\n\nReturn JSON only:\n{\n  "rename_map":[{"from":"Variant wording","to":"Canonical wording"}]\n}\n\nRules:\n- Only include entries when two terms are near duplicates of the same concept\n- Keep "to" concise and neutral\n- Do not merge genuinely different concepts`;const raw=await callLLMJSON("You normalize research term lists. Return strict JSON.",prompt,cfg);const parsed=extractJSON(raw);applyRenameMapToResults(probeResults,synthResult,Array.isArray(parsed.rename_map)?parsed.rename_map:[]);}
async function assignSemanticPositions(target,cfg,setStatus){const notify=(msg)=>{if(typeof setStatus==="function") setStatus(msg);};DISC_SIM_MATRIX=null;PROJECTION_STABILITY=null;const embeddingInputs=TERMS.map(term=>buildEmbeddingText(term,target));const embedModel=String(cfg?.embeddingModel||"").trim()||"(unspecified embedding model)";const vectors=await callEmbeddings(embeddingInputs,cfg,(batchNo,total)=>{notify(`VECTOR LAYOUT - ${embedModel} batch ${batchNo}/${total}...`);});const normalizedVectors=vectors.map(normalizeEmbeddingVector);DISC_SIM_MATRIX=computeDiscSimilarityMatrix(normalizedVectors);notify("VECTOR LAYOUT - projecting semantic manifold to 3D...");const basePoints=normalizePointCloud(await projectVectorsTo3D(normalizedVectors,PROJECTION_BASE_SEED),1.45);for(let i=0;i<TERMS.length;i++){TERMS[i].pos=basePoints[i]||[0,0,0];}const rerunCount=Math.max(0,Math.min(4,PROJECTION_STABILITY_RUNS-1));const reruns=[];for(let idx=0;idx<rerunCount;idx++){const seed=PROJECTION_BASE_SEED+idx+1;notify(`VECTOR LAYOUT - projection stability check ${idx+1}/${rerunCount}...`);const runPoints=normalizePointCloud(await projectVectorsTo3D(normalizedVectors,seed),1.45);reruns.push({seed,points:runPoints});}PROJECTION_STABILITY=computeProjectionStability(basePoints,reruns);renderEmbeddingDiagnostics();}
function buildEmbeddingText(term,target){applyDisplayDescriptionForTerm(term,{fallbackDescription:term.description,fallbackSource:term.description_source});const discs=term.slices.map(i=>DISCS[i]?.name).filter(Boolean).join(" | ")||"synthesis";return `Target: ${target}. Type: ${term.type}. Disciplines: ${discs}. Term: ${term.label}. Description: ${term.description}`;}
function normalizeEmbeddingVector(vec){const norm=Math.hypot(...vec)||1;return vec.map(v=>v/norm);}
async function projectVectorsTo3D(vectors,seed=PROJECTION_BASE_SEED){if(vectors.length===0) return [];if(vectors.length===1) return [[0,0,0]];if(vectors.length===2) return [[-1,0,0],[1,0,0]];try{const {UMAP}=await loadUMAPModule();const rng=new RNG(seed>>>0);const nNeighbors=Math.max(2,Math.min(12,vectors.length-1));const umap=new UMAP({nComponents:3,nNeighbors,minDist:0.15,spread:1.1,random:()=>rng.next()});return umap.fit(vectors);}catch(err){console.warn("UMAP unavailable; using random projection fallback.",err);return randomProjection3D(vectors,seed);}}
function loadUMAPModule(){if(!umapModulePromise){umapModulePromise=import("https://esm.sh/umap-js@1.4.0").then(mod=>{if(!mod||!mod.UMAP) throw new Error("UMAP export not found");return mod;});}return umapModulePromise;}
function randomProjection3D(vectors,seed=1337){const dims=vectors[0]?.length||0;const rng=new RNG(seed>>>0);const basis=[new Array(dims),new Array(dims),new Array(dims)];for(let axis=0;axis<3;axis++){let norm=0;for(let i=0;i<dims;i++){const val=(rng.next()*2)-1;basis[axis][i]=val;norm+=val*val;}norm=Math.sqrt(norm)||1;for(let i=0;i<dims;i++) basis[axis][i]/=norm;}return vectors.map(vec=>{const out=[0,0,0];for(let axis=0;axis<3;axis++){let acc=0;for(let i=0;i<dims;i++) acc+=vec[i]*basis[axis][i];out[axis]=acc;}return out;});}
function averageVector(vectors){if(!vectors.length) return null;const dims=vectors[0]?.length||0;if(!dims) return null;const out=new Array(dims).fill(0);for(const vec of vectors){for(let i=0;i<dims;i++){out[i]+=Number(vec?.[i]||0);}}for(let i=0;i<dims;i++){out[i]/=vectors.length;}return normalizeEmbeddingVector(out);}
function cosineDistance(a,b){if(!Array.isArray(a)||!Array.isArray(b)||!a.length||!b.length) return null;const dims=Math.min(a.length,b.length);let dot=0,na=0,nb=0;for(let i=0;i<dims;i++){const av=Number(a[i]||0);const bv=Number(b[i]||0);dot+=av*bv;na+=av*av;nb+=bv*bv;}if(na<=0||nb<=0) return null;const cosine=Math.max(-1,Math.min(1,dot/(Math.sqrt(na)*Math.sqrt(nb))));return 1-cosine;}
function computeDiscCentroidsFromVectors(vectors){const centroids={};for(const disc of DISCS){const bucket=[];for(let i=0;i<TERMS.length;i++){if(TERMS[i]?.slices?.includes(disc.id)&&Array.isArray(vectors[i])) bucket.push(vectors[i]);}centroids[disc.id]=averageVector(bucket);}return centroids;}
function computeDiscSimilarityMatrix(vectors){const centroids=computeDiscCentroidsFromVectors(vectors);const discIds=DISCS.map(d=>d.id);const labels=DISCS.map(d=>d.abbr||makeAbbr(d.name));const distances=discIds.map((leftId,row)=>discIds.map((rightId,col)=>row===col?0:cosineDistance(centroids[leftId],centroids[rightId])));return {discIds,labels,distances,generatedAt:new Date().toISOString()};}
function computeDiscCentroidsFromPoints(points){const centroids={};for(const disc of DISCS){const bucket=[];for(let i=0;i<TERMS.length;i++){if(TERMS[i]?.slices?.includes(disc.id)&&Array.isArray(points[i])) bucket.push(points[i]);}centroids[disc.id]=averagePoint3(bucket);}return centroids;}
function averagePoint3(points){if(!points.length) return null;let x=0,y=0,z=0;for(const p of points){x+=Number(p?.[0]||0);y+=Number(p?.[1]||0);z+=Number(p?.[2]||0);}return [x/points.length,y/points.length,z/points.length];}
function euclid3(a,b){if(!Array.isArray(a)||!Array.isArray(b)) return null;return Math.hypot((a[0]||0)-(b[0]||0),(a[1]||0)-(b[1]||0),(a[2]||0)-(b[2]||0));}
function buildDiscNeighborMap(centroids,k){const map={};for(const disc of DISCS){const here=centroids[disc.id];if(!here){map[disc.id]=[];continue;}const scores=[];for(const other of DISCS){if(other.id===disc.id) continue;const there=centroids[other.id];const dist=euclid3(here,there);if(dist===null) continue;scores.push({id:other.id,dist});}scores.sort((a,b)=>a.dist-b.dist);map[disc.id]=scores.slice(0,Math.min(k,scores.length)).map(item=>item.id);}return map;}
function neighborOverlap(a,b){if(!Array.isArray(a)||!Array.isArray(b)||!a.length||!b.length) return null;const left=new Set(a);const right=new Set(b);let inter=0;for(const id of left){if(right.has(id)) inter++;}return inter/Math.max(left.size,right.size,1);}
function averageNumbers(values){const finite=values.filter(v=>Number.isFinite(v));if(!finite.length) return null;return finite.reduce((sum,v)=>sum+v,0)/finite.length;}
function computeProjectionStability(basePoints,reruns){if(!Array.isArray(basePoints)||!basePoints.length||DISCS.length<2){return {runs:1+reruns.length,score:null,label:"exploratory fog",perRun:[],generatedAt:new Date().toISOString()};}const neighborCount=Math.min(2,Math.max(1,DISCS.length-1));const baseNeighbors=buildDiscNeighborMap(computeDiscCentroidsFromPoints(basePoints),neighborCount);const perRun=[];for(const run of reruns){const runNeighbors=buildDiscNeighborMap(computeDiscCentroidsFromPoints(run.points||[]),neighborCount);const overlaps=[];for(const disc of DISCS){const overlap=neighborOverlap(baseNeighbors[disc.id]||[],runNeighbors[disc.id]||[]);if(overlap!==null) overlaps.push(overlap);}perRun.push({seed:run.seed,overlap:averageNumbers(overlaps)});}const score=averageNumbers(perRun.map(item=>item.overlap));const label=score===null?"exploratory fog":score>=0.75?"stable":score>=0.45?"mixed":"exploratory fog";return {runs:1+reruns.length,neighborCount,score,label,perRun,generatedAt:new Date().toISOString()};}
function renderEmbeddingDiagnostics(){const statusEl=document.getElementById("disc-sim-status");const matrixEl=document.getElementById("disc-sim-matrix");const stabEl=document.getElementById("projection-stability");if(!statusEl||!matrixEl||!stabEl) return;if(!DISC_SIM_MATRIX?.distances?.length){statusEl.textContent="No embedding diagnostics yet.";stabEl.textContent="";matrixEl.innerHTML="";return;}statusEl.textContent="Disc similarity matrix (cosine distance in original embedding space; rotation-invariant). Lower is closer.";const labels=DISC_SIM_MATRIX.labels||DISCS.map(d=>d.abbr);const rows=DISC_SIM_MATRIX.distances.map((row,rowIdx)=>`<tr><th>${escapeHtml(labels[rowIdx]||`D${rowIdx+1}`)}</th>${row.map(cell=>{if(cell===null||cell===undefined||Number.isNaN(cell)) return "<td>-</td>";return `<td>${Number(cell).toFixed(2)}</td>`;}).join("")}</tr>`).join("");matrixEl.innerHTML=`<table class="matrix-table"><thead><tr><th></th>${labels.map(label=>`<th>${escapeHtml(label)}</th>`).join("")}</tr></thead><tbody>${rows}</tbody></table>`;if(!PROJECTION_STABILITY){stabEl.textContent="Projection stability check unavailable.";return;}const scorePct=Number.isFinite(PROJECTION_STABILITY.score)?`${(PROJECTION_STABILITY.score*100).toFixed(1)}%`:"n/a";const runs=Array.isArray(PROJECTION_STABILITY.perRun)?PROJECTION_STABILITY.perRun:[];const runBits=runs.length?` | reruns: ${runs.map(r=>`seed ${r.seed}: ${Number.isFinite(r.overlap)?(r.overlap*100).toFixed(0)+"%":"n/a"}`).join(", ")}`:"";stabEl.textContent=`Projection stability: ${PROJECTION_STABILITY.label} (${scorePct} neighborhood overlap).${runBits}`;}
function normalizePointCloud(points,targetRadius=1.4){if(!points.length) return [];const mean=[0,0,0];for(const p of points){mean[0]+=Number(p[0]||0);mean[1]+=Number(p[1]||0);mean[2]+=Number(p[2]||0);}mean[0]/=points.length;mean[1]/=points.length;mean[2]/=points.length;const centered=points.map(p=>[Number(p[0]||0)-mean[0],Number(p[1]||0)-mean[1],Number(p[2]||0)-mean[2]]);let maxDist=0;for(const p of centered){maxDist=Math.max(maxDist,Math.hypot(p[0],p[1],p[2]));}const scale=maxDist>0?targetRadius/maxDist:1;const rng=new RNG(99);return centered.map(p=>[p[0]*scale+rng.jitter(0.02),p[1]*scale+rng.jitter(0.02),p[2]*scale+rng.jitter(0.02)]);}
function applyFallbackPositions(){const rng=new RNG(42);for(const term of TERMS){if(term.type==="unique"){const id=term.slices[0]||0;const dir=fallbackDirection(id);const dist=1.3+(1-clamp01(term.centrality||0.5))*0.6;term.pos=[dir[0]*dist+rng.jitter(0.08),dir[1]*dist+rng.jitter(0.08),dir[2]*dist+rng.jitter(0.08)];continue;}if(term.type==="convergent"||term.type==="contradictory"){const ids=term.slices.length?term.slices:[0];const avg=[0,0,0];for(const id of ids){const dir=fallbackDirection(id);avg[0]+=dir[0];avg[1]+=dir[1];avg[2]+=dir[2];}const unit=normalize3(avg,fallbackDirection(ids[0]||0));const dist=term.type==="convergent"?0.8:0.95;term.pos=[unit[0]*dist+rng.jitter(0.06),unit[1]*dist+rng.jitter(0.06),unit[2]*dist+rng.jitter(0.06)];continue;}term.pos=[rng.jitter(0.10),rng.jitter(0.10),rng.jitter(0.10)];}}
function clamp01(v){return Math.max(0,Math.min(1,Number(v)||0));}
function fallbackDirection(idx){return FALLBACK_DIRS[idx%FALLBACK_DIRS.length]||[1,0,0];}
function normalize3(vec,fallback=[1,0,0]){const len=Math.hypot(vec[0]||0,vec[1]||0,vec[2]||0);if(len<1e-6){const fLen=Math.hypot(fallback[0]||1,fallback[1]||0,fallback[2]||0)||1;return [fallback[0]/fLen,fallback[1]/fLen,fallback[2]/fLen];}return [(vec[0]||0)/len,(vec[1]||0)/len,(vec[2]||0)/len];}
function computeDisciplineAnchors(poolTerms=TERMS){const anchors={};for(const d of DISCS){const points=(poolTerms||[]).filter(t=>t.slices.includes(d.id));if(!points.length){anchors[d.id]=fallbackDirection(d.id).map(v=>v*1.2);continue;}const centroid=[0,0,0];for(const term of points){centroid[0]+=term.pos[0];centroid[1]+=term.pos[1];centroid[2]+=term.pos[2];}centroid[0]/=points.length;centroid[1]/=points.length;centroid[2]/=points.length;if(Math.hypot(centroid[0],centroid[1],centroid[2])<0.08){const dir=fallbackDirection(d.id);anchors[d.id]=[dir[0]*0.9,dir[1]*0.9,dir[2]*0.9];}else{anchors[d.id]=centroid;}}return anchors;}
function showViz(target){isGenerating=false;const label=document.getElementById("viz-target-label");label.textContent=target.toUpperCase();label.title=(CURRENT_RUN_ID||LAST_RUN?.runId||"");activeSlices=new Set(DISCS.map(d=>d.id));activeTypes=new Set(["unique","convergent","contradictory","emergent"]);showSurfaces=true;document.getElementById("surf-check").checked=true;buildSidebar();buildStats();renderCAPanel();renderPlot();document.getElementById("plot").on("plotly_click",onPlotClick);switchMainTab(activeTab==="generator"?"generator":"plot",{silent:true});} 
function buildSidebar(){const dl=document.getElementById("disc-list");dl.innerHTML="";for(const d of DISCS){const btn=document.createElement("div");btn.className="disc-btn";btn.dataset.id=d.id;btn.innerHTML=`<div class="disc-btn-dot" style="background:${d.col}"></div><span class="disc-btn-abbr" style="color:${d.col}">${d.abbr}</span><span class="disc-btn-name">${d.name}</span><button class="small-btn" data-rerun="${d.id}" type="button">RERUN</button>`;btn.addEventListener("click",()=>{if(activeSlices.has(d.id)) activeSlices.delete(d.id);else activeSlices.add(d.id);btn.classList.toggle("off");renderPlot();});btn.querySelector("[data-rerun]").addEventListener("click",e=>{e.stopPropagation();rerunProbe(d.id);});dl.appendChild(btn);}const tl=document.getElementById("type-list");tl.innerHTML="";for(const [tp,cfg] of Object.entries(TYPE_CFG)){const btn=document.createElement("div");btn.className="type-btn";btn.dataset.type=tp;btn.innerHTML=`<div style="width:10px;height:10px;background:${cfg.col};margin-top:2px;flex-shrink:0;border-radius:2px"></div><div><div style="font-size:13px;letter-spacing:.4px;color:${cfg.col}">${cfg.label}</div><div style="font-size:12px;color:var(--muted);margin-top:2px">${cfg.desc}</div></div>`;btn.addEventListener("click",()=>{if(activeTypes.has(tp)) activeTypes.delete(tp);else activeTypes.add(tp);btn.classList.toggle("off");renderPlot();});tl.appendChild(btn);}document.getElementById("surf-check").onchange=e=>{showSurfaces=e.target.checked;renderPlot();};renderGroundingLegend();}
function buildStats(){
  const sr=document.getElementById("stat-rows");
  if(!sr) return;
  refreshTermSignalFields(TERMS);
  sr.innerHTML="";
  const addRow=(label,value,color="var(--text)")=>{
    const row=document.createElement("div");
    row.className="stat-row";
    row.innerHTML=`<span style="color:var(--muted)">${escapeHtml(label)}</span><span style="color:${color}">${escapeHtml(String(value))}</span>`;
    sr.appendChild(row);
  };
  const activeCfg=RUN_STATE?.config||LAST_RUN?.config||null;
  if(activeCfg?.researchModel) addRow("CHAT MODEL",activeCfg.researchModel,"var(--accent)");
  if(activeCfg?.embeddingModel) addRow("EMBED MODEL",activeCfg.embeddingModel,"var(--accent)");
  for(const [tp,cfg] of Object.entries(TYPE_CFG)){
    const n=TERMS.filter(t=>t.type===tp).length;
    addRow(cfg.label,n,cfg.col);
  }
  if(TERMS.length){
    const groundingStats=computeGroundingStats(TERMS);
    const sourceTypeBreakdown=computeSourceTypeBreakdown(CITATIONS);
    const warnings=buildGroundingHealthWarnings(groundingStats,sourceTypeBreakdown);
    const signalRows=TERMS.map(getTermSignalModel);
    const groundedPct=(groundingStats.groundedNodesPct*100).toFixed(1);
    const outcomeCoveragePct=((Number(groundingStats.term_outcome_coverage_pct||0))*100).toFixed(1);
    const noCitePct=(groundingStats.nodesWithNoCitationsPct*100).toFixed(1);
    const groundedCol=groundingStats.groundedNodesPct>=0.6?"#16a34a":groundingStats.groundedNodesPct>=0.35?"#d97706":"#dc2626";
    const outcomeCoverageCol=Number(groundingStats.term_outcome_coverage_pct||0)>=0.75?"#16a34a":Number(groundingStats.term_outcome_coverage_pct||0)>=0.5?"#d97706":"#dc2626";
    const ambiguousCol=groundingStats.ambiguousWaMatches===0?"#16a34a":groundingStats.ambiguousWaMatches<=Math.max(1,Math.floor(groundingStats.totalNodes*0.1))?"#d97706":"#dc2626";
    const attemptedRejectedTerms=Number((groundingStats.attempted_rejected_terms??groundingStats.waFailures)||0);
    const failureCol=attemptedRejectedTerms===0?"#16a34a":"#dc2626";
    const outcomeBreakdown=groundingStats.termOutcomeBreakdown&&typeof groundingStats.termOutcomeBreakdown==="object"?groundingStats.termOutcomeBreakdown:{};
    const researchSupportedWaUnresolved=signalRows.filter(row=>Boolean(row?.researchSupported)&&String(row?.waGroundingStatus||"").startsWith("wa_unresolved")).length;
    const highRelevanceWaUnresolved=signalRows.filter(row=>Number(row?.relevanceScore)>=0.72&&String(row?.waGroundingStatus||"").startsWith("wa_unresolved")).length;
    const localNoWaExpectation=signalRows.filter(row=>row?.waGroundingStatus==="wa_not_suitable").length;
    const avgRelevance=signalRows.length?signalRows.reduce((sum,row)=>sum+Number(row?.relevanceScore||0),0)/signalRows.length:0;
    const avgEvidenceSupport=signalRows.length?signalRows.reduce((sum,row)=>sum+Number(row?.evidenceSupportScore||0),0)/signalRows.length:0;
    addRow("TOTAL NODES",groundingStats.totalNodes,"var(--accent)");
    addRow("WA GROUNDED NODES %",`${groundedPct}%`,groundedCol);
    addRow("WA OUTCOME COVERAGE %",`${outcomeCoveragePct}%`,outcomeCoverageCol);
    addRow("WA OUTCOME: GROUNDED (APPLIED)",Number(outcomeBreakdown.grounded||0),termGroundingOutcomeColor("grounded"));
    addRow("WA OUTCOME: GROUNDED (METADATA-ONLY)",Number(outcomeBreakdown.metadata_only||0),termGroundingOutcomeColor("metadata_only"));
    addRow("WA OUTCOME: UNRESOLVED",Number(outcomeBreakdown.rejected||0),termGroundingOutcomeColor("rejected"));
    addRow("WA OUTCOME: NOT SUITABLE (LOCAL)",Number(outcomeBreakdown.local_defined||0),termGroundingOutcomeColor("local_defined"));
    addRow("WA OUTCOME: NOT ATTEMPTED",Number(outcomeBreakdown.not_attempted||0),termGroundingOutcomeColor("not_attempted"));
    addRow("AMBIGUOUS WA MATCHES",groundingStats.ambiguousWaMatches,ambiguousCol);
    addRow("WA UNRESOLVED AFTER ATTEMPTS",attemptedRejectedTerms,failureCol);
    addRow("RESEARCH-SUPPORTED + WA UNRESOLVED",researchSupportedWaUnresolved,researchSupportedWaUnresolved>0?"#d97706":"#16a34a");
    addRow("HIGH RELEVANCE + WA UNRESOLVED",highRelevanceWaUnresolved,highRelevanceWaUnresolved>0?"#d97706":"#16a34a");
    addRow("LOCAL CONSTRUCTS (NO WA EXPECTATION)",localNoWaExpectation,localNoWaExpectation>0?"#0ea5e9":"#64748b");
    addRow("AVG RELEVANCE SCORE",avgRelevance.toFixed(2),avgRelevance>=0.65?"#16a34a":avgRelevance>=0.45?"#d97706":"#dc2626");
    addRow("AVG EVIDENCE SUPPORT SCORE",avgEvidenceSupport.toFixed(2),avgEvidenceSupport>=0.65?"#16a34a":avgEvidenceSupport>=0.45?"#d97706":"#dc2626");
    const pendingAmbiguity=getPendingAmbiguityCount();
    addRow("AMBIGUITY QUEUE (PENDING)",pendingAmbiguity,pendingAmbiguity>0?"#d97706":"#16a34a");
    addRow("WA ACCEPTED",Number(groundingStats.accepted_wolfram||0),Number(groundingStats.accepted_wolfram||0)>0?"#16a34a":"#64748b");
    addRow("WA UNRESOLVED",Number(groundingStats.rejected_wolfram||0),Number(groundingStats.rejected_wolfram||0)===0?"#16a34a":"#dc2626");
    addRow("ACCEPTED BUT LOW ALIGN",Number(groundingStats.accepted_but_low_alignment||0),Number(groundingStats.accepted_but_low_alignment||0)===0?"#16a34a":"#d97706");
    addRow("DICT-ONLY GROUNDINGS",Number(groundingStats.dictionary_only_groundings||0),Number(groundingStats.dictionary_only_groundings||0)===0?"#16a34a":"#d97706");
    addRow("LIKELY CAT MISMATCH",Number(groundingStats.likely_category_mismatch||0),Number(groundingStats.likely_category_mismatch||0)===0?"#16a34a":"#d97706");
    addRow("METADATA-ONLY TERMS",Number(groundingStats.metadata_only_terms||0),Number(groundingStats.metadata_only_terms||0)===0?"#16a34a":"#d97706");
    addRow("AVG CITATIONS / NODE",groundingStats.avgCitationsPerNode.toFixed(2),groundingStats.avgCitationsPerNode>=1?"#16a34a":"#d97706");
    addRow("NODES W/ NO CITATIONS",`${groundingStats.nodesWithNoCitations} (${noCitePct}%)`,groundingStats.nodesWithNoCitations===0?"#16a34a":"#d97706");
    const topSources=Object.entries(sourceTypeBreakdown).slice(0,3).map(([k,v])=>`${sourceTypeLabel(k)}:${v}`).join(" | ");
    if(topSources){
      const srcNote=document.createElement("div");
      srcNote.className="matrix-note";
      srcNote.style.marginTop="6px";
      srcNote.textContent=`Source mix: ${topSources}`;
      sr.appendChild(srcNote);
    }
    if(warnings.length){
      const warn=document.createElement("div");
      warn.className="matrix-note";
      warn.style.marginTop="6px";
      warn.textContent=`Grounding diagnostics: ${warnings.slice(0,3).join(" | ")}${warnings.length>3?" ...":""}`;
      sr.appendChild(warn);
    }
  }
  renderGenericInterpretationHotspotAudit(WOLFRAM_GROUNDING_DIAGNOSTICS);
  renderEmbeddingDiagnostics();
  renderCAPanel();
}
function buildSurface(discId,anchors,poolTerms=TERMS){const points=(poolTerms||[]).filter(t=>t.slices.includes(discId));if(points.length<3) return null;const col=DISCS[discId]?.col||"#fff";const cx=points.reduce((s,t)=>s+t.pos[0],0)/points.length;const cy=points.reduce((s,t)=>s+t.pos[1],0)/points.length;const cz=points.reduce((s,t)=>s+t.pos[2],0)/points.length;const baseDir=anchors[discId]||fallbackDirection(discId);const dir=normalize3(baseDir,fallbackDirection(discId));const tmp=Math.abs(dir[0])<0.9?[1,0,0]:[0,1,0];const u=[tmp[1]*dir[2]-tmp[2]*dir[1],tmp[2]*dir[0]-tmp[0]*dir[2],tmp[0]*dir[1]-tmp[1]*dir[0]];const unitU=normalize3(u,[0,1,0]);const v=[dir[1]*unitU[2]-dir[2]*unitU[1],dir[2]*unitU[0]-dir[0]*unitU[2],dir[0]*unitU[1]-dir[1]*unitU[0]];const angles=points.map(term=>{const dx=term.pos[0]-cx,dy=term.pos[1]-cy,dz=term.pos[2]-cz;return Math.atan2(dx*v[0]+dy*v[1]+dz*v[2],dx*unitU[0]+dy*unitU[1]+dz*unitU[2]);});const sorted=[...points.map((_,i)=>i)].sort((a,b)=>angles[a]-angles[b]);const x=[cx],y=[cy],z=[cz];for(const idx of sorted){x.push(points[idx].pos[0]);y.push(points[idx].pos[1]);z.push(points[idx].pos[2]);}x.push(points[sorted[0]].pos[0]);y.push(points[sorted[0]].pos[1]);z.push(points[sorted[0]].pos[2]);const i=[],j=[],k=[];const n=sorted.length;for(let q=1;q<=n;q++){i.push(0);j.push(q);k.push(q<n?q+1:1);}return {type:"mesh3d",x,y,z,i,j,k,color:col,opacity:0.09,hoverinfo:"none",showlegend:false,flatshading:true,lighting:{ambient:0.9,diffuse:0.1}};}
function markerSizeByCentrality(term,minSize,maxSize){const c=clamp01(term?.centrality??0.5);return minSize+(maxSize-minSize)*c;}
function getGroundingConfidenceRank(term){const level=String(term?.grounding?.wolframConfidence?.level||"none").toLowerCase();if(level==="high") return 3;if(level==="medium") return 2;if(level==="low") return 1;const score=Number(term?.grounding?.wolframConfidence?.score);if(Number.isFinite(score)){if(score>=0.75) return 3;if(score>=0.4) return 2;if(score>0) return 1;}return 0;}
function groundingColorForTerm(term){const outcome=getTermGroundingOutcome(term);const rank=getGroundingConfidenceRank(term);if(outcome==="grounded"){if(rank>=3) return "#16a34a";if(rank>=2) return "#0ea5e9";return "#84cc16";}if(outcome==="metadata_only") return "#f59e0b";if(outcome==="rejected") return "#ef4444";if(outcome==="local_defined") return "#0ea5e9";return "#64748b";}
function hasWolframGrounding(term){const grounding=term?.grounding||{};return Boolean((grounding?.wolframQueriesTried||[]).length||(grounding?.wolframEntities||[]).length||(grounding?.wolframInterpretations||[]).length);}
function isUnresolvedGrounding(term){const outcome=getTermGroundingOutcome(term);if(outcome==="rejected") return true;if(outcome==="not_attempted"||outcome==="local_defined") return false;const interpretations=(term?.grounding?.wolframInterpretations||[]);if(Array.isArray(interpretations)&&interpretations.length>1) return true;const resolution=String(term?.grounding?.wolframResolution||"").toLowerCase();if(/fallback|ambiguous|did.?you.?mean/.test(resolution)) return true;return false;}
function appendGroundingOverlayTraces(traces,pool){if(!showGroundingOverlays||!Array.isArray(pool)||!pool.length) return;const haloHigh=[],haloMed=[],haloLow=[],unresolved=[];for(const term of pool){if(!term) continue;if(isUnresolvedGrounding(term)){unresolved.push(term);continue;}if(getTermGroundingOutcome(term)==="grounded"){const rank=getGroundingConfidenceRank(term);if(rank>=3) haloHigh.push(term);else if(rank>=2) haloMed.push(term);else haloLow.push(term);}}const ringTrace=(terms,name,color,sizeBoost,lineWidth,symbol,showlegend,legendgroup)=>{if(!terms.length) return null;return {type:"scatter3d",mode:"markers",name,x:terms.map(t=>t.pos[0]),y:terms.map(t=>t.pos[1]),z:terms.map(t=>t.pos[2]),text:terms.map(t=>t.label),hovertemplate:"<b>%{text}</b><br><i>grounding overlay</i><extra></extra>",marker:{symbol,size:terms.map(t=>markerSizeByCentrality(t,8,16)+sizeBoost),color:"rgba(0,0,0,0)",line:{color,width:lineWidth},opacity:0.95},legendgroup,showlegend};};const highTrace=ringTrace(haloHigh,"Grounded Halo (high confidence)","#22c55e",8,3.1,"circle-open",true,"grounding-halo");const medTrace=ringTrace(haloMed,"Grounded Halo (medium confidence)","#14b8a6",7,2.1,"circle-open",true,"grounding-halo");const lowTrace=ringTrace(haloLow,"Grounded Halo (low confidence)","#84cc16",6,1.2,"circle-open",false,"grounding-halo");const unresolvedTrace=ringTrace(unresolved,"Unresolved / ambiguous","#f97316",9,2.2,"circle-open-dot",true,"grounding-ambiguous");for(const trace of [highTrace,medTrace,lowTrace,unresolvedTrace]){if(trace) traces.push(trace);}}
function buildTraces(visibleTerms=getVisibleNodeTerms()){const traces=[];const pool=Array.isArray(visibleTerms)?visibleTerms:[];const anchors=computeDisciplineAnchors(pool);if(showSurfaces){for(const d of DISCS){if(!activeSlices.has(d.id)) continue;const surface=buildSurface(d.id,anchors,pool);if(surface) traces.push(surface);}}for(const d of DISCS){if(!activeSlices.has(d.id)) continue;const dir=normalize3(anchors[d.id],fallbackDirection(d.id));const tip=dir.map(v=>v*1.55);const labelPos=dir.map(v=>v*1.72);traces.push({type:"scatter3d",mode:"lines",x:[0,tip[0]],y:[0,tip[1]],z:[0,tip[2]],line:{color:d.col+"28",width:1.2},hoverinfo:"none",showlegend:false});traces.push({type:"scatter3d",mode:"text",x:[labelPos[0]],y:[labelPos[1]],z:[labelPos[2]],text:[d.abbr],textfont:{color:d.col,size:9,family:"Courier New"},textposition:"middle center",hoverinfo:"none",showlegend:false});}
if(activeTypes.has("unique")){for(const d of DISCS){if(!activeSlices.has(d.id)) continue;const ts=pool.filter(t=>t.type==="unique"&&t.slices[0]===d.id);if(!ts.length) continue;const colors=ts.map(t=>nodeColorMode==="grounding"?groundingColorForTerm(t):d.col);traces.push({type:"scatter3d",mode:"markers",name:d.abbr,x:ts.map(t=>t.pos[0]),y:ts.map(t=>t.pos[1]),z:ts.map(t=>t.pos[2]),text:ts.map(t=>t.label),customdata:ts.map(t=>clamp01(t.centrality)),hovertemplate:`<b>%{text}</b><br>${d.name}<br>centrality %{customdata:.2f}<br><i>unique</i><extra></extra>`,marker:{color:colors,size:ts.map(t=>markerSizeByCentrality(t,6,14)),opacity:nodeColorMode==="grounding"?0.92:0.85,symbol:"circle",line:{color:nodeColorMode==="grounding"?"#0f172a66":d.col+"66",width:nodeColorMode==="grounding"?1.1:0.5}},legendgroup:d.abbr,showlegend:true});}} 
if(activeTypes.has("convergent")){const ts=pool.filter(t=>t.type==="convergent");if(ts.length){const colors=ts.map(t=>{if(nodeColorMode==="grounding") return groundingColorForTerm(t);const n=t.slices.length;if(n>=6) return "#fff";if(n>=4) return "#aaaaff";if(n>=2) return "#7777cc";return "#5555aa";});traces.push({type:"scatter3d",mode:"markers",name:"Convergent",x:ts.map(t=>t.pos[0]),y:ts.map(t=>t.pos[1]),z:ts.map(t=>t.pos[2]),text:ts.map(t=>t.label),customdata:ts.map(t=>t.slices.length),hovertemplate:"<b>%{text}</b><br>%{customdata} disciplines<br><i>convergent</i><extra></extra>",marker:{color:colors,size:ts.map(t=>markerSizeByCentrality(t,8,18)+(t.slices.length/(DISCS.length||7))*4),opacity:nodeColorMode==="grounding"?0.95:0.92,symbol:"diamond",line:{color:nodeColorMode==="grounding"?"#0f172a88":"#ffffff44",width:nodeColorMode==="grounding"?1.2:0.5}},legendgroup:"convergent",showlegend:true});}}
if(activeTypes.has("contradictory")){const ts=pool.filter(t=>t.type==="contradictory");if(ts.length){const edgeX=[],edgeY=[],edgeZ=[];for(const term of ts){for(const slice of term.slices){if(!activeSlices.has(slice)) continue;const anchor=anchors[slice];if(!anchor) continue;edgeX.push(term.pos[0],anchor[0],null);edgeY.push(term.pos[1],anchor[1],null);edgeZ.push(term.pos[2],anchor[2],null);}}if(edgeX.length){traces.push({type:"scatter3d",mode:"lines",name:"Contradiction Edges",x:edgeX,y:edgeY,z:edgeZ,line:{color:"#ff950044",width:1.3},hoverinfo:"none",legendgroup:"contradictory",showlegend:false});}const colors=ts.map(t=>nodeColorMode==="grounding"?groundingColorForTerm(t):"#ff9500");traces.push({type:"scatter3d",mode:"markers",name:"Contradictory",x:ts.map(t=>t.pos[0]),y:ts.map(t=>t.pos[1]),z:ts.map(t=>t.pos[2]),text:ts.map(t=>t.label),hovertemplate:"<b>%{text}</b><br><i>tension zone</i><extra></extra>",marker:{color:colors,size:ts.map(t=>markerSizeByCentrality(t,12,22)),opacity:1,symbol:"cross",line:{color:nodeColorMode==="grounding"?"#0f172a88":"#ffcc00",width:nodeColorMode==="grounding"?1.3:1.5}},legendgroup:"contradictory",showlegend:true});}}
if(activeTypes.has("emergent")){const ts=pool.filter(t=>t.type==="emergent");if(ts.length){const colors=ts.map(t=>nodeColorMode==="grounding"?groundingColorForTerm(t):"#ffd700");traces.push({type:"scatter3d",mode:"markers+text",name:"Emergent",x:ts.map(t=>t.pos[0]),y:ts.map(t=>t.pos[1]),z:ts.map(t=>t.pos[2]),text:ts.map(t=>t.label),textposition:"top center",textfont:{color:"#ffd700",size:9,family:"Courier New"},hovertemplate:"<b>%{text}</b><br><i>synthesis only</i><extra></extra>",marker:{color:colors,size:ts.map(t=>markerSizeByCentrality(t,14,26)),opacity:1,symbol:"star",line:{color:nodeColorMode==="grounding"?"#0f172a88":"#fff",width:nodeColorMode==="grounding"?1.4:1.5}},legendgroup:"emergent",showlegend:true});}}
appendGroundingOverlayTraces(traces,pool);
return traces;}
function getPlotLayout(){const theme=document.documentElement.getAttribute("data-theme")||"light";if(theme==="dark"){return {paper_bgcolor:"#0b1020",plot_bgcolor:"#0b1020",scene:{bgcolor:"#0b1020",xaxis:{showgrid:false,zeroline:false,showticklabels:false,showline:false,visible:false},yaxis:{showgrid:false,zeroline:false,showticklabels:false,showline:false,visible:false},zaxis:{showgrid:false,zeroline:false,showticklabels:false,showline:false,visible:false},camera:{eye:{x:1.7,y:1.7,z:1.2},center:{x:0,y:0,z:0}},aspectmode:"cube"},legend:{bgcolor:"#111827",bordercolor:"#334155",borderwidth:1,font:{color:"#e2e8f0",family:"Courier New",size:12},x:0.01,y:0.99,xanchor:"left",yanchor:"top"},margin:{l:0,r:0,b:0,t:0},hoverlabel:{bgcolor:"#111827",bordercolor:"#64748b",font:{color:"#f8fafc",family:"Courier New",size:13}}};}if(theme==="contrast"){return {paper_bgcolor:"#000000",plot_bgcolor:"#000000",scene:{bgcolor:"#000000",xaxis:{showgrid:false,zeroline:false,showticklabels:false,showline:false,visible:false},yaxis:{showgrid:false,zeroline:false,showticklabels:false,showline:false,visible:false},zaxis:{showgrid:false,zeroline:false,showticklabels:false,showline:false,visible:false},camera:{eye:{x:1.7,y:1.7,z:1.2},center:{x:0,y:0,z:0}},aspectmode:"cube"},legend:{bgcolor:"#000000",bordercolor:"#ffffff",borderwidth:1,font:{color:"#ffffff",family:"Courier New",size:12},x:0.01,y:0.99,xanchor:"left",yanchor:"top"},margin:{l:0,r:0,b:0,t:0},hoverlabel:{bgcolor:"#000000",bordercolor:"#ffffff",font:{color:"#ffffff",family:"Courier New",size:13}}};}return {paper_bgcolor:"#f4f7ff",plot_bgcolor:"#f4f7ff",scene:{bgcolor:"#f4f7ff",xaxis:{showgrid:false,zeroline:false,showticklabels:false,showline:false,visible:false},yaxis:{showgrid:false,zeroline:false,showticklabels:false,showline:false,visible:false},zaxis:{showgrid:false,zeroline:false,showticklabels:false,showline:false,visible:false},camera:{eye:{x:1.7,y:1.7,z:1.2},center:{x:0,y:0,z:0}},aspectmode:"cube"},legend:{bgcolor:"#ffffff",bordercolor:"#cbd5e1",borderwidth:1,font:{color:"#334155",family:"Courier New",size:12},x:0.01,y:0.99,xanchor:"left",yanchor:"top"},margin:{l:0,r:0,b:0,t:0},hoverlabel:{bgcolor:"#ffffff",bordercolor:"#94a3b8",font:{color:"#0f172a",family:"Courier New",size:13}}};}
const CONFIG={responsive:true,displaylogo:false,modeBarButtonsToRemove:["toImage","sendDataToCloud"]};
function renderPlot(){const visibleTerms=getVisibleNodeTerms();document.getElementById("vis-count").textContent=visibleTerms.length;renderNodeFilterResults();const traces=buildTraces(visibleTerms);const layout=getPlotLayout();if(!plotInited){Plotly.newPlot("plot",traces,layout,CONFIG);plotInited=true;}else{Plotly.react("plot",traces,layout,CONFIG);}}
function formatProvenanceLine(item){const source=String(item?.source||"unknown").toUpperCase();const impact=String(item?.impact||item?.stage||"").trim();const note=String(item?.note||"").trim();const query=String(item?.query||"").trim();const parts=[`[${source}]`];if(impact) parts.push(impact);if(note) parts.push(note);if(query) parts.push(`query: ${query}`);return parts.join(" | ");}
function getLinkedCitationsForTerm(term){const ids=Array.isArray(term?.citations)?term.citations:[];const out=[];for(const id of ids){const cite=CITATIONS.find(c=>c.id===id);if(cite) out.push(cite);}return out;}
function safeHttpUrl(url){const text=String(url||"").trim();if(/^https?:\/\//i.test(text)) return text;return "";}
function summarizeWhyNodeExists(term,sliceNames){if(term.type==="unique"){return `Unique node from a single probe perspective (${sliceNames[0]||"unlabeled probe"}).`;}if(term.type==="convergent"){return `Convergent node synthesized across ${sliceNames.length||0} probe(s) where similar concepts aligned.`;}if(term.type==="contradictory"){return `Contradictory node marks tension across ${sliceNames.length||0} probe(s) with incompatible claims or frames.`;}if(term.type==="emergent"){return "Emergent node added at synthesis stage; it does not originate from one probe alone.";}return "Node included from probe/synthesis output.";}
function resolveChosenWolframQuery(grounding,provenance){const fromProv=[...(provenance||[])].reverse().find(item=>String(item?.source||"").toLowerCase()==="wolfram"&&String(item?.query||"").trim());if(fromProv?.query) return String(fromProv.query).trim();const queries=Array.isArray(grounding?.wolframQueriesTried)?grounding.wolframQueriesTried:[];const resolution=String(grounding?.wolframResolution||"");const fallbackMatch=resolution.match(/fallback\s*#\s*(\d+)/i);if(fallbackMatch){const idx=Math.max(1,Number(fallbackMatch[1]))-1;if(queries[idx]) return String(queries[idx]);}return String(queries[0]||"").trim();}
function buildTermDescriptionDetail(term){
  applyDisplayDescriptionForTerm(term,{fallbackDescription:term?.description,fallbackSource:term?.description_source});
  const descriptions=normalizeTermDescriptions(term?.descriptions,{fallbackDescription:term?.description,fallbackSource:term?.description_source,label:term?.label});
  const desc=String(descriptions.displayDescription||term?.description||"").trim();
  const source=String(term?.description_source||"").trim().toLowerCase()||"unknown";
  const grounding=term?.grounding&&typeof term.grounding==="object"?term.grounding:null;
  const groundingEligibility=normalizeGroundingEligibility(grounding?.groundingEligibility||"eligible");
  const groundingSkipReason=String(grounding?.groundingSkipReason||"").trim();
  const confLevel=String(grounding?.wolframConfidence?.level||"none");
  const confScore=Number.isFinite(Number(grounding?.wolframConfidence?.score))?Number(grounding.wolframConfidence.score):null;
  const resolution=String(grounding?.wolframResolution||"").trim();
  const chosenInterpretation=String(grounding?.wolframChosenInterpretation||"").trim();
  const interpretations=Array.isArray(grounding?.wolframInterpretations)?grounding.wolframInterpretations.filter(Boolean):[];
  const provenance=Array.isArray(term?.description_provenance)?term.description_provenance.slice(0,10):[];
  const linkedCitations=getLinkedCitationsForTerm(term);
  const researchCitations=getResearchCitationsForTerm(term);
  const wolframCitations=getWolframCitationsForTerm(term);
  const selectedWolfram=wolframCitations[0]||null;
  const queryUsed=resolveChosenWolframQuery(grounding,provenance);
  const selectedFact=String(descriptions.wolframGrounding||selectedWolfram?.wolfram_best_definition||selectedWolfram?.quote_or_snippet||"").trim();
  const altFacts=[...new Set(wolframCitations.flatMap(c=>Array.isArray(c?.wolfram_alt_facts)?c.wolfram_alt_facts:[]).map(x=>String(x||"").trim()).filter(Boolean))];
  const didYouMeans=[...new Set(wolframCitations.flatMap(c=>Array.isArray(c?.wolfram_did_you_means)?c.wolfram_did_you_means:[]).map(x=>String(x||"").trim()).filter(Boolean))];
  const assumptions=[...new Set(wolframCitations.flatMap(c=>Array.isArray(c?.wolfram_assumptions)?c.wolfram_assumptions:[]).map(x=>String(x||"").trim()).filter(Boolean))];
  const warnings=[...new Set(wolframCitations.flatMap(c=>Array.isArray(c?.wolfram_warnings)?c.wolfram_warnings:[]).map(x=>String(x||"").trim()).filter(Boolean))];
  const sliceNames=(Array.isArray(term?.slices)?term.slices:[]).map(i=>DISCS[i]?.name).filter(Boolean);
  const probeCount=sliceNames.length;
  const sourceCount=linkedCitations.length;
  const whyNode=summarizeWhyNodeExists(term,sliceNames);
  const signal=getTermSignalModel(term);
  const termOutcome=signal.outcome;
  const termOutcomeLabel=termGroundingOutcomeLabel(termOutcome);
  const termOutcomeCol=termGroundingOutcomeColor(termOutcome);
  const waStatusLabel=waTermStatusLabel(signal.waGroundingStatus);
  const waStatusCol=waTermStatusColor(signal.waGroundingStatus);
  const relevanceScore=Number(signal.relevanceScore||0).toFixed(2);
  const evidenceScore=Number(signal.evidenceSupportScore||0).toFixed(2);
  const stateBadge=signal.stateBadge||"Relevant | WA status pending";
  const ambiguityCount=didYouMeans.length+warnings.length+assumptions.length+Math.max(0,interpretations.length-(chosenInterpretation?1:0))+altFacts.length;
  const probeLayer=String(descriptions.probeSummary||"").trim();
  const synthesisLayer=String(descriptions.synthesisSummary||"").trim();
  const wolframLayer=String(descriptions.wolframGrounding||"").trim();
  const displayReason=String(descriptions.displayDescriptionReason||"").trim();
  const provenanceRows=provenance.length?provenance.map(item=>`<div style="font-size:12px;color:var(--muted);margin-top:3px">- ${escapeHtml(formatProvenanceLine(item))}</div>`).join(""):`<div style="font-size:12px;color:var(--muted);font-style:italic">No provenance entries</div>`;
  const alternativesContent=ambiguityCount?[
    didYouMeans.length?`<div style="font-size:12px;color:var(--muted);margin-top:4px"><strong>Did-you-mean:</strong> ${escapeHtml(didYouMeans.slice(0,8).join(" | "))}</div>`:"",
    warnings.length?`<div style="font-size:12px;color:var(--muted);margin-top:4px"><strong>Warnings:</strong> ${escapeHtml(warnings.slice(0,6).join(" | "))}</div>`:"",
    assumptions.length?`<div style="font-size:12px;color:var(--muted);margin-top:4px"><strong>Assumptions:</strong> ${escapeHtml(assumptions.slice(0,6).join(" | "))}</div>`:"",
    altFacts.length?`<div style="font-size:12px;color:var(--muted);margin-top:4px"><strong>Alternative facts:</strong> ${escapeHtml(altFacts.slice(0,6).join(" | "))}</div>`:"",
    interpretations.length?`<div style="font-size:12px;color:var(--muted);margin-top:4px"><strong>Interpretation candidates:</strong> ${escapeHtml(interpretations.slice(0,10).join(" | "))}</div>`:""
  ].filter(Boolean).join(""):`<div style="font-size:12px;color:var(--muted);font-style:italic;margin-top:4px">No notable ambiguities captured.</div>`;
  return [
    `<div>${escapeHtml(desc||"No description available.")}</div>`,
    `<div style="font-size:12px;color:var(--muted);margin-top:4px">Display description built from: ${escapeHtml(displayReason||"unspecified")}</div>`,
    probeLayer?`<div style="font-size:12px;color:var(--muted);margin-top:3px"><strong>probeSummary:</strong> ${escapeHtml(probeLayer)}</div>`:"",
    synthesisLayer?`<div style="font-size:12px;color:var(--muted);margin-top:3px"><strong>synthesisSummary:</strong> ${escapeHtml(synthesisLayer)}</div>`:"",
    wolframLayer?`<div style="font-size:12px;color:var(--muted);margin-top:3px"><strong>wolframGrounding:</strong> ${escapeHtml(wolframLayer)}</div>`:"",
    `<div class="tag-row" style="margin-top:8px"><span class="tag strong">${escapeHtml(stateBadge)}</span><span class="tag" style="border-color:${termOutcomeCol};color:${termOutcomeCol}">outcome: ${escapeHtml(termOutcomeLabel)}</span><span class="tag" style="border-color:${waStatusCol};color:${waStatusCol}">WA status: ${escapeHtml(waStatusLabel)}</span><span class="tag">WA eligibility: ${escapeHtml(groundingEligibility)}</span><span class="tag">WA confidence: ${escapeHtml(confLevel)}${confScore!==null?` (${confScore.toFixed(2)})`:""}</span><span class="tag">sources: ${sourceCount}</span><span class="tag">research sources: ${researchCitations.length}</span><span class="tag">probes mentioning: ${probeCount}</span></div>`,
    `<div class="sec-label" style="margin-top:8px">RELEVANCE AND SUPPORT AXES</div>`,
    `<div style="font-size:12px;color:var(--muted)">Relevance score (internal expedition signal): ${relevanceScore} (${escapeHtml(signal.relevanceBand)}).</div>`,
    `<div style="font-size:12px;color:var(--muted);margin-top:3px">Evidence support score (research citations + probe structure): ${evidenceScore} (${escapeHtml(signal.evidenceBand)}).</div>`,
    `<div style="font-size:12px;color:var(--muted);margin-top:3px">Display description source: ${escapeHtml(signal.displayDescriptionSource||source)}</div>`,
    `<div class="sec-label" style="margin-top:8px">SUPPORT HIERARCHY</div>`,
    `<div style="font-size:12px;color:var(--muted)"><strong>Primary:</strong> citations / papers (${escapeHtml(signal.primarySupportSummary)}).</div>`,
    `<div style="font-size:12px;color:var(--muted);margin-top:3px"><strong>Secondary:</strong> probe convergence + synthesis structure (${escapeHtml(signal.secondarySupportSummary)}).</div>`,
    `<div style="font-size:12px;color:var(--muted);margin-top:3px"><strong>Tertiary:</strong> Wolfram canonicalization (${escapeHtml(signal.tertiarySupportSummary)}).</div>`,
    `<div style="font-size:12px;color:var(--muted);margin-top:3px">Policy: WA status informs grounding display, not term relevance.</div>`,
    `<div class="sec-label" style="margin-top:8px">INTERPRETATION CHOSEN</div>`,
    `<div style="font-size:12px;color:var(--muted)">Query used: ${escapeHtml(queryUsed||"-")}</div>`,
    `<div style="font-size:12px;color:var(--muted);margin-top:3px">WA input interpretation: ${escapeHtml(chosenInterpretation||selectedWolfram?.wolfram_input_interpretation||"-")}</div>`,
    `<div style="font-size:12px;color:var(--muted);margin-top:3px">Selected definition/fact: ${escapeHtml(selectedFact||"-")}</div>`,
    groundingSkipReason?`<div style="font-size:12px;color:var(--muted);margin-top:3px">Skip reason: ${escapeHtml(groundingSkipReason)}</div>`:"",
    resolution?`<div style="font-size:12px;color:var(--muted);margin-top:3px">Resolution path: ${escapeHtml(resolution)}</div>`:"",
    `<details style="margin-top:8px"><summary style="cursor:pointer;font-size:12px;color:var(--text)">Alternatives and ambiguities (${ambiguityCount})</summary>${alternativesContent}</details>`,
    `<div class="sec-label" style="margin-top:8px">SOURCE PROVENANCE</div>${provenanceRows}`,
    `<div class="sec-label" style="margin-top:8px">WHY THIS NODE EXISTS</div>`,
    `<div style="font-size:12px;color:var(--muted)">${escapeHtml(whyNode)}</div>`,
    `<div style="font-size:12px;color:var(--muted);margin-top:3px">Probe slices: ${escapeHtml(sliceNames.join(" | ")||"synthesis only")}</div>`,
    `<div style="font-size:12px;color:var(--muted);margin-top:3px">Node class logic: ${escapeHtml(term.type)} (${escapeHtml(TYPE_CFG[term.type]?.desc||"")})</div>`
  ].filter(Boolean).join("");
}
function onPlotClick(data){
  if(!data.points?.[0]) return;
  const label=data.points[0].text;
  const term=getVisibleNodeTerms().find(t=>t.label===label)||TERMS.find(t=>t.label===label);
  if(!term) return;
  showTermDetail(term);
}
function resetToSetup(){if(plotInited) Plotly.purge("plot");plotInited=false;TERMS=[];DISCS=[];CITATIONS=[];CALL_LOGS=[];RUN_STATE=null;CURRENT_RUN_ID=null;activeSlices=new Set();activeTypes=new Set();sessionConfig=null;LAST_RUN=null;DISC_SIM_MATRIX=null;PROJECTION_STABILITY=null;CA_PROBE_OUTPUT=null;WOLFRAM_GROUNDING_DIAGNOSTICS=[];AMBIGUITY_QUEUE=[];CITATION_UNMAPPED_SUPPORTING_TERMS=[];lastReportText="";lastClaimsText="";lastOutlineText="";lastCritiqueText="";lastMarkdownText="";ACTIVE_ARTIFACT_KEY="";isGenerating=false;EVIDENCE_FILTER_STATE={sourceType:"all",termLabel:"",provider:"all"};clearNodeFilters();document.getElementById("evidence-filter-bar").innerHTML="";document.getElementById("evidence-modal-content").innerHTML="";document.getElementById("ambiguity-modal-content").innerHTML="";document.getElementById("detail").style.display="none";updateAmbiguityQueueUIState();renderCAPanel();renderNodeFilterResults();closeModal("raw-modal");closeModal("report-modal");closeModal("evidence-modal");closeModal("ambiguity-modal");closeModal("claims-modal");closeModal("outline-modal");closeModal("critique-modal");closeModal("replication-modal");closeModal("artifact-modal");setArtifactDrawer(false);setExportMenu(false);initArtifactStore();renderDisciplineInputs(clampInt(document.getElementById("lens-count-input")?.value||7,2,12),getCurrentProbeSpecs());switchMainTab("generator",{silent:true});}
</script>
</body>
</html>


